{
  "plywood_metadata": {
    "plywood_gallery_core_version": "0.0.12"
  },
  "plywood_content": {
    "01lines_bars_and_markers": [
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_001_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============\nBar color demo\n==============\n\nThis is an example showing how to control bar color and legend entries\nusing the *color* and *label* parameters of `~matplotlib.pyplot.bar`.\nNote that labels with a preceding underscore won't show up in the legend.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nfruits = ['apple', 'blueberry', 'cherry', 'orange']\ncounts = [40, 100, 30, 55]\nbar_labels = ['red', 'blue', '_red', 'orange']\nbar_colors = ['tab:red', 'tab:blue', 'tab:red', 'tab:orange']\n\nax.bar(fruits, counts, label=bar_labels, color=bar_colors)\n\nax.set_ylabel('fruit supply')\nax.set_title('Fruit supply by kind and color')\nax.legend(title='Fruit color')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_002_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============\nBar Label Demo\n==============\n\nThis example shows how to use the `~.Axes.bar_label` helper function\nto create bar chart labels.\n\nSee also the :doc:`grouped bar\n</gallery/lines_bars_and_markers/barchart>`,\n:doc:`stacked bar\n</gallery/lines_bars_and_markers/bar_stacked>` and\n:doc:`horizontal bar chart\n</gallery/lines_bars_and_markers/barh>` examples.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# %%\n# data from https://allisonhorst.github.io/palmerpenguins/\n\nspecies = ('Adelie', 'Chinstrap', 'Gentoo')\nsex_counts = {\n    'Male': np.array([73, 34, 61]),\n    'Female': np.array([73, 34, 58]),\n}\nwidth = 0.6  # the width of the bars: can also be len(x) sequence\n\n\nfig, ax = plt.subplots()\nbottom = np.zeros(3)\n\nfor sex, sex_count in sex_counts.items():\n    p = ax.bar(species, sex_count, width, label=sex, bottom=bottom)\n    bottom += sex_count\n\n    ax.bar_label(p, label_type='center')\n\nax.set_title('Number of penguins by sex')\nax.legend()\n\nplt.show()\n\n# %%\n# Horizontal bar chart\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# Example data\npeople = ('Tom', 'Dick', 'Harry', 'Slim', 'Jim')\ny_pos = np.arange(len(people))\nperformance = 3 + 10 * np.random.rand(len(people))\nerror = np.random.rand(len(people))\n\nfig, ax = plt.subplots()\n\nhbars = ax.barh(y_pos, performance, xerr=error, align='center')\nax.set_yticks(y_pos, labels=people)\nax.invert_yaxis()  # labels read top-to-bottom\nax.set_xlabel('Performance')\nax.set_title('How fast do you want to go today?')\n\n# Label with specially formatted floats\nax.bar_label(hbars, fmt='%.2f')\nax.set_xlim(right=15)  # adjust xlim to fit labels\n\nplt.show()\n\n# %%\n# Some of the more advanced things that one can do with bar labels\n\nfig, ax = plt.subplots()\n\nhbars = ax.barh(y_pos, performance, xerr=error, align='center')\nax.set_yticks(y_pos, labels=people)\nax.invert_yaxis()  # labels read top-to-bottom\nax.set_xlabel('Performance')\nax.set_title('How fast do you want to go today?')\n\n# Label with given captions, custom padding and annotate options\nax.bar_label(hbars, labels=[f'\u00b1{e:.2f}' for e in error],\n             padding=8, color='b', fontsize=14)\nax.set_xlim(right=16)\n\nplt.show()\n\n# %%\n# Bar labels using {}-style format string\n\nfruit_names = ['Coffee', 'Salted Caramel', 'Pistachio']\nfruit_counts = [4000, 2000, 7000]\n\nfig, ax = plt.subplots()\nbar_container = ax.bar(fruit_names, fruit_counts)\nax.set(ylabel='pints sold', title='Gelato sales by flavor', ylim=(0, 8000))\nax.bar_label(bar_container, fmt='{:,.0f}')\n\n# %%\n# Bar labels using a callable\n\nanimal_names = ['Lion', 'Gazelle', 'Cheetah']\nmph_speed = [50, 60, 75]\n\nfig, ax = plt.subplots()\nbar_container = ax.bar(animal_names, mph_speed)\nax.set(ylabel='speed in MPH', title='Running speeds', ylim=(0, 80))\nax.bar_label(bar_container, fmt=lambda x: f'{x * 1.61:.1f} km/h')\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`\n#    - `matplotlib.axes.Axes.barh` / `matplotlib.pyplot.barh`\n#    - `matplotlib.axes.Axes.bar_label` / `matplotlib.pyplot.bar_label`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_003_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================\nStacked bar chart\n=================\n\nThis is an example of creating a stacked bar plot\nusing `~matplotlib.pyplot.bar`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# data from https://allisonhorst.github.io/palmerpenguins/\n\nspecies = (\n    \"Adelie\\n $\\\\mu=$3700.66g\",\n    \"Chinstrap\\n $\\\\mu=$3733.09g\",\n    \"Gentoo\\n $\\\\mu=5076.02g$\",\n)\nweight_counts = {\n    \"Below\": np.array([70, 31, 58]),\n    \"Above\": np.array([82, 37, 66]),\n}\nwidth = 0.5\n\nfig, ax = plt.subplots()\nbottom = np.zeros(3)\n\nfor boolean, weight_count in weight_counts.items():\n    p = ax.bar(species, weight_count, width, label=boolean, bottom=bottom)\n    bottom += weight_count\n\nax.set_title(\"Number of penguins with above average body mass\")\nax.legend(loc=\"upper right\")\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_004_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============================\nGrouped bar chart with labels\n=============================\n\nThis example shows a how to create a grouped bar chart and how to annotate\nbars with labels.\n\"\"\"\n\n# data from https://allisonhorst.github.io/palmerpenguins/\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nspecies = (\"Adelie\", \"Chinstrap\", \"Gentoo\")\npenguin_means = {\n    'Bill Depth': (18.35, 18.43, 14.98),\n    'Bill Length': (38.79, 48.83, 47.50),\n    'Flipper Length': (189.95, 195.82, 217.19),\n}\n\nx = np.arange(len(species))  # the label locations\nwidth = 0.25  # the width of the bars\nmultiplier = 0\n\nfig, ax = plt.subplots(layout='constrained')\n\nfor attribute, measurement in penguin_means.items():\n    offset = width * multiplier\n    rects = ax.bar(x + offset, measurement, width, label=attribute)\n    ax.bar_label(rects, padding=3)\n    multiplier += 1\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_ylabel('Length (mm)')\nax.set_title('Penguin attributes by species')\nax.set_xticks(x + width, species)\nax.legend(loc='upper left', ncols=3)\nax.set_ylim(0, 250)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`\n#    - `matplotlib.axes.Axes.bar_label` / `matplotlib.pyplot.bar_label`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_005_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n====================\nHorizontal bar chart\n====================\n\nThis example showcases a simple horizontal bar chart.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\n\n# Example data\npeople = ('Tom', 'Dick', 'Harry', 'Slim', 'Jim')\ny_pos = np.arange(len(people))\nperformance = 3 + 10 * np.random.rand(len(people))\nerror = np.random.rand(len(people))\n\nax.barh(y_pos, performance, xerr=error, align='center')\nax.set_yticks(y_pos, labels=people)\nax.invert_yaxis()  # labels read top-to-bottom\nax.set_xlabel('Performance')\nax.set_title('How fast do you want to go today?')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_006_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========\nBroken Barh\n===========\n\nMake a \"broken\" horizontal bar plot, i.e., one with gaps\n\"\"\"\nimport matplotlib.pyplot as plt\n\n# Horizontal bar plot with gaps\nfig, ax = plt.subplots()\nax.broken_barh([(110, 30), (150, 10)], (10, 9), facecolors='tab:blue')\nax.broken_barh([(10, 50), (100, 20), (130, 10)], (20, 9),\n               facecolors=('tab:orange', 'tab:green', 'tab:red'))\nax.set_ylim(5, 35)\nax.set_xlim(0, 200)\nax.set_xlabel('seconds since start')\nax.set_yticks([15, 25], labels=['Bill', 'Jim'])     # Modify y-axis tick labels\nax.grid(True)                                       # Make grid lines visible\nax.annotate('race interrupted', (61, 25),\n            xytext=(0.8, 0.9), textcoords='axes fraction',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            fontsize=16,\n            horizontalalignment='right', verticalalignment='top')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_007_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========\nCapStyle\n=========\n\nThe `matplotlib._enums.CapStyle` controls how Matplotlib draws the corners\nwhere two different line segments meet. For more details, see the\n`~matplotlib._enums.CapStyle` docs.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib._enums import CapStyle\n\nCapStyle.demo()\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_008_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============================\nPlotting categorical variables\n==============================\n\nYou can pass categorical values (i.e. strings) directly as x- or y-values to\nmany plotting functions:\n\"\"\"\nimport matplotlib.pyplot as plt\n\ndata = {'apple': 10, 'orange': 15, 'lemon': 5, 'lime': 20}\nnames = list(data.keys())\nvalues = list(data.values())\n\nfig, axs = plt.subplots(1, 3, figsize=(9, 3), sharey=True)\naxs[0].bar(names, values)\naxs[1].scatter(names, values)\naxs[2].plot(names, values)\nfig.suptitle('Categorical Plotting')\n\n\n# %%\n# This works on both axes:\n\ncat = [\"bored\", \"happy\", \"bored\", \"bored\", \"happy\", \"bored\"]\ndog = [\"happy\", \"happy\", \"happy\", \"happy\", \"bored\", \"bored\"]\nactivity = [\"combing\", \"drinking\", \"feeding\", \"napping\", \"playing\", \"washing\"]\n\nfig, ax = plt.subplots()\nax.plot(activity, dog, label=\"dog\")\nax.plot(activity, cat, label=\"cat\")\nax.legend()\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_009_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=====================================\nPlotting the coherence of two signals\n=====================================\n\nAn example showing how to plot the coherence of two signals.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\ndt = 0.01\nt = np.arange(0, 30, dt)\nnse1 = np.random.randn(len(t))                 # white noise 1\nnse2 = np.random.randn(len(t))                 # white noise 2\n\n# Two signals with a coherent part at 10 Hz and a random part\ns1 = np.sin(2 * np.pi * 10 * t) + nse1\ns2 = np.sin(2 * np.pi * 10 * t) + nse2\n\nfig, axs = plt.subplots(2, 1)\naxs[0].plot(t, s1, t, s2)\naxs[0].set_xlim(0, 2)\naxs[0].set_xlabel('Time')\naxs[0].set_ylabel('s1 and s2')\naxs[0].grid(True)\n\ncxy, f = axs[1].cohere(s1, s2, 256, 1. / dt)\naxs[1].set_ylabel('Coherence')\n\nfig.tight_layout()\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_010_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========\nCSD Demo\n========\n\nCompute the cross spectral density of two signals\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, (ax1, ax2) = plt.subplots(2, 1)\n# make a little extra space between the subplots\nfig.subplots_adjust(hspace=0.5)\n\ndt = 0.01\nt = np.arange(0, 30, dt)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nnse1 = np.random.randn(len(t))                 # white noise 1\nnse2 = np.random.randn(len(t))                 # white noise 2\nr = np.exp(-t / 0.05)\n\ncnse1 = np.convolve(nse1, r, mode='same') * dt   # colored noise 1\ncnse2 = np.convolve(nse2, r, mode='same') * dt   # colored noise 2\n\n# two signals with a coherent part and a random part\ns1 = 0.01 * np.sin(2 * np.pi * 10 * t) + cnse1\ns2 = 0.01 * np.sin(2 * np.pi * 10 * t) + cnse2\n\nax1.plot(t, s1, t, s2)\nax1.set_xlim(0, 5)\nax1.set_xlabel('Time')\nax1.set_ylabel('s1 and s2')\nax1.grid(True)\n\ncxy, f = ax2.csd(s1, s2, 256, 1. / dt)\nax2.set_ylabel('CSD (dB)')\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_011_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=====================\nCurve with error band\n=====================\n\nThis example illustrates how to draw an error band around a parametrized curve.\n\nA parametrized curve x(t), y(t) can directly be drawn using `~.Axes.plot`.\n\"\"\"\n# sphinx_gallery_thumbnail_number = 2\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\n\nN = 400\nt = np.linspace(0, 2 * np.pi, N)\nr = 0.5 + np.cos(t)\nx, y = r * np.cos(t), r * np.sin(t)\n\nfig, ax = plt.subplots()\nax.plot(x, y, \"k\")\nax.set(aspect=1)\n\n# %%\n# An error band can be used to indicate the uncertainty of the curve.\n# In this example we assume that the error can be given as a scalar *err*\n# that describes the uncertainty perpendicular to the curve in every point.\n#\n# We visualize this error as a colored band around the path using a\n# `.PathPatch`. The patch is created from two path segments *(xp, yp)*, and\n# *(xn, yn)* that are shifted by +/- *err* perpendicular to the curve *(x, y)*.\n#\n# Note: This method of using a `.PathPatch` is suited to arbitrary curves in\n# 2D. If you just have a standard y-vs.-x plot, you can use the simpler\n# `~.Axes.fill_between` method (see also\n# :doc:`/gallery/lines_bars_and_markers/fill_between_demo`).\n\n\ndef draw_error_band(ax, x, y, err, **kwargs):\n    # Calculate normals via centered finite differences (except the first point\n    # which uses a forward difference and the last point which uses a backward\n    # difference).\n    dx = np.concatenate([[x[1] - x[0]], x[2:] - x[:-2], [x[-1] - x[-2]]])\n    dy = np.concatenate([[y[1] - y[0]], y[2:] - y[:-2], [y[-1] - y[-2]]])\n    l = np.hypot(dx, dy)\n    nx = dy / l\n    ny = -dx / l\n\n    # end points of errors\n    xp = x + nx * err\n    yp = y + ny * err\n    xn = x - nx * err\n    yn = y - ny * err\n\n    vertices = np.block([[xp, xn[::-1]],\n                         [yp, yn[::-1]]]).T\n    codes = np.full(len(vertices), Path.LINETO)\n    codes[0] = codes[len(xp)] = Path.MOVETO\n    path = Path(vertices, codes)\n    ax.add_patch(PathPatch(path, **kwargs))\n\n\n_, axs = plt.subplots(1, 2, layout='constrained', sharex=True, sharey=True)\nerrs = [\n    (axs[0], \"constant error\", 0.05),\n    (axs[1], \"variable error\", 0.05 * np.sin(2 * t) ** 2 + 0.04),\n]\nfor i, (ax, title, err) in enumerate(errs):\n    ax.set(title=title, aspect=1, xticks=[], yticks=[])\n    ax.plot(x, y, \"k\")\n    draw_error_band(ax, x, y, err=err,\n                    facecolor=f\"C{i}\", edgecolor=\"none\", alpha=.3)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches.PathPatch`\n#    - `matplotlib.path.Path`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_012_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========================\nErrorbar limit selection\n========================\n\nIllustration of selectively drawing lower and/or upper limit symbols on\nerrorbars using the parameters ``uplims``, ``lolims`` of `~.pyplot.errorbar`.\n\nAlternatively, you can use 2xN values to draw errorbars in only one direction.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nx = np.arange(10)\ny = 2.5 * np.sin(x / 20 * np.pi)\nyerr = np.linspace(0.05, 0.2, 10)\n\nplt.errorbar(x, y + 3, yerr=yerr, label='both limits (default)')\n\nplt.errorbar(x, y + 2, yerr=yerr, uplims=True, label='uplims=True')\n\nplt.errorbar(x, y + 1, yerr=yerr, uplims=True, lolims=True,\n             label='uplims=True, lolims=True')\n\nupperlimits = [True, False] * 5\nlowerlimits = [False, True] * 5\nplt.errorbar(x, y, yerr=yerr, uplims=upperlimits, lolims=lowerlimits,\n             label='subsets of uplims and lolims')\n\nplt.legend(loc='lower right')\n\n\n# %%\n# Similarly ``xuplims`` and ``xlolims`` can be used on the horizontal ``xerr``\n# errorbars.\n\nfig = plt.figure()\nx = np.arange(10) / 10\ny = (x + 0.1)**2\n\nplt.errorbar(x, y, xerr=0.1, xlolims=True, label='xlolims=True')\ny = (x + 0.1)**3\n\nplt.errorbar(x + 0.6, y, xerr=0.1, xuplims=upperlimits, xlolims=lowerlimits,\n             label='subsets of xuplims and xlolims')\n\ny = (x + 0.1)**4\nplt.errorbar(x + 1.2, y, xerr=0.1, xuplims=True, label='xuplims=True')\n\nplt.legend()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.errorbar` / `matplotlib.pyplot.errorbar`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_013_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n====================\nErrorbar subsampling\n====================\n\nThe parameter *errorevery* of `.Axes.errorbar` can be used to draw error bars\nonly on a subset of data points. This is particularly useful if there are many\ndata points with similar errors.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.arange(0.1, 4, 0.1)\ny1 = np.exp(-1.0 * x)\ny2 = np.exp(-0.5 * x)\n\n# example variable error bar values\ny1err = 0.1 + 0.1 * np.sqrt(x)\ny2err = 0.1 + 0.1 * np.sqrt(x/2)\n\n\nfig, (ax0, ax1, ax2) = plt.subplots(nrows=1, ncols=3, sharex=True,\n                                    figsize=(12, 6))\n\nax0.set_title('all errorbars')\nax0.errorbar(x, y1, yerr=y1err)\nax0.errorbar(x, y2, yerr=y2err)\n\nax1.set_title('only every 6th errorbar')\nax1.errorbar(x, y1, yerr=y1err, errorevery=6)\nax1.errorbar(x, y2, yerr=y2err, errorevery=6)\n\nax2.set_title('second series shifted by 3')\nax2.errorbar(x, y1, yerr=y1err, errorevery=(0, 6))\nax2.errorbar(x, y2, yerr=y2err, errorevery=(3, 6))\n\nfig.suptitle('Errorbar subsampling')\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_014_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "r\"\"\"\n====================\nEventCollection Demo\n====================\n\nPlot two curves, then use `.EventCollection`\\s to mark the locations of the x\nand y data points on the respective axes for each curve.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import EventCollection\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# create random data\nxdata = np.random.random([2, 10])\n\n# split the data into two parts\nxdata1 = xdata[0, :]\nxdata2 = xdata[1, :]\n\n# sort the data so it makes clean curves\nxdata1.sort()\nxdata2.sort()\n\n# create some y data points\nydata1 = xdata1 ** 2\nydata2 = 1 - xdata2 ** 3\n\n# plot the data\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1)\nax.plot(xdata1, ydata1, color='tab:blue')\nax.plot(xdata2, ydata2, color='tab:orange')\n\n# create the events marking the x data points\nxevents1 = EventCollection(xdata1, color='tab:blue', linelength=0.05)\nxevents2 = EventCollection(xdata2, color='tab:orange', linelength=0.05)\n\n# create the events marking the y data points\nyevents1 = EventCollection(ydata1, color='tab:blue', linelength=0.05,\n                           orientation='vertical')\nyevents2 = EventCollection(ydata2, color='tab:orange', linelength=0.05,\n                           orientation='vertical')\n\n# add the events to the axis\nax.add_collection(xevents1)\nax.add_collection(xevents2)\nax.add_collection(yevents1)\nax.add_collection(yevents2)\n\n# set the limits\nax.set_xlim([0, 1])\nax.set_ylim([0, 1])\n\nax.set_title('line plot with data points')\n\n# display the plot\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_015_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============\nEventplot demo\n==============\n\nAn `~.axes.Axes.eventplot` showing sequences of events with various line\nproperties. The plot is shown in both horizontal and vertical orientations.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib\n\nmatplotlib.rcParams['font.size'] = 8.0\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# create random data\ndata1 = np.random.random([6, 50])\n\n# set different colors for each set of positions\ncolors1 = [f'C{i}' for i in range(6)]\n\n# set different line properties for each set of positions\n# note that some overlap\nlineoffsets1 = [-15, -3, 1, 1.5, 6, 10]\nlinelengths1 = [5, 2, 1, 1, 3, 1.5]\n\nfig, axs = plt.subplots(2, 2)\n\n# create a horizontal plot\naxs[0, 0].eventplot(data1, colors=colors1, lineoffsets=lineoffsets1,\n                    linelengths=linelengths1)\n\n# create a vertical plot\naxs[1, 0].eventplot(data1, colors=colors1, lineoffsets=lineoffsets1,\n                    linelengths=linelengths1, orientation='vertical')\n\n# create another set of random data.\n# the gamma distribution is only used for aesthetic purposes\ndata2 = np.random.gamma(4, size=[60, 50])\n\n# use individual values for the parameters this time\n# these values will be used for all data sets (except lineoffsets2, which\n# sets the increment between each data set in this usage)\ncolors2 = 'black'\nlineoffsets2 = 1\nlinelengths2 = 1\n\n# create a horizontal plot\naxs[0, 1].eventplot(data2, colors=colors2, lineoffsets=lineoffsets2,\n                    linelengths=linelengths2)\n\n\n# create a vertical plot\naxs[1, 1].eventplot(data2, colors=colors2, lineoffsets=lineoffsets2,\n                    linelengths=linelengths2, orientation='vertical')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_016_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============\nFilled polygon\n==============\n\n`~.Axes.fill()` draws a filled polygon based on lists of point\ncoordinates *x*, *y*.\n\nThis example uses the `Koch snowflake`_ as an example polygon.\n\n.. _Koch snowflake: https://en.wikipedia.org/wiki/Koch_snowflake\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef koch_snowflake(order, scale=10):\n    \"\"\"\n    Return two lists x, y of point coordinates of the Koch snowflake.\n\n    Parameters\n    ----------\n    order : int\n        The recursion depth.\n    scale : float\n        The extent of the snowflake (edge length of the base triangle).\n    \"\"\"\n    def _koch_snowflake_complex(order):\n        if order == 0:\n            # initial triangle\n            angles = np.array([0, 120, 240]) + 90\n            return scale / np.sqrt(3) * np.exp(np.deg2rad(angles) * 1j)\n        else:\n            ZR = 0.5 - 0.5j * np.sqrt(3) / 3\n\n            p1 = _koch_snowflake_complex(order - 1)  # start points\n            p2 = np.roll(p1, shift=-1)  # end points\n            dp = p2 - p1  # connection vectors\n\n            new_points = np.empty(len(p1) * 4, dtype=np.complex128)\n            new_points[::4] = p1\n            new_points[1::4] = p1 + dp / 3\n            new_points[2::4] = p1 + dp * ZR\n            new_points[3::4] = p1 + dp / 3 * 2\n            return new_points\n\n    points = _koch_snowflake_complex(order)\n    x, y = points.real, points.imag\n    return x, y\n\n\n# %%\n# Basic usage:\n\nx, y = koch_snowflake(order=5)\n\nplt.figure(figsize=(8, 8))\nplt.axis('equal')\nplt.fill(x, y)\nplt.show()\n\n# %%\n# Use keyword arguments *facecolor* and *edgecolor* to modify the colors\n# of the polygon. Since the *linewidth* of the edge is 0 in the default\n# Matplotlib style, we have to set it as well for the edge to become visible.\n\nx, y = koch_snowflake(order=2)\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(9, 3),\n                                    subplot_kw={'aspect': 'equal'})\nax1.fill(x, y)\nax2.fill(x, y, facecolor='lightsalmon', edgecolor='orangered', linewidth=3)\nax3.fill(x, y, facecolor='none', edgecolor='purple', linewidth=3)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.fill` / `matplotlib.pyplot.fill`\n#    - `matplotlib.axes.Axes.axis` / `matplotlib.pyplot.axis`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_017_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============================\nFilling the area between lines\n==============================\n\nThis example shows how to use `~.axes.Axes.fill_between` to color the area\nbetween two lines.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# %%\n#\n# Basic usage\n# -----------\n# The parameters *y1* and *y2* can be scalars, indicating a horizontal\n# boundary at the given y-values. If only *y1* is given, *y2* defaults to 0.\n\nx = np.arange(0.0, 2, 0.01)\ny1 = np.sin(2 * np.pi * x)\ny2 = 0.8 * np.sin(4 * np.pi * x)\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, sharex=True, figsize=(6, 6))\n\nax1.fill_between(x, y1)\nax1.set_title('fill between y1 and 0')\n\nax2.fill_between(x, y1, 1)\nax2.set_title('fill between y1 and 1')\n\nax3.fill_between(x, y1, y2)\nax3.set_title('fill between y1 and y2')\nax3.set_xlabel('x')\nfig.tight_layout()\n\n# %%\n#\n# Example: Confidence bands\n# -------------------------\n# A common application for `~.axes.Axes.fill_between` is the indication of\n# confidence bands.\n#\n# `~.axes.Axes.fill_between` uses the colors of the color cycle as the fill\n# color. These may be a bit strong when applied to fill areas. It is\n# therefore often a good practice to lighten the color by making the area\n# semi-transparent using *alpha*.\n\n# sphinx_gallery_thumbnail_number = 2\n\nN = 21\nx = np.linspace(0, 10, 11)\ny = [3.9, 4.4, 10.8, 10.3, 11.2, 13.1, 14.1,  9.9, 13.9, 15.1, 12.5]\n\n# fit a linear curve and estimate its y-values and their error.\na, b = np.polyfit(x, y, deg=1)\ny_est = a * x + b\ny_err = x.std() * np.sqrt(1/len(x) +\n                          (x - x.mean())**2 / np.sum((x - x.mean())**2))\n\nfig, ax = plt.subplots()\nax.plot(x, y_est, '-')\nax.fill_between(x, y_est - y_err, y_est + y_err, alpha=0.2)\nax.plot(x, y, 'o', color='tab:brown')\n\n# %%\n#\n# Selectively filling horizontal regions\n# --------------------------------------\n# The parameter *where* allows to specify the x-ranges to fill. It's a boolean\n# array with the same size as *x*.\n#\n# Only x-ranges of contiguous *True* sequences are filled. As a result the\n# range between neighboring *True* and *False* values is never filled. This\n# often undesired when the data points should represent a contiguous quantity.\n# It is therefore recommended to set ``interpolate=True`` unless the\n# x-distance of the data points is fine enough so that the above effect is not\n# noticeable. Interpolation approximates the actual x position at which the\n# *where* condition will change and extends the filling up to there.\n\nx = np.array([0, 1, 2, 3])\ny1 = np.array([0.8, 0.8, 0.2, 0.2])\ny2 = np.array([0, 0, 1, 1])\n\nfig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\n\nax1.set_title('interpolation=False')\nax1.plot(x, y1, 'o--')\nax1.plot(x, y2, 'o--')\nax1.fill_between(x, y1, y2, where=(y1 > y2), color='C0', alpha=0.3)\nax1.fill_between(x, y1, y2, where=(y1 < y2), color='C1', alpha=0.3)\n\nax2.set_title('interpolation=True')\nax2.plot(x, y1, 'o--')\nax2.plot(x, y2, 'o--')\nax2.fill_between(x, y1, y2, where=(y1 > y2), color='C0', alpha=0.3,\n                 interpolate=True)\nax2.fill_between(x, y1, y2, where=(y1 <= y2), color='C1', alpha=0.3,\n                 interpolate=True)\nfig.tight_layout()\n\n# %%\n#\n# .. note::\n#\n#    Similar gaps will occur if *y1* or *y2* are masked arrays. Since missing\n#    values cannot be approximated, *interpolate* has no effect in this case.\n#    The gaps around masked values can only be reduced by adding more data\n#    points close to the masked values.\n\n# %%\n#\n# Selectively marking horizontal regions across the whole Axes\n# ------------------------------------------------------------\n# The same selection mechanism can be applied to fill the full vertical height\n# of the axes. To be independent of y-limits, we add a transform that\n# interprets the x-values in data coordinates and the y-values in axes\n# coordinates.\n#\n# The following example marks the regions in which the y-data are above a\n# given threshold.\n\nfig, ax = plt.subplots()\nx = np.arange(0, 4 * np.pi, 0.01)\ny = np.sin(x)\nax.plot(x, y, color='black')\n\nthreshold = 0.75\nax.axhline(threshold, color='green', lw=2, alpha=0.7)\nax.fill_between(x, 0, 1, where=y > threshold,\n                color='green', alpha=0.5, transform=ax.get_xaxis_transform())\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.fill_between` / `matplotlib.pyplot.fill_between`\n#    - `matplotlib.axes.Axes.get_xaxis_transform`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_018_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================\nFill Betweenx Demo\n==================\n\nUsing `~.Axes.fill_betweenx` to color along the horizontal direction between\ntwo curves.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ny = np.arange(0.0, 2, 0.01)\nx1 = np.sin(2 * np.pi * y)\nx2 = 1.2 * np.sin(4 * np.pi * y)\n\nfig, [ax1, ax2, ax3] = plt.subplots(1, 3, sharey=True, figsize=(6, 6))\n\nax1.fill_betweenx(y, 0, x1)\nax1.set_title('between (x1, 0)')\n\nax2.fill_betweenx(y, x1, 1)\nax2.set_title('between (x1, 1)')\nax2.set_xlabel('x')\n\nax3.fill_betweenx(y, x1, x2)\nax3.set_title('between (x1, x2)')\n\n# %%\n# Now fill between x1 and x2 where a logical condition is met. Note this is\n# different than calling::\n#\n#   fill_between(y[where], x1[where], x2[where])\n#\n# because of edge effects over multiple contiguous regions.\n\nfig, [ax, ax1] = plt.subplots(1, 2, sharey=True, figsize=(6, 6))\nax.plot(x1, y, x2, y, color='black')\nax.fill_betweenx(y, x1, x2, where=x2 >= x1, facecolor='green')\nax.fill_betweenx(y, x1, x2, where=x2 <= x1, facecolor='red')\nax.set_title('fill_betweenx where')\n\n# Test support for masked arrays.\nx2 = np.ma.masked_greater(x2, 1.0)\nax1.plot(x1, y, x2, y, color='black')\nax1.fill_betweenx(y, x1, x2, where=x2 >= x1, facecolor='green')\nax1.fill_betweenx(y, x1, x2, where=x2 <= x1, facecolor='red')\nax1.set_title('regions with x2 > 1 are masked')\n\n# %%\n# This example illustrates a problem; because of the data gridding, there are\n# undesired unfilled triangles at the crossover points. A brute-force solution\n# would be to interpolate all arrays to a very fine grid before plotting.\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_019_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========================\nHatch-filled histograms\n=========================\n\nHatching capabilities for plotting histograms.\n\"\"\"\n\nfrom functools import partial\nimport itertools\n\nfrom cycler import cycler\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as mticker\n\n\ndef filled_hist(ax, edges, values, bottoms=None, orientation='v',\n                **kwargs):\n    \"\"\"\n    Draw a histogram as a stepped patch.\n\n    Parameters\n    ----------\n    ax : Axes\n        The axes to plot to\n\n    edges : array\n        A length n+1 array giving the left edges of each bin and the\n        right edge of the last bin.\n\n    values : array\n        A length n array of bin counts or values\n\n    bottoms : float or array, optional\n        A length n array of the bottom of the bars.  If None, zero is used.\n\n    orientation : {'v', 'h'}\n       Orientation of the histogram.  'v' (default) has\n       the bars increasing in the positive y-direction.\n\n    **kwargs\n        Extra keyword arguments are passed through to `.fill_between`.\n\n    Returns\n    -------\n    ret : PolyCollection\n        Artist added to the Axes\n    \"\"\"\n    print(orientation)\n    if orientation not in 'hv':\n        raise ValueError(f\"orientation must be in {{'h', 'v'}} \"\n                         f\"not {orientation}\")\n\n    kwargs.setdefault('step', 'post')\n    kwargs.setdefault('alpha', 0.7)\n    edges = np.asarray(edges)\n    values = np.asarray(values)\n    if len(edges) - 1 != len(values):\n        raise ValueError(f'Must provide one more bin edge than value not: '\n                         f'{len(edges)=} {len(values)=}')\n\n    if bottoms is None:\n        bottoms = 0\n    bottoms = np.broadcast_to(bottoms, values.shape)\n\n    values = np.append(values, values[-1])\n    bottoms = np.append(bottoms, bottoms[-1])\n    if orientation == 'h':\n        return ax.fill_betweenx(edges, values, bottoms,\n                                **kwargs)\n    elif orientation == 'v':\n        return ax.fill_between(edges, values, bottoms,\n                               **kwargs)\n    else:\n        raise AssertionError(\"you should never be here\")\n\n\ndef stack_hist(ax, stacked_data, sty_cycle, bottoms=None,\n               hist_func=None, labels=None,\n               plot_func=None, plot_kwargs=None):\n    \"\"\"\n    Parameters\n    ----------\n    ax : axes.Axes\n        The axes to add artists too\n\n    stacked_data : array or Mapping\n        A (M, N) shaped array.  The first dimension will be iterated over to\n        compute histograms row-wise\n\n    sty_cycle : Cycler or operable of dict\n        Style to apply to each set\n\n    bottoms : array, default: 0\n        The initial positions of the bottoms.\n\n    hist_func : callable, optional\n        Must have signature `bin_vals, bin_edges = f(data)`.\n        `bin_edges` expected to be one longer than `bin_vals`\n\n    labels : list of str, optional\n        The label for each set.\n\n        If not given and stacked data is an array defaults to 'default set {n}'\n\n        If *stacked_data* is a mapping, and *labels* is None, default to the\n        keys.\n\n        If *stacked_data* is a mapping and *labels* is given then only the\n        columns listed will be plotted.\n\n    plot_func : callable, optional\n        Function to call to draw the histogram must have signature:\n\n          ret = plot_func(ax, edges, top, bottoms=bottoms,\n                          label=label, **kwargs)\n\n    plot_kwargs : dict, optional\n        Any extra keyword arguments to pass through to the plotting function.\n        This will be the same for all calls to the plotting function and will\n        override the values in *sty_cycle*.\n\n    Returns\n    -------\n    arts : dict\n        Dictionary of artists keyed on their labels\n    \"\"\"\n    # deal with default binning function\n    if hist_func is None:\n        hist_func = np.histogram\n\n    # deal with default plotting function\n    if plot_func is None:\n        plot_func = filled_hist\n\n    # deal with default\n    if plot_kwargs is None:\n        plot_kwargs = {}\n    print(plot_kwargs)\n    try:\n        l_keys = stacked_data.keys()\n        label_data = True\n        if labels is None:\n            labels = l_keys\n\n    except AttributeError:\n        label_data = False\n        if labels is None:\n            labels = itertools.repeat(None)\n\n    if label_data:\n        loop_iter = enumerate((stacked_data[lab], lab, s)\n                              for lab, s in zip(labels, sty_cycle))\n    else:\n        loop_iter = enumerate(zip(stacked_data, labels, sty_cycle))\n\n    arts = {}\n    for j, (data, label, sty) in loop_iter:\n        if label is None:\n            label = f'dflt set {j}'\n        label = sty.pop('label', label)\n        vals, edges = hist_func(data)\n        if bottoms is None:\n            bottoms = np.zeros_like(vals)\n        top = bottoms + vals\n        print(sty)\n        sty.update(plot_kwargs)\n        print(sty)\n        ret = plot_func(ax, edges, top, bottoms=bottoms,\n                        label=label, **sty)\n        bottoms = top\n        arts[label] = ret\n    ax.legend(fontsize=10)\n    return arts\n\n\n# set up histogram function to fixed bins\nedges = np.linspace(-3, 3, 20, endpoint=True)\nhist_func = partial(np.histogram, bins=edges)\n\n# set up style cycles\ncolor_cycle = cycler(facecolor=plt.rcParams['axes.prop_cycle'][:4])\nlabel_cycle = cycler(label=[f'set {n}' for n in range(4)])\nhatch_cycle = cycler(hatch=['/', '*', '+', '|'])\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nstack_data = np.random.randn(4, 12250)\ndict_data = dict(zip((c['label'] for c in label_cycle), stack_data))\n\n# %%\n# Work with plain arrays\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(9, 4.5), tight_layout=True)\narts = stack_hist(ax1, stack_data, color_cycle + label_cycle + hatch_cycle,\n                  hist_func=hist_func)\n\narts = stack_hist(ax2, stack_data, color_cycle,\n                  hist_func=hist_func,\n                  plot_kwargs=dict(edgecolor='w', orientation='h'))\nax1.set_ylabel('counts')\nax1.set_xlabel('x')\nax2.set_xlabel('counts')\nax2.set_ylabel('x')\n\n# %%\n# Work with labeled data\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(9, 4.5),\n                               tight_layout=True, sharey=True)\n\narts = stack_hist(ax1, dict_data, color_cycle + hatch_cycle,\n                  hist_func=hist_func)\n\narts = stack_hist(ax2, dict_data, color_cycle + hatch_cycle,\n                  hist_func=hist_func, labels=['set 0', 'set 3'])\nax1.xaxis.set_major_locator(mticker.MaxNLocator(5))\nax1.set_xlabel('counts')\nax1.set_ylabel('x')\nax2.set_ylabel('x')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.fill_betweenx` / `matplotlib.pyplot.fill_betweenx`\n#    - `matplotlib.axes.Axes.fill_between` / `matplotlib.pyplot.fill_between`\n#    - `matplotlib.axis.Axis.set_major_locator`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_020_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========================\nBar chart with gradients\n========================\n\nMatplotlib does not natively support gradients. However, we can emulate a\ngradient-filled rectangle by an `.AxesImage` of the right size and coloring.\n\nIn particular, we use a colormap to generate the actual colors. It is then\nsufficient to define the underlying values on the corners of the image and\nlet bicubic interpolation fill out the area. We define the gradient direction\nby a unit vector *v*. The values at the corners are then obtained by the\nlengths of the projections of the corner vectors on *v*.\n\nA similar approach can be used to create a gradient background for an Axes.\nIn that case, it is helpful to use Axes coordinates (``extent=(0, 1, 0, 1),\ntransform=ax.transAxes``) to be independent of the data coordinates.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\n\ndef gradient_image(ax, direction=0.3, cmap_range=(0, 1), **kwargs):\n    \"\"\"\n    Draw a gradient image based on a colormap.\n\n    Parameters\n    ----------\n    ax : Axes\n        The axes to draw on.\n    direction : float\n        The direction of the gradient. This is a number in\n        range 0 (=vertical) to 1 (=horizontal).\n    cmap_range : float, float\n        The fraction (cmin, cmax) of the colormap that should be\n        used for the gradient, where the complete colormap is (0, 1).\n    **kwargs\n        Other parameters are passed on to `.Axes.imshow()`.\n        In particular, *cmap*, *extent*, and *transform* may be useful.\n    \"\"\"\n    phi = direction * np.pi / 2\n    v = np.array([np.cos(phi), np.sin(phi)])\n    X = np.array([[v @ [1, 0], v @ [1, 1]],\n                  [v @ [0, 0], v @ [0, 1]]])\n    a, b = cmap_range\n    X = a + (b - a) / X.max() * X\n    im = ax.imshow(X, interpolation='bicubic', clim=(0, 1),\n                   aspect='auto', **kwargs)\n    return im\n\n\ndef gradient_bar(ax, x, y, width=0.5, bottom=0):\n    for left, top in zip(x, y):\n        right = left + width\n        gradient_image(ax, extent=(left, right, bottom, top),\n                       cmap=plt.cm.Blues_r, cmap_range=(0, 0.8))\n\n\nfig, ax = plt.subplots()\nax.set(xlim=(0, 10), ylim=(0, 1))\n\n# background image\ngradient_image(ax, direction=1, extent=(0, 1, 0, 1), transform=ax.transAxes,\n               cmap=plt.cm.RdYlGn, cmap_range=(0.2, 0.8), alpha=0.5)\n\nN = 10\nx = np.arange(N) + 0.15\ny = np.random.rand(N)\ngradient_bar(ax, x, y, width=0.7)\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_021_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========\nHat graph\n=========\nThis example shows how to create a `hat graph`_ and how to annotate it with\nlabels.\n\n.. _hat graph: https://doi.org/10.1186/s41235-019-0182-3\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef hat_graph(ax, xlabels, values, group_labels):\n    \"\"\"\n    Create a hat graph.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        The Axes to plot into.\n    xlabels : list of str\n        The category names to be displayed on the x-axis.\n    values : (M, N) array-like\n        The data values.\n        Rows are the groups (len(group_labels) == M).\n        Columns are the categories (len(xlabels) == N).\n    group_labels : list of str\n        The group labels displayed in the legend.\n    \"\"\"\n\n    def label_bars(heights, rects):\n        \"\"\"Attach a text label on top of each bar.\"\"\"\n        for height, rect in zip(heights, rects):\n            ax.annotate(f'{height}',\n                        xy=(rect.get_x() + rect.get_width() / 2, height),\n                        xytext=(0, 4),  # 4 points vertical offset.\n                        textcoords='offset points',\n                        ha='center', va='bottom')\n\n    values = np.asarray(values)\n    x = np.arange(values.shape[1])\n    ax.set_xticks(x, labels=xlabels)\n    spacing = 0.3  # spacing between hat groups\n    width = (1 - spacing) / values.shape[0]\n    heights0 = values[0]\n    for i, (heights, group_label) in enumerate(zip(values, group_labels)):\n        style = {'fill': False} if i == 0 else {'edgecolor': 'black'}\n        rects = ax.bar(x - spacing/2 + i * width, heights - heights0,\n                       width, bottom=heights0, label=group_label, **style)\n        label_bars(heights, rects)\n\n\n# initialise labels and a numpy array make sure you have\n# N labels of N number of values in the array\nxlabels = ['I', 'II', 'III', 'IV', 'V']\nplayerA = np.array([5, 15, 22, 20, 25])\nplayerB = np.array([25, 32, 34, 30, 27])\n\nfig, ax = plt.subplots()\nhat_graph(ax, xlabels, [playerA, playerB], ['Player A', 'Player B'])\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_xlabel('Games')\nax.set_ylabel('Score')\nax.set_ylim(0, 60)\nax.set_title('Scores by number of game and players')\nax.legend()\n\nfig.tight_layout()\nplt.show()\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`\n#    - `matplotlib.axes.Axes.annotate` / `matplotlib.pyplot.annotate`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_022_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============================================\nDiscrete distribution as horizontal bar chart\n=============================================\n\nStacked bar charts can be used to visualize discrete distributions.\n\nThis example visualizes the result of a survey in which people could rate\ntheir agreement to questions on a five-element scale.\n\nThe horizontal stacking is achieved by calling `~.Axes.barh()` for each\ncategory and passing the starting point as the cumulative sum of the\nalready drawn bars via the parameter ``left``.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncategory_names = ['Strongly disagree', 'Disagree',\n                  'Neither agree nor disagree', 'Agree', 'Strongly agree']\nresults = {\n    'Question 1': [10, 15, 17, 32, 26],\n    'Question 2': [26, 22, 29, 10, 13],\n    'Question 3': [35, 37, 7, 2, 19],\n    'Question 4': [32, 11, 9, 15, 33],\n    'Question 5': [21, 29, 5, 5, 40],\n    'Question 6': [8, 19, 5, 30, 38]\n}\n\n\ndef survey(results, category_names):\n    \"\"\"\n    Parameters\n    ----------\n    results : dict\n        A mapping from question labels to a list of answers per category.\n        It is assumed all lists contain the same number of entries and that\n        it matches the length of *category_names*.\n    category_names : list of str\n        The category labels.\n    \"\"\"\n    labels = list(results.keys())\n    data = np.array(list(results.values()))\n    data_cum = data.cumsum(axis=1)\n    category_colors = plt.colormaps['RdYlGn'](\n        np.linspace(0.15, 0.85, data.shape[1]))\n\n    fig, ax = plt.subplots(figsize=(9.2, 5))\n    ax.invert_yaxis()\n    ax.xaxis.set_visible(False)\n    ax.set_xlim(0, np.sum(data, axis=1).max())\n\n    for i, (colname, color) in enumerate(zip(category_names, category_colors)):\n        widths = data[:, i]\n        starts = data_cum[:, i] - widths\n        rects = ax.barh(labels, widths, left=starts, height=0.5,\n                        label=colname, color=color)\n\n        r, g, b, _ = color\n        text_color = 'white' if r * g * b < 0.5 else 'darkgrey'\n        ax.bar_label(rects, label_type='center', color=text_color)\n    ax.legend(ncols=len(category_names), bbox_to_anchor=(0, 1),\n              loc='lower left', fontsize='small')\n\n    return fig, ax\n\n\nsurvey(results, category_names)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.barh` / `matplotlib.pyplot.barh`\n#    - `matplotlib.axes.Axes.bar_label` / `matplotlib.pyplot.bar_label`\n#    - `matplotlib.axes.Axes.legend` / `matplotlib.pyplot.legend`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_023_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========\nJoinStyle\n=========\n\nThe `matplotlib._enums.JoinStyle` controls how Matplotlib draws the corners\nwhere two different line segments meet. For more details, see the\n`~matplotlib._enums.JoinStyle` docs.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib._enums import JoinStyle\n\nJoinStyle.demo()\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_024_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============================\nCustomizing dashed line styles\n==============================\n\nThe dashing of a line is controlled via a dash sequence. It can be modified\nusing `.Line2D.set_dashes`.\n\nThe dash sequence is a series of on/off lengths in points, e.g.\n``[3, 1]`` would be 3pt long lines separated by 1pt spaces.\n\nSome functions like `.Axes.plot` support passing Line properties as keyword\narguments. In such a case, you can already set the dashing when creating the\nline.\n\n*Note*: The dash style can also be configured via a\n:ref:`property_cycle <color_cycle>`\nby passing a list of dash sequences using the keyword *dashes* to the\ncycler. This is not shown within this example.\n\nOther attributes of the dash may also be set either with the relevant method\n(`~.Line2D.set_dash_capstyle`, `~.Line2D.set_dash_joinstyle`,\n`~.Line2D.set_gapcolor`) or by passing the property through a plotting\nfunction.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 10, 500)\ny = np.sin(x)\n\nplt.rc('lines', linewidth=2.5)\nfig, ax = plt.subplots()\n\n# Using set_dashes() and set_capstyle() to modify dashing of an existing line.\nline1, = ax.plot(x, y, label='Using set_dashes() and set_dash_capstyle()')\nline1.set_dashes([2, 2, 10, 2])  # 2pt line, 2pt break, 10pt line, 2pt break.\nline1.set_dash_capstyle('round')\n\n# Using plot(..., dashes=...) to set the dashing when creating a line.\nline2, = ax.plot(x, y - 0.2, dashes=[6, 2], label='Using the dashes parameter')\n\n# Using plot(..., dashes=..., gapcolor=...) to set the dashing and\n# alternating color when creating a line.\nline3, = ax.plot(x, y - 0.4, dashes=[4, 4], gapcolor='tab:pink',\n                 label='Using the dashes and gapcolor parameters')\n\nax.legend(handlelength=4)\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_025_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============================\nLines with a ticked patheffect\n==============================\n\nTicks can be added along a line to mark one side as a barrier using\n`~matplotlib.patheffects.TickedStroke`.  You can control the angle,\nspacing, and length of the ticks.\n\nThe ticks will also appear appropriately in the legend.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import patheffects\n\n# Plot a straight diagonal line with ticked style path\nfig, ax = plt.subplots(figsize=(6, 6))\nax.plot([0, 1], [0, 1], label=\"Line\",\n        path_effects=[patheffects.withTickedStroke(spacing=7, angle=135)])\n\n# Plot a curved line with ticked style path\nnx = 101\nx = np.linspace(0.0, 1.0, nx)\ny = 0.3*np.sin(x*8) + 0.4\nax.plot(x, y, label=\"Curve\", path_effects=[patheffects.withTickedStroke()])\n\nax.legend()\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_026_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========\nLinestyles\n==========\n\nSimple linestyles can be defined using the strings \"solid\", \"dotted\", \"dashed\"\nor \"dashdot\". More refined control can be achieved by providing a dash tuple\n``(offset, (on_off_seq))``. For example, ``(0, (3, 10, 1, 15))`` means\n(3pt line, 10pt space, 1pt line, 15pt space) with no offset, while\n``(5, (10, 3))``, means (10pt line, 3pt space), but skip the first 5pt line.\nSee also `.Line2D.set_linestyle`.\n\n*Note*: The dash style can also be configured via `.Line2D.set_dashes`\nas shown in :doc:`/gallery/lines_bars_and_markers/line_demo_dash_control`\nand passing a list of dash sequences using the keyword *dashes* to the\ncycler in :ref:`property_cycle <color_cycle>`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nlinestyle_str = [\n     ('solid', 'solid'),      # Same as (0, ()) or '-'\n     ('dotted', 'dotted'),    # Same as (0, (1, 1)) or ':'\n     ('dashed', 'dashed'),    # Same as '--'\n     ('dashdot', 'dashdot')]  # Same as '-.'\n\nlinestyle_tuple = [\n     ('loosely dotted',        (0, (1, 10))),\n     ('dotted',                (0, (1, 1))),\n     ('densely dotted',        (0, (1, 1))),\n     ('long dash with offset', (5, (10, 3))),\n     ('loosely dashed',        (0, (5, 10))),\n     ('dashed',                (0, (5, 5))),\n     ('densely dashed',        (0, (5, 1))),\n\n     ('loosely dashdotted',    (0, (3, 10, 1, 10))),\n     ('dashdotted',            (0, (3, 5, 1, 5))),\n     ('densely dashdotted',    (0, (3, 1, 1, 1))),\n\n     ('dashdotdotted',         (0, (3, 5, 1, 5, 1, 5))),\n     ('loosely dashdotdotted', (0, (3, 10, 1, 10, 1, 10))),\n     ('densely dashdotdotted', (0, (3, 1, 1, 1, 1, 1)))]\n\n\ndef plot_linestyles(ax, linestyles, title):\n    X, Y = np.linspace(0, 100, 10), np.zeros(10)\n    yticklabels = []\n\n    for i, (name, linestyle) in enumerate(linestyles):\n        ax.plot(X, Y+i, linestyle=linestyle, linewidth=1.5, color='black')\n        yticklabels.append(name)\n\n    ax.set_title(title)\n    ax.set(ylim=(-0.5, len(linestyles)-0.5),\n           yticks=np.arange(len(linestyles)),\n           yticklabels=yticklabels)\n    ax.tick_params(left=False, bottom=False, labelbottom=False)\n    ax.spines[:].set_visible(False)\n\n    # For each line style, add a text annotation with a small offset from\n    # the reference point (0 in Axes coords, y tick value in Data coords).\n    for i, (name, linestyle) in enumerate(linestyles):\n        ax.annotate(repr(linestyle),\n                    xy=(0.0, i), xycoords=ax.get_yaxis_transform(),\n                    xytext=(-6, -12), textcoords='offset points',\n                    color=\"blue\", fontsize=8, ha=\"right\", family=\"monospace\")\n\n\nfig, (ax0, ax1) = plt.subplots(2, 1, figsize=(10, 8), height_ratios=[1, 3])\n\nplot_linestyles(ax0, linestyle_str[::-1], title='Named linestyles')\nplot_linestyles(ax1, linestyle_tuple[::-1], title='Parametrized linestyles')\n\nplt.tight_layout()\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_027_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nMarker reference\n================\n\nMatplotlib supports multiple categories of markers which are selected using\nthe ``marker`` parameter of plot commands:\n\n- `Unfilled markers`_\n- `Filled markers`_\n- `Markers created from TeX symbols`_\n- `Markers created from Paths`_\n\nFor a list of all markers see also the `matplotlib.markers` documentation.\n\nFor example usages see\n:doc:`/gallery/lines_bars_and_markers/scatter_star_poly`.\n\n.. redirect-from:: /gallery/shapes_and_collections/marker_path\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.lines import Line2D\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.transforms import Affine2D\n\ntext_style = dict(horizontalalignment='right', verticalalignment='center',\n                  fontsize=12, fontfamily='monospace')\nmarker_style = dict(linestyle=':', color='0.8', markersize=10,\n                    markerfacecolor=\"tab:blue\", markeredgecolor=\"tab:blue\")\n\n\ndef format_axes(ax):\n    ax.margins(0.2)\n    ax.set_axis_off()\n    ax.invert_yaxis()\n\n\ndef split_list(a_list):\n    i_half = len(a_list) // 2\n    return a_list[:i_half], a_list[i_half:]\n\n\n# %%\n# Unfilled markers\n# ================\n# Unfilled markers are single-colored.\n\nfig, axs = plt.subplots(ncols=2)\nfig.suptitle('Un-filled markers', fontsize=14)\n\n# Filter out filled markers and marker settings that do nothing.\nunfilled_markers = [m for m, func in Line2D.markers.items()\n                    if func != 'nothing' and m not in Line2D.filled_markers]\n\nfor ax, markers in zip(axs, split_list(unfilled_markers)):\n    for y, marker in enumerate(markers):\n        ax.text(-0.5, y, repr(marker), **text_style)\n        ax.plot([y] * 3, marker=marker, **marker_style)\n    format_axes(ax)\n\n# %%\n# Filled markers\n# ==============\n\nfig, axs = plt.subplots(ncols=2)\nfig.suptitle('Filled markers', fontsize=14)\nfor ax, markers in zip(axs, split_list(Line2D.filled_markers)):\n    for y, marker in enumerate(markers):\n        ax.text(-0.5, y, repr(marker), **text_style)\n        ax.plot([y] * 3, marker=marker, **marker_style)\n    format_axes(ax)\n\n# %%\n# .. _marker_fill_styles:\n#\n# Marker fill styles\n# ------------------\n# The edge color and fill color of filled markers can be specified separately.\n# Additionally, the ``fillstyle`` can be configured to be unfilled, fully\n# filled, or half-filled in various directions. The half-filled styles use\n# ``markerfacecoloralt`` as secondary fill color.\n\nfig, ax = plt.subplots()\nfig.suptitle('Marker fillstyle', fontsize=14)\nfig.subplots_adjust(left=0.4)\n\nfilled_marker_style = dict(marker='o', linestyle=':', markersize=15,\n                           color='darkgrey',\n                           markerfacecolor='tab:blue',\n                           markerfacecoloralt='lightsteelblue',\n                           markeredgecolor='brown')\n\nfor y, fill_style in enumerate(Line2D.fillStyles):\n    ax.text(-0.5, y, repr(fill_style), **text_style)\n    ax.plot([y] * 3, fillstyle=fill_style, **filled_marker_style)\nformat_axes(ax)\n\n# %%\n# Markers created from TeX symbols\n# ================================\n#\n# Use :ref:`MathText <mathtext>`, to use custom marker symbols,\n# like e.g. ``\"$\\u266B$\"``. For an overview over the STIX font symbols refer\n# to the `STIX font table <http://www.stixfonts.org/allGlyphs.html>`_.\n# Also see the :doc:`/gallery/text_labels_and_annotations/stix_fonts_demo`.\n\n\nfig, ax = plt.subplots()\nfig.suptitle('Mathtext markers', fontsize=14)\nfig.subplots_adjust(left=0.4)\n\nmarker_style.update(markeredgecolor=\"none\", markersize=15)\nmarkers = [\"$1$\", r\"$\\frac{1}{2}$\", \"$f$\", \"$\\u266B$\", r\"$\\mathcal{A}$\"]\n\nfor y, marker in enumerate(markers):\n    # Escape dollars so that the text is written \"as is\", not as mathtext.\n    ax.text(-0.5, y, repr(marker).replace(\"$\", r\"\\$\"), **text_style)\n    ax.plot([y] * 3, marker=marker, **marker_style)\nformat_axes(ax)\n\n# %%\n# Markers created from Paths\n# ==========================\n#\n# Any `~.path.Path` can be used as a marker. The following example shows two\n# simple paths *star* and *circle*, and a more elaborate path of a circle with\n# a cut-out star.\n\nimport numpy as np\n\nimport matplotlib.path as mpath\n\nstar = mpath.Path.unit_regular_star(6)\ncircle = mpath.Path.unit_circle()\n# concatenate the circle with an internal cutout of the star\ncut_star = mpath.Path(\n    vertices=np.concatenate([circle.vertices, star.vertices[::-1, ...]]),\n    codes=np.concatenate([circle.codes, star.codes]))\n\nfig, ax = plt.subplots()\nfig.suptitle('Path markers', fontsize=14)\nfig.subplots_adjust(left=0.4)\n\nmarkers = {'star': star, 'circle': circle, 'cut_star': cut_star}\n\nfor y, (name, marker) in enumerate(markers.items()):\n    ax.text(-0.5, y, name, **text_style)\n    ax.plot([y] * 3, marker=marker, **marker_style)\nformat_axes(ax)\n\n# %%\n# Advanced marker modifications with transform\n# ============================================\n#\n# Markers can be modified by passing a transform to the MarkerStyle\n# constructor. Following example shows how a supplied rotation is applied to\n# several marker shapes.\n\ncommon_style = {k: v for k, v in filled_marker_style.items() if k != 'marker'}\nangles = [0, 10, 20, 30, 45, 60, 90]\n\nfig, ax = plt.subplots()\nfig.suptitle('Rotated markers', fontsize=14)\n\nax.text(-0.5, 0, 'Filled marker', **text_style)\nfor x, theta in enumerate(angles):\n    t = Affine2D().rotate_deg(theta)\n    ax.plot(x, 0, marker=MarkerStyle('o', 'left', t), **common_style)\n\nax.text(-0.5, 1, 'Un-filled marker', **text_style)\nfor x, theta in enumerate(angles):\n    t = Affine2D().rotate_deg(theta)\n    ax.plot(x, 1, marker=MarkerStyle('1', 'left', t), **common_style)\n\nax.text(-0.5, 2, 'Equation marker', **text_style)\nfor x, theta in enumerate(angles):\n    t = Affine2D().rotate_deg(theta)\n    eq = r'$\\frac{1}{x}$'\n    ax.plot(x, 2, marker=MarkerStyle(eq, 'left', t), **common_style)\n\nfor x, theta in enumerate(angles):\n    ax.text(x, 2.5, f\"{theta}\u00b0\", horizontalalignment=\"center\")\nformat_axes(ax)\n\nfig.tight_layout()\n\n# %%\n# Setting marker cap style and join style\n# =======================================\n#\n# Markers have default cap and join styles, but these can be\n# customized when creating a MarkerStyle.\n\nfrom matplotlib.markers import CapStyle, JoinStyle\n\nmarker_inner = dict(markersize=35,\n                    markerfacecolor='tab:blue',\n                    markerfacecoloralt='lightsteelblue',\n                    markeredgecolor='brown',\n                    markeredgewidth=8,\n                    )\n\nmarker_outer = dict(markersize=35,\n                    markerfacecolor='tab:blue',\n                    markerfacecoloralt='lightsteelblue',\n                    markeredgecolor='white',\n                    markeredgewidth=1,\n                    )\n\nfig, ax = plt.subplots()\nfig.suptitle('Marker CapStyle', fontsize=14)\nfig.subplots_adjust(left=0.1)\n\nfor y, cap_style in enumerate(CapStyle):\n    ax.text(-0.5, y, cap_style.name, **text_style)\n    for x, theta in enumerate(angles):\n        t = Affine2D().rotate_deg(theta)\n        m = MarkerStyle('1', transform=t, capstyle=cap_style)\n        ax.plot(x, y, marker=m, **marker_inner)\n        ax.plot(x, y, marker=m, **marker_outer)\n        ax.text(x, len(CapStyle) - .5, f'{theta}\u00b0', ha='center')\nformat_axes(ax)\n\n# %%\n# Modifying the join style:\n\nfig, ax = plt.subplots()\nfig.suptitle('Marker JoinStyle', fontsize=14)\nfig.subplots_adjust(left=0.05)\n\nfor y, join_style in enumerate(JoinStyle):\n    ax.text(-0.5, y, join_style.name, **text_style)\n    for x, theta in enumerate(angles):\n        t = Affine2D().rotate_deg(theta)\n        m = MarkerStyle('*', transform=t, joinstyle=join_style)\n        ax.plot(x, y, marker=m, **marker_inner)\n        ax.text(x, len(JoinStyle) - .5, f'{theta}\u00b0', ha='center')\nformat_axes(ax)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_028_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============\nMarkevery Demo\n==============\n\nThe ``markevery`` property of `.Line2D` allows drawing markers at a subset of\ndata points.\n\nThe list of possible parameters is specified at `.Line2D.set_markevery`.\nIn short:\n\n- A single integer N draws every N-th marker.\n- A tuple of integers (start, N) draws every N-th marker, starting at data\n  index *start*.\n- A list of integers draws the markers at the specified indices.\n- A slice draws the markers at the sliced indices.\n- A float specifies the distance between markers as a fraction of the Axes\n  diagonal in screen space. This will lead to a visually uniform distribution\n  of the points along the line, irrespective of scales and zooming.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# define a list of markevery cases to plot\ncases = [\n    None,\n    8,\n    (30, 8),\n    [16, 24, 32],\n    [0, -1],\n    slice(100, 200, 3),\n    0.1,\n    0.4,\n    (0.2, 0.4)\n]\n\n# data points\ndelta = 0.11\nx = np.linspace(0, 10 - 2 * delta, 200) + delta\ny = np.sin(x) + 1.0 + delta\n\n# %%\n# markevery with linear scales\n# ----------------------------\n\nfig, axs = plt.subplots(3, 3, figsize=(10, 6), layout='constrained')\nfor ax, markevery in zip(axs.flat, cases):\n    ax.set_title(f'markevery={markevery}')\n    ax.plot(x, y, 'o', ls='-', ms=4, markevery=markevery)\n\n# %%\n# markevery with log scales\n# -------------------------\n#\n# Note that the log scale causes a visual asymmetry in the marker distance for\n# when subsampling the data using an integer. In contrast, subsampling on\n# fraction of figure size creates even distributions, because it's based on\n# fractions of the Axes diagonal, not on data coordinates or data indices.\n\nfig, axs = plt.subplots(3, 3, figsize=(10, 6), layout='constrained')\nfor ax, markevery in zip(axs.flat, cases):\n    ax.set_title(f'markevery={markevery}')\n    ax.set_xscale('log')\n    ax.set_yscale('log')\n    ax.plot(x, y, 'o', ls='-', ms=4, markevery=markevery)\n\n# %%\n# markevery on zoomed plots\n# -------------------------\n#\n# Integer-based *markevery* specifications select points from the underlying\n# data and are independent on the view. In contrast, float-based specifications\n# are related to the Axes diagonal. While zooming does not change the Axes\n# diagonal, it changes the displayed data range, and more points will be\n# displayed when zooming.\n\nfig, axs = plt.subplots(3, 3, figsize=(10, 6), layout='constrained')\nfor ax, markevery in zip(axs.flat, cases):\n    ax.set_title(f'markevery={markevery}')\n    ax.plot(x, y, 'o', ls='-', ms=4, markevery=markevery)\n    ax.set_xlim((6, 6.7))\n    ax.set_ylim((1.1, 1.7))\n\n# %%\n# markevery on polar plots\n# ------------------------\n\nr = np.linspace(0, 3.0, 200)\ntheta = 2 * np.pi * r\n\nfig, axs = plt.subplots(3, 3, figsize=(10, 6), layout='constrained',\n                        subplot_kw={'projection': 'polar'})\nfor ax, markevery in zip(axs.flat, cases):\n    ax.set_title(f'markevery={markevery}')\n    ax.plot(theta, r, 'o', ls='-', ms=4, markevery=markevery)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_029_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============================\nPlotting masked and NaN values\n==============================\n\nSometimes you need to plot data with missing values.\n\nOne possibility is to simply remove undesired data points. The line plotted\nthrough the remaining data will be continuous, and not indicate where the\nmissing data is located.\n\nIf it is useful to have gaps in the line where the data is missing, then the\nundesired points can be indicated using a `masked array`_ or by setting their\nvalues to NaN. No marker will be drawn where either x or y are masked and, if\nplotting with a line, it will be broken there.\n\n.. _masked array:\n   https://numpy.org/doc/stable/reference/maskedarray.generic.html\n\nThe following example illustrates the three cases:\n\n1) Removing points.\n2) Masking points.\n3) Setting to NaN.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-np.pi/2, np.pi/2, 31)\ny = np.cos(x)**3\n\n# 1) remove points where y > 0.7\nx2 = x[y <= 0.7]\ny2 = y[y <= 0.7]\n\n# 2) mask points where y > 0.7\ny3 = np.ma.masked_where(y > 0.7, y)\n\n# 3) set to NaN where y > 0.7\ny4 = y.copy()\ny4[y3 > 0.7] = np.nan\n\nplt.plot(x*0.1, y, 'o-', color='lightgrey', label='No mask')\nplt.plot(x2*0.4, y2, 'o-', label='Points removed')\nplt.plot(x*0.7, y3, 'o-', label='Masked values')\nplt.plot(x*1.0, y4, 'o-', label='NaN values')\nplt.legend()\nplt.title('Masked and NaN data')\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_030_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================\nMulticolored lines\n==================\n\nThis example shows how to make a multicolored line. In this example, the line\nis colored based on its derivative.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import LineCollection\nfrom matplotlib.colors import BoundaryNorm, ListedColormap\n\nx = np.linspace(0, 3 * np.pi, 500)\ny = np.sin(x)\ndydx = np.cos(0.5 * (x[:-1] + x[1:]))  # first derivative\n\n# Create a set of line segments so that we can color them individually\n# This creates the points as an N x 1 x 2 array so that we can stack points\n# together easily to get the segments. The segments array for line collection\n# needs to be (numlines) x (points per line) x 2 (for x and y)\npoints = np.array([x, y]).T.reshape(-1, 1, 2)\nsegments = np.concatenate([points[:-1], points[1:]], axis=1)\n\nfig, axs = plt.subplots(2, 1, sharex=True, sharey=True)\n\n# Create a continuous norm to map from data points to colors\nnorm = plt.Normalize(dydx.min(), dydx.max())\nlc = LineCollection(segments, cmap='viridis', norm=norm)\n# Set the values used for colormapping\nlc.set_array(dydx)\nlc.set_linewidth(2)\nline = axs[0].add_collection(lc)\nfig.colorbar(line, ax=axs[0])\n\n# Use a boundary norm instead\ncmap = ListedColormap(['r', 'g', 'b'])\nnorm = BoundaryNorm([-1, -0.5, 0.5, 1], cmap.N)\nlc = LineCollection(segments, cmap=cmap, norm=norm)\nlc.set_array(dydx)\nlc.set_linewidth(2)\nline = axs[1].add_collection(lc)\nfig.colorbar(line, ax=axs[1])\n\naxs[0].set_xlim(x.min(), x.max())\naxs[0].set_ylim(-1.1, 1.1)\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_031_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============================================\nMapping marker properties to multivariate data\n==============================================\n\nThis example shows how to use different properties of markers to plot\nmultivariate datasets. Here we represent a successful baseball throw as a\nsmiley face with marker size mapped to the skill of thrower, marker rotation to\nthe take-off angle, and thrust to the marker color.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import Normalize\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.text import TextPath\nfrom matplotlib.transforms import Affine2D\n\nSUCCESS_SYMBOLS = [\n    TextPath((0, 0), \"\u2639\"),\n    TextPath((0, 0), \"\ud83d\ude12\"),\n    TextPath((0, 0), \"\u263a\"),\n]\n\nN = 25\nnp.random.seed(42)\nskills = np.random.uniform(5, 80, size=N) * 0.1 + 5\ntakeoff_angles = np.random.normal(0, 90, N)\nthrusts = np.random.uniform(size=N)\nsuccessful = np.random.randint(0, 3, size=N)\npositions = np.random.normal(size=(N, 2)) * 5\ndata = zip(skills, takeoff_angles, thrusts, successful, positions)\n\ncmap = plt.colormaps[\"plasma\"]\nfig, ax = plt.subplots()\nfig.suptitle(\"Throwing success\", size=14)\nfor skill, takeoff, thrust, mood, pos in data:\n    t = Affine2D().scale(skill).rotate_deg(takeoff)\n    m = MarkerStyle(SUCCESS_SYMBOLS[mood], transform=t)\n    ax.plot(pos[0], pos[1], marker=m, color=cmap(thrust))\nfig.colorbar(plt.cm.ScalarMappable(norm=Normalize(0, 1), cmap=cmap),\n             ax=ax, label=\"Normalized Thrust [a.u.]\")\nax.set_xlabel(\"X position [m]\")\nax.set_ylabel(\"Y position [m]\")\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_032_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========\nPsd Demo\n========\n\nPlotting Power Spectral Density (PSD) in Matplotlib.\n\nThe PSD is a common plot in the field of signal processing. NumPy has\nmany useful libraries for computing a PSD. Below we demo a few examples\nof how this can be accomplished and visualized with Matplotlib.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.mlab as mlab\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\ndt = 0.01\nt = np.arange(0, 10, dt)\nnse = np.random.randn(len(t))\nr = np.exp(-t / 0.05)\n\ncnse = np.convolve(nse, r) * dt\ncnse = cnse[:len(t)]\ns = 0.1 * np.sin(2 * np.pi * t) + cnse\n\nfig, (ax0, ax1) = plt.subplots(2, 1)\nax0.plot(t, s)\nax1.psd(s, 512, 1 / dt)\n\nplt.show()\n\n# %%\n# Compare this with the equivalent Matlab code to accomplish the same thing::\n#\n#     dt = 0.01;\n#     t = [0:dt:10];\n#     nse = randn(size(t));\n#     r = exp(-t/0.05);\n#     cnse = conv(nse, r)*dt;\n#     cnse = cnse(1:length(t));\n#     s = 0.1*sin(2*pi*t) + cnse;\n#\n#     subplot(211)\n#     plot(t, s)\n#     subplot(212)\n#     psd(s, 512, 1/dt)\n#\n# Below we'll show a slightly more complex example that demonstrates\n# how padding affects the resulting PSD.\n\ndt = np.pi / 100.\nfs = 1. / dt\nt = np.arange(0, 8, dt)\ny = 10. * np.sin(2 * np.pi * 4 * t) + 5. * np.sin(2 * np.pi * 4.25 * t)\ny = y + np.random.randn(*t.shape)\n\n# Plot the raw time series\nfig, axs = plt.subplot_mosaic([\n    ['signal', 'signal', 'signal'],\n    ['zero padding', 'block size', 'overlap'],\n], layout='constrained')\n\naxs['signal'].plot(t, y)\naxs['signal'].set_xlabel('time [s]')\naxs['signal'].set_ylabel('signal')\n\n# Plot the PSD with different amounts of zero padding. This uses the entire\n# time series at once\naxs['zero padding'].psd(y, NFFT=len(t), pad_to=len(t), Fs=fs)\naxs['zero padding'].psd(y, NFFT=len(t), pad_to=len(t) * 2, Fs=fs)\naxs['zero padding'].psd(y, NFFT=len(t), pad_to=len(t) * 4, Fs=fs)\n\n# Plot the PSD with different block sizes, Zero pad to the length of the\n# original data sequence.\naxs['block size'].psd(y, NFFT=len(t), pad_to=len(t), Fs=fs)\naxs['block size'].psd(y, NFFT=len(t) // 2, pad_to=len(t), Fs=fs)\naxs['block size'].psd(y, NFFT=len(t) // 4, pad_to=len(t), Fs=fs)\naxs['block size'].set_ylabel('')\n\n# Plot the PSD with different amounts of overlap between blocks\naxs['overlap'].psd(y, NFFT=len(t) // 2, pad_to=len(t), noverlap=0, Fs=fs)\naxs['overlap'].psd(y, NFFT=len(t) // 2, pad_to=len(t),\n                   noverlap=int(0.025 * len(t)), Fs=fs)\naxs['overlap'].psd(y, NFFT=len(t) // 2, pad_to=len(t),\n                   noverlap=int(0.1 * len(t)), Fs=fs)\naxs['overlap'].set_ylabel('')\naxs['overlap'].set_title('overlap')\n\nfor title, ax in axs.items():\n    if title == 'signal':\n        continue\n\n    ax.set_title(title)\n    ax.sharex(axs['zero padding'])\n    ax.sharey(axs['zero padding'])\n\nplt.show()\n\n\n# %%\n# This is a ported version of a MATLAB example from the signal\n# processing toolbox that showed some difference at one time between\n# Matplotlib's and MATLAB's scaling of the PSD.\n\nfs = 1000\nt = np.linspace(0, 0.3, 301)\nA = np.array([2, 8]).reshape(-1, 1)\nf = np.array([150, 140]).reshape(-1, 1)\nxn = (A * np.sin(2 * np.pi * f * t)).sum(axis=0)\nxn += 5 * np.random.randn(*t.shape)\n\nfig, (ax0, ax1) = plt.subplots(ncols=2, layout='constrained')\n\nyticks = np.arange(-50, 30, 10)\nyrange = (yticks[0], yticks[-1])\nxticks = np.arange(0, 550, 100)\n\nax0.psd(xn, NFFT=301, Fs=fs, window=mlab.window_none, pad_to=1024,\n        scale_by_freq=True)\nax0.set_title('Periodogram')\nax0.set_yticks(yticks)\nax0.set_xticks(xticks)\nax0.grid(True)\nax0.set_ylim(yrange)\n\nax1.psd(xn, NFFT=150, Fs=fs, window=mlab.window_none, pad_to=512, noverlap=75,\n        scale_by_freq=True)\nax1.set_title('Welch')\nax1.set_xticks(xticks)\nax1.set_yticks(yticks)\nax1.set_ylabel('')  # overwrite the y-label added by `psd`\nax1.grid(True)\nax1.set_ylim(yrange)\n\nplt.show()\n\n# %%\n# This is a ported version of a MATLAB example from the signal\n# processing toolbox that showed some difference at one time between\n# Matplotlib's and MATLAB's scaling of the PSD.\n#\n# It uses a complex signal so we can see that complex PSD's work properly.\n\nprng = np.random.RandomState(19680801)  # to ensure reproducibility\n\nfs = 1000\nt = np.linspace(0, 0.3, 301)\nA = np.array([2, 8]).reshape(-1, 1)\nf = np.array([150, 140]).reshape(-1, 1)\nxn = (A * np.exp(2j * np.pi * f * t)).sum(axis=0) + 5 * prng.randn(*t.shape)\n\nfig, (ax0, ax1) = plt.subplots(ncols=2, layout='constrained')\n\nyticks = np.arange(-50, 30, 10)\nyrange = (yticks[0], yticks[-1])\nxticks = np.arange(-500, 550, 200)\n\nax0.psd(xn, NFFT=301, Fs=fs, window=mlab.window_none, pad_to=1024,\n        scale_by_freq=True)\nax0.set_title('Periodogram')\nax0.set_yticks(yticks)\nax0.set_xticks(xticks)\nax0.grid(True)\nax0.set_ylim(yrange)\n\nax1.psd(xn, NFFT=150, Fs=fs, window=mlab.window_none, pad_to=512, noverlap=75,\n        scale_by_freq=True)\nax1.set_title('Welch')\nax1.set_xticks(xticks)\nax1.set_yticks(yticks)\nax1.set_ylabel('')  # overwrite the y-label added by `psd`\nax1.grid(True)\nax1.set_ylim(yrange)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_033_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============================\nScatter plot with histograms\n============================\n\nShow the marginal distributions of a scatter plot as histograms at the sides of\nthe plot.\n\nFor a nice alignment of the main axes with the marginals, two options are shown\nbelow:\n\n.. contents::\n   :local:\n\nWhile `.Axes.inset_axes` may be a bit more complex, it allows correct handling\nof main axes with a fixed aspect ratio.\n\nAn alternative method to produce a similar figure using the ``axes_grid1``\ntoolkit is shown in the :doc:`/gallery/axes_grid1/scatter_hist_locatable_axes`\nexample.  Finally, it is also possible to position all axes in absolute\ncoordinates using `.Figure.add_axes` (not shown here).\n\nLet us first define a function that takes x and y data as input, as well\nas three axes, the main axes for the scatter, and two marginal axes. It will\nthen create the scatter and histograms inside the provided axes.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# some random data\nx = np.random.randn(1000)\ny = np.random.randn(1000)\n\n\ndef scatter_hist(x, y, ax, ax_histx, ax_histy):\n    # no labels\n    ax_histx.tick_params(axis=\"x\", labelbottom=False)\n    ax_histy.tick_params(axis=\"y\", labelleft=False)\n\n    # the scatter plot:\n    ax.scatter(x, y)\n\n    # now determine nice limits by hand:\n    binwidth = 0.25\n    xymax = max(np.max(np.abs(x)), np.max(np.abs(y)))\n    lim = (int(xymax/binwidth) + 1) * binwidth\n\n    bins = np.arange(-lim, lim + binwidth, binwidth)\n    ax_histx.hist(x, bins=bins)\n    ax_histy.hist(y, bins=bins, orientation='horizontal')\n\n\n# %%\n#\n# Defining the axes positions using a gridspec\n# --------------------------------------------\n#\n# We define a gridspec with unequal width- and height-ratios to achieve desired\n# layout.  Also see the :ref:`arranging_axes` tutorial.\n\n# Start with a square Figure.\nfig = plt.figure(figsize=(6, 6))\n# Add a gridspec with two rows and two columns and a ratio of 1 to 4 between\n# the size of the marginal axes and the main axes in both directions.\n# Also adjust the subplot parameters for a square plot.\ngs = fig.add_gridspec(2, 2,  width_ratios=(4, 1), height_ratios=(1, 4),\n                      left=0.1, right=0.9, bottom=0.1, top=0.9,\n                      wspace=0.05, hspace=0.05)\n# Create the Axes.\nax = fig.add_subplot(gs[1, 0])\nax_histx = fig.add_subplot(gs[0, 0], sharex=ax)\nax_histy = fig.add_subplot(gs[1, 1], sharey=ax)\n# Draw the scatter plot and marginals.\nscatter_hist(x, y, ax, ax_histx, ax_histy)\n\n\n# %%\n#\n# Defining the axes positions using inset_axes\n# --------------------------------------------\n#\n# `~.Axes.inset_axes` can be used to position marginals *outside* the main\n# axes.  The advantage of doing so is that the aspect ratio of the main axes\n# can be fixed, and the marginals will always be drawn relative to the position\n# of the axes.\n\n# Create a Figure, which doesn't have to be square.\nfig = plt.figure(layout='constrained')\n# Create the main axes, leaving 25% of the figure space at the top and on the\n# right to position marginals.\nax = fig.add_gridspec(top=0.75, right=0.75).subplots()\n# The main axes' aspect can be fixed.\nax.set(aspect=1)\n# Create marginal axes, which have 25% of the size of the main axes.  Note that\n# the inset axes are positioned *outside* (on the right and the top) of the\n# main axes, by specifying axes coordinates greater than 1.  Axes coordinates\n# less than 0 would likewise specify positions on the left and the bottom of\n# the main axes.\nax_histx = ax.inset_axes([0, 1.05, 1, 0.25], sharex=ax)\nax_histy = ax.inset_axes([1.05, 0, 0.25, 1], sharey=ax)\n# Draw the scatter plot and marginals.\nscatter_hist(x, y, ax, ax_histx, ax_histy)\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.figure.Figure.add_subplot`\n#    - `matplotlib.figure.Figure.add_gridspec`\n#    - `matplotlib.axes.Axes.inset_axes`\n#    - `matplotlib.axes.Axes.scatter`\n#    - `matplotlib.axes.Axes.hist`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_034_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============\nScatter Masked\n==============\n\nMask some data points and add a line demarking\nmasked regions.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nN = 100\nr0 = 0.6\nx = 0.9 * np.random.rand(N)\ny = 0.9 * np.random.rand(N)\narea = (20 * np.random.rand(N))**2  # 0 to 10 point radii\nc = np.sqrt(area)\nr = np.sqrt(x ** 2 + y ** 2)\narea1 = np.ma.masked_where(r < r0, area)\narea2 = np.ma.masked_where(r >= r0, area)\nplt.scatter(x, y, s=area1, marker='^', c=c)\nplt.scatter(x, y, s=area2, marker='o', c=c)\n# Show the boundary between the regions:\ntheta = np.arange(0, np.pi / 2, 0.01)\nplt.plot(r0 * np.cos(theta), r0 * np.sin(theta))\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_035_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============\nMarker examples\n===============\n\nExample with different ways to specify markers.\n\nSee also the `matplotlib.markers` documentation for a list of all markers and\n:doc:`/gallery/lines_bars_and_markers/marker_reference` for more information\non configuring markers.\n\n.. redirect-from:: /gallery/lines_bars_and_markers/scatter_custom_symbol\n.. redirect-from:: /gallery/lines_bars_and_markers/scatter_symbol\n.. redirect-from:: /gallery/lines_bars_and_markers/scatter_piecharts\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx = np.random.rand(10)\ny = np.random.rand(10)\nz = np.sqrt(x**2 + y**2)\n\nfig, axs = plt.subplots(2, 3, sharex=True, sharey=True, layout=\"constrained\")\n\n# Matplotlib marker symbol\naxs[0, 0].scatter(x, y, s=80, c=z, marker=\">\")\naxs[0, 0].set_title(\"marker='>'\")\n\n# marker from TeX: passing a TeX symbol name enclosed in $-signs\naxs[0, 1].scatter(x, y, s=80, c=z, marker=r\"$\\clubsuit$\")\naxs[0, 1].set_title(r\"marker=r'\\$\\clubsuit\\$'\")\n\n# marker from path: passing a custom path of N vertices as a (N, 2) array-like\nverts = [[-1, -1], [1, -1], [1, 1], [-1, -1]]\naxs[0, 2].scatter(x, y, s=80, c=z, marker=verts)\naxs[0, 2].set_title(\"marker=verts\")\n\n# regular pentagon marker\naxs[1, 0].scatter(x, y, s=80, c=z, marker=(5, 0))\naxs[1, 0].set_title(\"marker=(5, 0)\")\n\n# regular 5-pointed star marker\naxs[1, 1].scatter(x, y, s=80, c=z, marker=(5, 1))\naxs[1, 1].set_title(\"marker=(5, 1)\")\n\n# regular 5-pointed asterisk marker\naxs[1, 2].scatter(x, y, s=80, c=z, marker=(5, 2))\naxs[1, 2].set_title(\"marker=(5, 2)\")\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_036_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========================\nScatter plots with a legend\n===========================\n\nTo create a scatter plot with a legend one may use a loop and create one\n`~.Axes.scatter` plot per item to appear in the legend and set the ``label``\naccordingly.\n\nThe following also demonstrates how transparency of the markers\ncan be adjusted by giving ``alpha`` a value between 0 and 1.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\nfor color in ['tab:blue', 'tab:orange', 'tab:green']:\n    n = 750\n    x, y = np.random.rand(2, n)\n    scale = 200.0 * np.random.rand(n)\n    ax.scatter(x, y, c=color, s=scale, label=color,\n               alpha=0.3, edgecolors='none')\n\nax.legend()\nax.grid(True)\n\nplt.show()\n\n\n# %%\n# .. _automatedlegendcreation:\n#\n# Automated legend creation\n# -------------------------\n#\n# Another option for creating a legend for a scatter is to use the\n# `.PathCollection.legend_elements` method.  It will automatically try to\n# determine a useful number of legend entries to be shown and return a tuple of\n# handles and labels. Those can be passed to the call to `~.axes.Axes.legend`.\n\n\nN = 45\nx, y = np.random.rand(2, N)\nc = np.random.randint(1, 5, size=N)\ns = np.random.randint(10, 220, size=N)\n\nfig, ax = plt.subplots()\n\nscatter = ax.scatter(x, y, c=c, s=s)\n\n# produce a legend with the unique colors from the scatter\nlegend1 = ax.legend(*scatter.legend_elements(),\n                    loc=\"lower left\", title=\"Classes\")\nax.add_artist(legend1)\n\n# produce a legend with a cross-section of sizes from the scatter\nhandles, labels = scatter.legend_elements(prop=\"sizes\", alpha=0.6)\nlegend2 = ax.legend(handles, labels, loc=\"upper right\", title=\"Sizes\")\n\nplt.show()\n\n\n# %%\n# Further arguments to the `.PathCollection.legend_elements` method\n# can be used to steer how many legend entries are to be created and how they\n# should be labeled. The following shows how to use some of them.\n\nvolume = np.random.rayleigh(27, size=40)\namount = np.random.poisson(10, size=40)\nranking = np.random.normal(size=40)\nprice = np.random.uniform(1, 10, size=40)\n\nfig, ax = plt.subplots()\n\n# Because the price is much too small when being provided as size for ``s``,\n# we normalize it to some useful point sizes, s=0.3*(price*3)**2\nscatter = ax.scatter(volume, amount, c=ranking, s=0.3*(price*3)**2,\n                     vmin=-3, vmax=3, cmap=\"Spectral\")\n\n# Produce a legend for the ranking (colors). Even though there are 40 different\n# rankings, we only want to show 5 of them in the legend.\nlegend1 = ax.legend(*scatter.legend_elements(num=5),\n                    loc=\"upper left\", title=\"Ranking\")\nax.add_artist(legend1)\n\n# Produce a legend for the price (sizes). Because we want to show the prices\n# in dollars, we use the *func* argument to supply the inverse of the function\n# used to calculate the sizes from above. The *fmt* ensures to show the price\n# in dollars. Note how we target at 5 elements here, but obtain only 4 in the\n# created legend due to the automatic round prices that are chosen for us.\nkw = dict(prop=\"sizes\", num=5, color=scatter.cmap(0.7), fmt=\"$ {x:.2f}\",\n          func=lambda s: np.sqrt(s/.3)/3)\nlegend2 = ax.legend(*scatter.legend_elements(**kw),\n                    loc=\"lower right\", title=\"Price\")\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.scatter` / `matplotlib.pyplot.scatter`\n#    - `matplotlib.axes.Axes.legend` / `matplotlib.pyplot.legend`\n#    - `matplotlib.collections.PathCollection.legend_elements`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_037_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========\nSimple Plot\n===========\n\nCreate a simple plot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Data for plotting\nt = np.arange(0.0, 2.0, 0.01)\ns = 1 + np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\nax.set(xlabel='time (s)', ylabel='voltage (mV)',\n       title='About as simple as it gets, folks')\nax.grid()\n\nfig.savefig(\"test.png\")\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.figure.Figure.savefig`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_038_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========================================================\nShade regions defined by a logical mask using fill_between\n==========================================================\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2, 0.01)\ns = np.sin(2*np.pi*t)\n\nfig, ax = plt.subplots()\n\nax.plot(t, s, color='black')\nax.axhline(0, color='black')\n\nax.fill_between(t, 1, where=s > 0, facecolor='green', alpha=.5)\nax.fill_between(t, -1, where=s < 0, facecolor='red', alpha=.5)\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.fill_between`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_039_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========================\nSpectrum Representations\n========================\n\nThe plots show different spectrum representations of a sine signal with\nadditive noise. A (frequency) spectrum of a discrete-time signal is calculated\nby utilizing the fast Fourier transform (FFT).\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(0)\n\ndt = 0.01  # sampling interval\nFs = 1 / dt  # sampling frequency\nt = np.arange(0, 10, dt)\n\n# generate noise:\nnse = np.random.randn(len(t))\nr = np.exp(-t / 0.05)\ncnse = np.convolve(nse, r) * dt\ncnse = cnse[:len(t)]\n\ns = 0.1 * np.sin(4 * np.pi * t) + cnse  # the signal\n\nfig, axs = plt.subplots(nrows=3, ncols=2, figsize=(7, 7))\n\n# plot time signal:\naxs[0, 0].set_title(\"Signal\")\naxs[0, 0].plot(t, s, color='C0')\naxs[0, 0].set_xlabel(\"Time\")\naxs[0, 0].set_ylabel(\"Amplitude\")\n\n# plot different spectrum types:\naxs[1, 0].set_title(\"Magnitude Spectrum\")\naxs[1, 0].magnitude_spectrum(s, Fs=Fs, color='C1')\n\naxs[1, 1].set_title(\"Log. Magnitude Spectrum\")\naxs[1, 1].magnitude_spectrum(s, Fs=Fs, scale='dB', color='C1')\n\naxs[2, 0].set_title(\"Phase Spectrum \")\naxs[2, 0].phase_spectrum(s, Fs=Fs, color='C2')\n\naxs[2, 1].set_title(\"Angle Spectrum\")\naxs[2, 1].angle_spectrum(s, Fs=Fs, color='C2')\n\naxs[0, 1].remove()  # don't display empty ax\n\nfig.tight_layout()\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_040_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========================\nStackplots and streamgraphs\n===========================\n\"\"\"\n\n# %%\n# Stackplots\n# ----------\n#\n# Stackplots draw multiple datasets as vertically stacked areas. This is\n# useful when the individual data values and additionally their cumulative\n# value are of interest.\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# data from United Nations World Population Prospects (Revision 2019)\n# https://population.un.org/wpp/, license: CC BY 3.0 IGO\nyear = [1950, 1960, 1970, 1980, 1990, 2000, 2010, 2018]\npopulation_by_continent = {\n    'africa': [228, 284, 365, 477, 631, 814, 1044, 1275],\n    'americas': [340, 425, 519, 619, 727, 840, 943, 1006],\n    'asia': [1394, 1686, 2120, 2625, 3202, 3714, 4169, 4560],\n    'europe': [220, 253, 276, 295, 310, 303, 294, 293],\n    'oceania': [12, 15, 19, 22, 26, 31, 36, 39],\n}\n\nfig, ax = plt.subplots()\nax.stackplot(year, population_by_continent.values(),\n             labels=population_by_continent.keys(), alpha=0.8)\nax.legend(loc='upper left')\nax.set_title('World population')\nax.set_xlabel('Year')\nax.set_ylabel('Number of people (millions)')\n\nplt.show()\n\n# %%\n# Streamgraphs\n# ------------\n#\n# Using the *baseline* parameter, you can turn an ordinary stacked area plot\n# with baseline 0 into a stream graph.\n\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef gaussian_mixture(x, n=5):\n    \"\"\"Return a random mixture of *n* Gaussians, evaluated at positions *x*.\"\"\"\n    def add_random_gaussian(a):\n        amplitude = 1 / (.1 + np.random.random())\n        dx = x[-1] - x[0]\n        x0 = (2 * np.random.random() - .5) * dx\n        z = 10 / (.1 + np.random.random()) / dx\n        a += amplitude * np.exp(-(z * (x - x0))**2)\n    a = np.zeros_like(x)\n    for j in range(n):\n        add_random_gaussian(a)\n    return a\n\n\nx = np.linspace(0, 100, 101)\nys = [gaussian_mixture(x) for _ in range(3)]\n\nfig, ax = plt.subplots()\nax.stackplot(x, ys, baseline='wiggle')\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_041_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========\nStairs Demo\n===========\n\nThis example demonstrates the use of `~.matplotlib.pyplot.stairs` for stepwise\nconstant functions. A common use case is histogram and histogram-like data\nvisualization.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import StepPatch\n\nnp.random.seed(0)\nh, edges = np.histogram(np.random.normal(5, 3, 5000),\n                        bins=np.linspace(0, 10, 20))\n\nfig, axs = plt.subplots(3, 1, figsize=(7, 15))\naxs[0].stairs(h, edges, label='Simple histogram')\naxs[0].stairs(h, edges + 5, baseline=50, label='Modified baseline')\naxs[0].stairs(h, edges + 10, baseline=None, label='No edges')\naxs[0].set_title(\"Step Histograms\")\n\naxs[1].stairs(np.arange(1, 6, 1), fill=True,\n              label='Filled histogram\\nw/ automatic edges')\naxs[1].stairs(np.arange(1, 6, 1)*0.3, np.arange(2, 8, 1),\n              orientation='horizontal', hatch='//',\n              label='Hatched histogram\\nw/ horizontal orientation')\naxs[1].set_title(\"Filled histogram\")\n\npatch = StepPatch(values=[1, 2, 3, 2, 1],\n                  edges=range(1, 7),\n                  label=('Patch derived underlying object\\n'\n                         'with default edge/facecolor behaviour'))\naxs[2].add_patch(patch)\naxs[2].set_xlim(0, 7)\naxs[2].set_ylim(-1, 5)\naxs[2].set_title(\"StepPatch artist\")\n\nfor ax in axs:\n    ax.legend()\nplt.show()\n\n# %%\n# *baseline* can take an array to allow for stacked histogram plots\nA = [[0, 0, 0],\n     [1, 2, 3],\n     [2, 4, 6],\n     [3, 6, 9]]\n\nfor i in range(len(A) - 1):\n    plt.stairs(A[i+1], baseline=A[i], fill=True)\n\n# %%\n# Comparison of `.pyplot.step` and `.pyplot.stairs`\n# -------------------------------------------------\n#\n# `.pyplot.step` defines the positions of the steps as single values. The steps\n# extend left/right/both ways from these reference values depending on the\n# parameter *where*. The number of *x* and *y* values is the same.\n#\n# In contrast, `.pyplot.stairs` defines the positions of the steps via their\n# bounds *edges*, which is one element longer than the step values.\n\nbins = np.arange(14)\ncenters = bins[:-1] + np.diff(bins) / 2\ny = np.sin(centers / 2)\n\nplt.step(bins[:-1], y, where='post', label='step(where=\"post\")')\nplt.plot(bins[:-1], y, 'o--', color='grey', alpha=0.3)\n\nplt.stairs(y - 1, bins, baseline=None, label='stairs()')\nplt.plot(centers, y - 1, 'o--', color='grey', alpha=0.3)\nplt.plot(np.repeat(bins, 2), np.hstack([y[0], np.repeat(y, 2), y[-1]]) - 1,\n         'o', color='red', alpha=0.2)\n\nplt.legend()\nplt.title('step() vs. stairs()')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.stairs` / `matplotlib.pyplot.stairs`\n#    - `matplotlib.patches.StepPatch`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_042_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========\nStem Plot\n=========\n\n`~.pyplot.stem` plots vertical lines from a baseline to the y-coordinate and\nplaces a marker at the tip.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0.1, 2 * np.pi, 41)\ny = np.exp(np.sin(x))\n\nplt.stem(x, y)\nplt.show()\n\n# %%\n#\n# The position of the baseline can be adapted using *bottom*.\n# The parameters *linefmt*, *markerfmt*, and *basefmt* control basic format\n# properties of the plot. However, in contrast to `~.pyplot.plot` not all\n# properties are configurable via keyword arguments. For more advanced\n# control adapt the line objects returned by `.pyplot`.\n\nmarkerline, stemlines, baseline = plt.stem(\n    x, y, linefmt='grey', markerfmt='D', bottom=1.1)\nmarkerline.set_markerfacecolor('none')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.stem` / `matplotlib.pyplot.stem`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_043_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========\nStep Demo\n=========\n\nThis example demonstrates the use of `.pyplot.step` for piece-wise constant\ncurves. In particular, it illustrates the effect of the parameter *where*\non the step position.\n\n.. note::\n\n    For the common case that you know the edge positions, use `.pyplot.stairs`\n    instead.\n\nThe circular markers created with `.pyplot.plot` show the actual data\npositions so that it's easier to see the effect of *where*.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.arange(14)\ny = np.sin(x / 2)\n\nplt.step(x, y + 2, label='pre (default)')\nplt.plot(x, y + 2, 'o--', color='grey', alpha=0.3)\n\nplt.step(x, y + 1, where='mid', label='mid')\nplt.plot(x, y + 1, 'o--', color='grey', alpha=0.3)\n\nplt.step(x, y, where='post', label='post')\nplt.plot(x, y, 'o--', color='grey', alpha=0.3)\n\nplt.grid(axis='x', color='0.95')\nplt.legend(title='Parameter where:')\nplt.title('plt.step(where=...)')\nplt.show()\n\n# %%\n# The same behavior can be achieved by using the ``drawstyle`` parameter of\n# `.pyplot.plot`.\n\nplt.plot(x, y + 2, drawstyle='steps', label='steps (=steps-pre)')\nplt.plot(x, y + 2, 'o--', color='grey', alpha=0.3)\n\nplt.plot(x, y + 1, drawstyle='steps-mid', label='steps-mid')\nplt.plot(x, y + 1, 'o--', color='grey', alpha=0.3)\n\nplt.plot(x, y, drawstyle='steps-post', label='steps-post')\nplt.plot(x, y, 'o--', color='grey', alpha=0.3)\n\nplt.grid(axis='x', color='0.95')\nplt.legend(title='Parameter drawstyle:')\nplt.title('plt.plot(drawstyle=...)')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.step` / `matplotlib.pyplot.step`\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_044_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============================================\nCreating a timeline with lines, dates, and text\n===============================================\n\nHow to create a simple timeline using Matplotlib release dates.\n\nTimelines can be created with a collection of dates and text. In this example,\nwe show how to create a simple timeline using the dates for recent releases\nof Matplotlib. First, we'll pull the data from GitHub.\n\"\"\"\n\nfrom datetime import datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.dates as mdates\n\ntry:\n    # Try to fetch a list of Matplotlib releases and their dates\n    # from https://api.github.com/repos/matplotlib/matplotlib/releases\n    import json\n    import urllib.request\n\n    url = 'https://api.github.com/repos/matplotlib/matplotlib/releases'\n    url += '?per_page=100'\n    data = json.loads(urllib.request.urlopen(url, timeout=1).read().decode())\n\n    dates = []\n    names = []\n    for item in data:\n        if 'rc' not in item['tag_name'] and 'b' not in item['tag_name']:\n            dates.append(item['published_at'].split(\"T\")[0])\n            names.append(item['tag_name'])\n    # Convert date strings (e.g. 2014-10-18) to datetime\n    dates = [datetime.strptime(d, \"%Y-%m-%d\") for d in dates]\n\nexcept Exception:\n    # In case the above fails, e.g. because of missing internet connection\n    # use the following lists as fallback.\n    names = ['v2.2.4', 'v3.0.3', 'v3.0.2', 'v3.0.1', 'v3.0.0', 'v2.2.3',\n             'v2.2.2', 'v2.2.1', 'v2.2.0', 'v2.1.2', 'v2.1.1', 'v2.1.0',\n             'v2.0.2', 'v2.0.1', 'v2.0.0', 'v1.5.3', 'v1.5.2', 'v1.5.1',\n             'v1.5.0', 'v1.4.3', 'v1.4.2', 'v1.4.1', 'v1.4.0']\n\n    dates = ['2019-02-26', '2019-02-26', '2018-11-10', '2018-11-10',\n             '2018-09-18', '2018-08-10', '2018-03-17', '2018-03-16',\n             '2018-03-06', '2018-01-18', '2017-12-10', '2017-10-07',\n             '2017-05-10', '2017-05-02', '2017-01-17', '2016-09-09',\n             '2016-07-03', '2016-01-10', '2015-10-29', '2015-02-16',\n             '2014-10-26', '2014-10-18', '2014-08-26']\n\n    # Convert date strings (e.g. 2014-10-18) to datetime\n    dates = [datetime.strptime(d, \"%Y-%m-%d\") for d in dates]\n\n# %%\n# Next, we'll create a stem plot with some variation in levels as to\n# distinguish even close-by events. We add markers on the baseline for visual\n# emphasis on the one-dimensional nature of the timeline.\n#\n# For each event, we add a text label via `~.Axes.annotate`, which is offset\n# in units of points from the tip of the event line.\n#\n# Note that Matplotlib will automatically plot datetime inputs.\n\n\n# Choose some nice levels\nlevels = np.tile([-5, 5, -3, 3, -1, 1],\n                 int(np.ceil(len(dates)/6)))[:len(dates)]\n\n# Create figure and plot a stem plot with the date\nfig, ax = plt.subplots(figsize=(8.8, 4), layout=\"constrained\")\nax.set(title=\"Matplotlib release dates\")\n\nax.vlines(dates, 0, levels, color=\"tab:red\")  # The vertical stems.\nax.plot(dates, np.zeros_like(dates), \"-o\",\n        color=\"k\", markerfacecolor=\"w\")  # Baseline and markers on it.\n\n# annotate lines\nfor d, l, r in zip(dates, levels, names):\n    ax.annotate(r, xy=(d, l),\n                xytext=(-3, np.sign(l)*3), textcoords=\"offset points\",\n                horizontalalignment=\"right\",\n                verticalalignment=\"bottom\" if l > 0 else \"top\")\n\n# format x-axis with 4-month intervals\nax.xaxis.set_major_locator(mdates.MonthLocator(interval=4))\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%b %Y\"))\nplt.setp(ax.get_xticklabels(), rotation=30, ha=\"right\")\n\n# remove y-axis and spines\nax.yaxis.set_visible(False)\nax.spines[[\"left\", \"top\", \"right\"]].set_visible(False)\n\nax.margins(y=0.1)\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.annotate`\n#    - `matplotlib.axes.Axes.vlines`\n#    - `matplotlib.axis.Axis.set_major_locator`\n#    - `matplotlib.axis.Axis.set_major_formatter`\n#    - `matplotlib.dates.MonthLocator`\n#    - `matplotlib.dates.DateFormatter`"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_045_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================\nhlines and vlines\n=================\n\nThis example showcases the functions hlines and vlines.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nt = np.arange(0.0, 5.0, 0.1)\ns = np.exp(-t) + np.sin(2 * np.pi * t) + 1\nnse = np.random.normal(0.0, 0.3, t.shape) * s\n\nfig, (vax, hax) = plt.subplots(1, 2, figsize=(12, 6))\n\nvax.plot(t, s + nse, '^')\nvax.vlines(t, [0], s)\n# By using ``transform=vax.get_xaxis_transform()`` the y coordinates are scaled\n# such that 0 maps to the bottom of the axes and 1 to the top.\nvax.vlines([1, 2], 0, 1, transform=vax.get_xaxis_transform(), colors='r')\nvax.set_xlabel('time (s)')\nvax.set_title('Vertical lines demo')\n\nhax.plot(s + nse, t, '^')\nhax.hlines(t, [0], s, lw=2)\nhax.set_xlabel('time (s)')\nhax.set_title('Horizontal lines demo')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/01lines_bars_and_markers_046_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================================\nCross- and Auto-Correlation Demo\n================================\n\nExample use of cross-correlation (`~.Axes.xcorr`) and auto-correlation\n(`~.Axes.acorr`) plots.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nx, y = np.random.randn(2, 100)\nfig, [ax1, ax2] = plt.subplots(2, 1, sharex=True)\nax1.xcorr(x, y, usevlines=True, maxlags=50, normed=True, lw=2)\nax1.grid(True)\n\nax2.acorr(x, usevlines=True, normed=True, maxlags=50, lw=2)\nax2.grid(True)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.acorr` / `matplotlib.pyplot.acorr`\n#    - `matplotlib.axes.Axes.xcorr` / `matplotlib.pyplot.xcorr`"
      }
    ],
    "02images_contours_and_fields": [
      {
        "image_path": "gallery_assets/02images_contours_and_fields_047_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============================\nAffine transform of an image\n============================\n\n\nPrepending an affine transformation (`~.transforms.Affine2D`) to the :ref:`data\ntransform <data-coords>` of an image allows to manipulate the image's shape and\norientation.  This is an example of the concept of :ref:`transform chaining\n<transformation-pipeline>`.\n\nThe image of the output should have its boundary match the dashed yellow\nrectangle.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.transforms as mtransforms\n\n\ndef get_image():\n    delta = 0.25\n    x = y = np.arange(-3.0, 3.0, delta)\n    X, Y = np.meshgrid(x, y)\n    Z1 = np.exp(-X**2 - Y**2)\n    Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\n    Z = (Z1 - Z2)\n    return Z\n\n\ndef do_plot(ax, Z, transform):\n    im = ax.imshow(Z, interpolation='none',\n                   origin='lower',\n                   extent=[-2, 4, -3, 2], clip_on=True)\n\n    trans_data = transform + ax.transData\n    im.set_transform(trans_data)\n\n    # display intended extent of the image\n    x1, x2, y1, y2 = im.get_extent()\n    ax.plot([x1, x2, x2, x1, x1], [y1, y1, y2, y2, y1], \"y--\",\n            transform=trans_data)\n    ax.set_xlim(-5, 5)\n    ax.set_ylim(-4, 4)\n\n\n# prepare image and figure\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\nZ = get_image()\n\n# image rotation\ndo_plot(ax1, Z, mtransforms.Affine2D().rotate_deg(30))\n\n# image skew\ndo_plot(ax2, Z, mtransforms.Affine2D().skew_deg(30, 15))\n\n# scale and reflection\ndo_plot(ax3, Z, mtransforms.Affine2D().scale(-1, .5))\n\n# everything and a translation\ndo_plot(ax4, Z, mtransforms.Affine2D().\n        rotate_deg(30).skew_deg(30, 15).scale(-1, .5).translate(.5, -1))\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.transforms.Affine2D`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_048_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========\nWind Barbs\n==========\n\nDemonstration of wind barb plots.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-5, 5, 5)\nX, Y = np.meshgrid(x, x)\nU, V = 12 * X, 12 * Y\n\ndata = [(-1.5, .5, -6, -6),\n        (1, -1, -46, 46),\n        (-3, -1, 11, -11),\n        (1, 1.5, 80, 80),\n        (0.5, 0.25, 25, 15),\n        (-1.5, -0.5, -5, 40)]\n\ndata = np.array(data, dtype=[('x', np.float32), ('y', np.float32),\n                             ('u', np.float32), ('v', np.float32)])\n\nfig1, axs1 = plt.subplots(nrows=2, ncols=2)\n# Default parameters, uniform grid\naxs1[0, 0].barbs(X, Y, U, V)\n\n# Arbitrary set of vectors, make them longer and change the pivot point\n# (point around which they're rotated) to be the middle\naxs1[0, 1].barbs(\n    data['x'], data['y'], data['u'], data['v'], length=8, pivot='middle')\n\n# Showing colormapping with uniform grid.  Fill the circle for an empty barb,\n# don't round the values, and change some of the size parameters\naxs1[1, 0].barbs(\n    X, Y, U, V, np.sqrt(U ** 2 + V ** 2), fill_empty=True, rounding=False,\n    sizes=dict(emptybarb=0.25, spacing=0.2, height=0.3))\n\n# Change colors as well as the increments for parts of the barbs\naxs1[1, 1].barbs(data['x'], data['y'], data['u'], data['v'], flagcolor='r',\n                 barbcolor=['b', 'g'], flip_barb=True,\n                 barb_increments=dict(half=10, full=20, flag=100))\n\n# Masked arrays are also supported\nmasked_u = np.ma.masked_array(data['u'])\nmasked_u[4] = 1000  # Bad value that should not be plotted when masked\nmasked_u[4] = np.ma.masked\n\n# %%\n# Identical plot to panel 2 in the first figure, but with the point at\n# (0.5, 0.25) missing (masked)\nfig2, ax2 = plt.subplots()\nax2.barbs(data['x'], data['y'], masked_u, data['v'], length=8, pivot='middle')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.barbs` / `matplotlib.pyplot.barbs`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_049_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======\nBarcode\n=======\nThis demo shows how to produce a bar code.\n\nThe figure size is calculated so that the width in pixels is a multiple of the\nnumber of data points to prevent interpolation artifacts. Additionally, the\n``Axes`` is defined to span the whole figure and all ``Axis`` are turned off.\n\nThe data itself is rendered with `~.Axes.imshow` using\n\n- ``code.reshape(1, -1)`` to turn the data into a 2D array with one row.\n- ``imshow(..., aspect='auto')`` to allow for non-square pixels.\n- ``imshow(..., interpolation='nearest')`` to prevent blurred edges. This\n  should not happen anyway because we fine-tuned the figure width in pixels,\n  but just to be safe.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncode = np.array([\n    1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1,\n    0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0,\n    1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1,\n    1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1])\n\npixel_per_bar = 4\ndpi = 100\n\nfig = plt.figure(figsize=(len(code) * pixel_per_bar / dpi, 2), dpi=dpi)\nax = fig.add_axes([0, 0, 1, 1])  # span the whole figure\nax.set_axis_off()\nax.imshow(code.reshape(1, -1), cmap='binary', aspect='auto',\n          interpolation='nearest')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.figure.Figure.add_axes`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_050_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========================================\nInteractive Adjustment of Colormap Range\n========================================\n\nDemonstration of how a colorbar can be used to interactively adjust the\nrange of colormapping on an image. To use the interactive feature, you must\nbe in either zoom mode (magnifying glass toolbar button) or\npan mode (4-way arrow toolbar button) and click inside the colorbar.\n\nWhen zooming, the bounding box of the zoom region defines the new vmin and\nvmax of the norm. Zooming using the right mouse button will expand the\nvmin and vmax proportionally to the selected region, in the same manner that\none can zoom out on an axis. When panning, the vmin and vmax of the norm are\nboth shifted according to the direction of movement. The\nHome/Back/Forward buttons can also be used to get back to a previous state.\n\n.. redirect-from:: /gallery/userdemo/colormap_interactive_adjustment\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(0, 2 * np.pi, 1024)\ndata2d = np.sin(t)[:, np.newaxis] * np.cos(t)[np.newaxis, :]\n\nfig, ax = plt.subplots()\nim = ax.imshow(data2d)\nax.set_title('Pan on the colorbar to shift the color mapping\\n'\n             'Zoom on the colorbar to scale the color mapping')\n\nfig.colorbar(im, ax=ax, label='Interactive colorbar')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_051_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======================\nColormap normalizations\n=======================\n\nDemonstration of using norm to map colormaps onto data in non-linear ways.\n\n.. redirect-from:: /gallery/userdemo/colormap_normalizations\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors as colors\n\n# %%\n# Lognorm: Instead of pcolor log10(Z1) you can have colorbars that have\n# the exponential labels using a norm.\n\nN = 100\nX, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]\n\n# A low hump with a spike coming out of the top.  Needs to have\n# z/colour axis on a log scale, so we see both hump and spike.\n# A linear scale only shows the spike.\n\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X * 10)**2 - (Y * 10)**2)\nZ = Z1 + 50 * Z2\n\nfig, ax = plt.subplots(2, 1)\n\npcm = ax[0].pcolor(X, Y, Z,\n                   norm=colors.LogNorm(vmin=Z.min(), vmax=Z.max()),\n                   cmap='PuBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[0], extend='max')\n\npcm = ax[1].pcolor(X, Y, Z, cmap='PuBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[1], extend='max')\n\n\n# %%\n# PowerNorm: Here a power-law trend in X partially obscures a rectified\n# sine wave in Y. We can remove the power law using a PowerNorm.\n\nX, Y = np.mgrid[0:3:complex(0, N), 0:2:complex(0, N)]\nZ1 = (1 + np.sin(Y * 10.)) * X**2\n\nfig, ax = plt.subplots(2, 1)\n\npcm = ax[0].pcolormesh(X, Y, Z1, norm=colors.PowerNorm(gamma=1. / 2.),\n                       cmap='PuBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[0], extend='max')\n\npcm = ax[1].pcolormesh(X, Y, Z1, cmap='PuBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[1], extend='max')\n\n# %%\n# SymLogNorm: two humps, one negative and one positive, The positive\n# with 5-times the amplitude. Linearly, you cannot see detail in the\n# negative hump.  Here we logarithmically scale the positive and\n# negative data separately.\n#\n# Note that colorbar labels do not come out looking very good.\n\nX, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]\nZ = 5 * np.exp(-X**2 - Y**2)\n\nfig, ax = plt.subplots(2, 1)\n\npcm = ax[0].pcolormesh(X, Y, Z,\n                       norm=colors.SymLogNorm(linthresh=0.03, linscale=0.03,\n                                              vmin=-1.0, vmax=1.0, base=10),\n                       cmap='RdBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[0], extend='both')\n\npcm = ax[1].pcolormesh(X, Y, Z, cmap='RdBu_r', vmin=-np.max(Z),\n                       shading='nearest')\nfig.colorbar(pcm, ax=ax[1], extend='both')\n\n# %%\n# Custom Norm: An example with a customized normalization.  This one\n# uses the example above, and normalizes the negative data differently\n# from the positive.\n\nX, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\n# Example of making your own norm.  Also see matplotlib.colors.\n# From Joe Kington: This one gives two different linear ramps:\n\n\nclass MidpointNormalize(colors.Normalize):\n    def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):\n        self.midpoint = midpoint\n        super().__init__(vmin, vmax, clip)\n\n    def __call__(self, value, clip=None):\n        # I'm ignoring masked values and all kinds of edge cases to make a\n        # simple example...\n        x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]\n        return np.ma.masked_array(np.interp(value, x, y))\n\n\n# %%\nfig, ax = plt.subplots(2, 1)\n\npcm = ax[0].pcolormesh(X, Y, Z,\n                       norm=MidpointNormalize(midpoint=0.),\n                       cmap='RdBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[0], extend='both')\n\npcm = ax[1].pcolormesh(X, Y, Z, cmap='RdBu_r', vmin=-np.max(Z),\n                       shading='nearest')\nfig.colorbar(pcm, ax=ax[1], extend='both')\n\n# %%\n# BoundaryNorm: For this one you provide the boundaries for your colors,\n# and the Norm puts the first color in between the first pair, the\n# second color between the second pair, etc.\n\nfig, ax = plt.subplots(3, 1, figsize=(8, 8))\nax = ax.flatten()\n# even bounds gives a contour-like effect\nbounds = np.linspace(-1, 1, 10)\nnorm = colors.BoundaryNorm(boundaries=bounds, ncolors=256)\npcm = ax[0].pcolormesh(X, Y, Z,\n                       norm=norm,\n                       cmap='RdBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[0], extend='both', orientation='vertical')\n\n# uneven bounds changes the colormapping:\nbounds = np.array([-0.25, -0.125, 0, 0.5, 1])\nnorm = colors.BoundaryNorm(boundaries=bounds, ncolors=256)\npcm = ax[1].pcolormesh(X, Y, Z, norm=norm, cmap='RdBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[1], extend='both', orientation='vertical')\n\npcm = ax[2].pcolormesh(X, Y, Z, cmap='RdBu_r', vmin=-np.max(Z1),\n                       shading='nearest')\nfig.colorbar(pcm, ax=ax[2], extend='both', orientation='vertical')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_052_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================================\nColormap normalizations SymLogNorm\n==================================\n\nDemonstration of using norm to map colormaps onto data in non-linear ways.\n\n.. redirect-from:: /gallery/userdemo/colormap_normalization_symlognorm\n\"\"\"\n\n# %%\n# Synthetic dataset consisting of two humps, one negative and one positive,\n# the positive with 8-times the amplitude.\n# Linearly, the negative hump is almost invisible,\n# and it is very difficult to see any detail of its profile.\n# With the logarithmic scaling applied to both positive and negative values,\n# it is much easier to see the shape of each hump.\n#\n# See `~.colors.SymLogNorm`.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors as colors\n\n\ndef rbf(x, y):\n    return 1.0 / (1 + 5 * ((x ** 2) + (y ** 2)))\n\nN = 200\ngain = 8\nX, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]\nZ1 = rbf(X + 0.5, Y + 0.5)\nZ2 = rbf(X - 0.5, Y - 0.5)\nZ = gain * Z1 - Z2\n\nshadeopts = {'cmap': 'PRGn', 'shading': 'gouraud'}\ncolormap = 'PRGn'\nlnrwidth = 0.5\n\nfig, ax = plt.subplots(2, 1, sharex=True, sharey=True)\n\npcm = ax[0].pcolormesh(X, Y, Z,\n                       norm=colors.SymLogNorm(linthresh=lnrwidth, linscale=1,\n                                              vmin=-gain, vmax=gain, base=10),\n                       **shadeopts)\nfig.colorbar(pcm, ax=ax[0], extend='both')\nax[0].text(-2.5, 1.5, 'symlog')\n\npcm = ax[1].pcolormesh(X, Y, Z, vmin=-gain, vmax=gain,\n                       **shadeopts)\nfig.colorbar(pcm, ax=ax[1], extend='both')\nax[1].text(-2.5, 1.5, 'linear')\n\n\n# %%\n# In order to find the best visualization for any particular dataset,\n# it may be necessary to experiment with multiple different color scales.\n# As well as the `~.colors.SymLogNorm` scaling, there is also\n# the option of using `~.colors.AsinhNorm` (experimental), which has a smoother\n# transition between the linear and logarithmic regions of the transformation\n# applied to the data values, \"Z\".\n# In the plots below, it may be possible to see contour-like artifacts\n# around each hump despite there being no sharp features\n# in the dataset itself. The ``asinh`` scaling shows a smoother shading\n# of each hump.\n\nfig, ax = plt.subplots(2, 1, sharex=True, sharey=True)\n\npcm = ax[0].pcolormesh(X, Y, Z,\n                       norm=colors.SymLogNorm(linthresh=lnrwidth, linscale=1,\n                                              vmin=-gain, vmax=gain, base=10),\n                       **shadeopts)\nfig.colorbar(pcm, ax=ax[0], extend='both')\nax[0].text(-2.5, 1.5, 'symlog')\n\npcm = ax[1].pcolormesh(X, Y, Z,\n                       norm=colors.AsinhNorm(linear_width=lnrwidth,\n                                             vmin=-gain, vmax=gain),\n                       **shadeopts)\nfig.colorbar(pcm, ax=ax[1], extend='both')\nax[1].text(-2.5, 1.5, 'asinh')\n\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_053_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===================\nContour Corner Mask\n===================\n\nIllustrate the difference between ``corner_mask=False`` and\n``corner_mask=True`` for masked contour plots.  The default is controlled by\n:rc:`contour.corner_mask`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Data to plot.\nx, y = np.meshgrid(np.arange(7), np.arange(10))\nz = np.sin(0.5 * x) * np.cos(0.52 * y)\n\n# Mask various z values.\nmask = np.zeros_like(z, dtype=bool)\nmask[2, 3:5] = True\nmask[3:5, 4] = True\nmask[7, 2] = True\nmask[5, 0] = True\nmask[0, 6] = True\nz = np.ma.array(z, mask=mask)\n\ncorner_masks = [False, True]\nfig, axs = plt.subplots(ncols=2)\nfor ax, corner_mask in zip(axs, corner_masks):\n    cs = ax.contourf(x, y, z, corner_mask=corner_mask)\n    ax.contour(cs, colors='k')\n    ax.set_title(f'{corner_mask=}')\n\n    # Plot grid.\n    ax.grid(c='k', ls='-', alpha=0.3)\n\n    # Indicate masked points with red circles.\n    ax.plot(np.ma.array(x, mask=~mask), y, 'ro')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.axes.Axes.contourf` / `matplotlib.pyplot.contourf`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_054_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============\nContour Demo\n============\n\nIllustrate simple contour plotting, contours on an image with\na colorbar for the contours, and labelled contours.\n\nSee also the :doc:`contour image example\n</gallery/images_contours_and_fields/contour_image>`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cm as cm\n\ndelta = 0.025\nx = np.arange(-3.0, 3.0, delta)\ny = np.arange(-2.0, 2.0, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\n# %%\n# Create a simple contour plot with labels using default colors.  The inline\n# argument to clabel will control whether the labels are draw over the line\n# segments of the contour, removing the lines beneath the label.\n\nfig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z)\nax.clabel(CS, inline=True, fontsize=10)\nax.set_title('Simplest default with labels')\n\n# %%\n# Contour labels can be placed manually by providing list of positions (in data\n# coordinate).  See :doc:`/gallery/event_handling/ginput_manual_clabel_sgskip`\n# for interactive placement.\n\nfig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z)\nmanual_locations = [\n    (-1, -1.4), (-0.62, -0.7), (-2, 0.5), (1.7, 1.2), (2.0, 1.4), (2.4, 1.7)]\nax.clabel(CS, inline=True, fontsize=10, manual=manual_locations)\nax.set_title('labels at selected locations')\n\n# %%\n# You can force all the contours to be the same color.\n\nfig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z, 6, colors='k')  # Negative contours default to dashed.\nax.clabel(CS, fontsize=9, inline=True)\nax.set_title('Single color - negative contours dashed')\n\n# %%\n# You can set negative contours to be solid instead of dashed:\n\nplt.rcParams['contour.negative_linestyle'] = 'solid'\nfig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z, 6, colors='k')  # Negative contours default to dashed.\nax.clabel(CS, fontsize=9, inline=True)\nax.set_title('Single color - negative contours solid')\n\n# %%\n# And you can manually specify the colors of the contour\n\nfig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z, 6,\n                linewidths=np.arange(.5, 4, .5),\n                colors=('r', 'green', 'blue', (1, 1, 0), '#afeeee', '0.5'),\n                )\nax.clabel(CS, fontsize=9, inline=True)\nax.set_title('Crazy lines')\n\n# %%\n# Or you can use a colormap to specify the colors; the default\n# colormap will be used for the contour lines\n\nfig, ax = plt.subplots()\nim = ax.imshow(Z, interpolation='bilinear', origin='lower',\n               cmap=cm.gray, extent=(-3, 3, -2, 2))\nlevels = np.arange(-1.2, 1.6, 0.2)\nCS = ax.contour(Z, levels, origin='lower', cmap='flag', extend='both',\n                linewidths=2, extent=(-3, 3, -2, 2))\n\n# Thicken the zero contour.\nCS.collections[6].set_linewidth(4)\n\nax.clabel(CS, levels[1::2],  # label every second level\n          inline=True, fmt='%1.1f', fontsize=14)\n\n# make a colorbar for the contour lines\nCB = fig.colorbar(CS, shrink=0.8)\n\nax.set_title('Lines with colorbar')\n\n# We can still add a colorbar for the image, too.\nCBI = fig.colorbar(im, orientation='horizontal', shrink=0.8)\n\n# This makes the original colorbar look a bit out of place,\n# so let's improve its position.\n\nl, b, w, h = ax.get_position().bounds\nll, bb, ww, hh = CB.ax.get_position().bounds\nCB.ax.set_position([ll, b + 0.1*h, ww, h*0.8])\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.axes.Axes.clabel` / `matplotlib.pyplot.clabel`\n#    - `matplotlib.axes.Axes.get_position`\n#    - `matplotlib.axes.Axes.set_position`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_055_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============\nContour Image\n=============\n\nTest combinations of contouring, filled contouring, and image plotting.\nFor contour labelling, see also the :doc:`contour demo example\n</gallery/images_contours_and_fields/contour_demo>`.\n\nThe emphasis in this demo is on showing how to make contours register\ncorrectly on images, and on how to get both of them oriented as desired.\nIn particular, note the usage of the :ref:`\"origin\" and \"extent\"\n<imshow_extent>` keyword arguments to imshow and\ncontour.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\n\n# Default delta is large because that makes it fast, and it illustrates\n# the correct registration between image and contours.\ndelta = 0.5\n\nextent = (-3, 4, -4, 3)\n\nx = np.arange(-3.0, 4.001, delta)\ny = np.arange(-4.0, 3.001, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\n# Boost the upper limit to avoid truncation errors.\nlevels = np.arange(-2.0, 1.601, 0.4)\n\nnorm = cm.colors.Normalize(vmax=abs(Z).max(), vmin=-abs(Z).max())\ncmap = cm.PRGn\n\nfig, _axs = plt.subplots(nrows=2, ncols=2)\nfig.subplots_adjust(hspace=0.3)\naxs = _axs.flatten()\n\ncset1 = axs[0].contourf(X, Y, Z, levels, norm=norm,\n                        cmap=cmap.resampled(len(levels) - 1))\n# It is not necessary, but for the colormap, we need only the\n# number of levels minus 1.  To avoid discretization error, use\n# either this number or a large number such as the default (256).\n\n# If we want lines as well as filled regions, we need to call\n# contour separately; don't try to change the edgecolor or edgewidth\n# of the polygons in the collections returned by contourf.\n# Use levels output from previous call to guarantee they are the same.\n\ncset2 = axs[0].contour(X, Y, Z, cset1.levels, colors='k')\n\n# We don't really need dashed contour lines to indicate negative\n# regions, so let's turn them off.\n\nfor c in cset2.collections:\n    c.set_linestyle('solid')\n\n# It is easier here to make a separate call to contour than\n# to set up an array of colors and linewidths.\n# We are making a thick green line as a zero contour.\n# Specify the zero level as a tuple with only 0 in it.\n\ncset3 = axs[0].contour(X, Y, Z, (0,), colors='g', linewidths=2)\naxs[0].set_title('Filled contours')\nfig.colorbar(cset1, ax=axs[0])\n\n\naxs[1].imshow(Z, extent=extent, cmap=cmap, norm=norm)\naxs[1].contour(Z, levels, colors='k', origin='upper', extent=extent)\naxs[1].set_title(\"Image, origin 'upper'\")\n\naxs[2].imshow(Z, origin='lower', extent=extent, cmap=cmap, norm=norm)\naxs[2].contour(Z, levels, colors='k', origin='lower', extent=extent)\naxs[2].set_title(\"Image, origin 'lower'\")\n\n# We will use the interpolation \"nearest\" here to show the actual\n# image pixels.\n# Note that the contour lines don't extend to the edge of the box.\n# This is intentional. The Z values are defined at the center of each\n# image pixel (each color block on the following subplot), so the\n# domain that is contoured does not extend beyond these pixel centers.\nim = axs[3].imshow(Z, interpolation='nearest', extent=extent,\n                   cmap=cmap, norm=norm)\naxs[3].contour(Z, levels, colors='k', origin='image', extent=extent)\nylim = axs[3].get_ylim()\naxs[3].set_ylim(ylim[::-1])\naxs[3].set_title(\"Origin from rc, reversed y-axis\")\nfig.colorbar(im, ax=axs[3])\n\nfig.tight_layout()\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.colors.Normalize`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_056_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================\nContour Label Demo\n==================\n\nIllustrate some of the more advanced things that one can do with\ncontour labels.\n\nSee also the :doc:`contour demo example\n</gallery/images_contours_and_fields/contour_demo>`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as ticker\n\n# %%\n# Define our surface\n\ndelta = 0.025\nx = np.arange(-3.0, 3.0, delta)\ny = np.arange(-2.0, 2.0, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\n# %%\n# Make contour labels with custom level formatters\n\n\n# This custom formatter removes trailing zeros, e.g. \"1.0\" becomes \"1\", and\n# then adds a percent sign.\ndef fmt(x):\n    s = f\"{x:.1f}\"\n    if s.endswith(\"0\"):\n        s = f\"{x:.0f}\"\n    return rf\"{s} \\%\" if plt.rcParams[\"text.usetex\"] else f\"{s} %\"\n\n\n# Basic contour plot\nfig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z)\n\nax.clabel(CS, CS.levels, inline=True, fmt=fmt, fontsize=10)\n\n# %%\n# Label contours with arbitrary strings using a dictionary\n\nfig1, ax1 = plt.subplots()\n\n# Basic contour plot\nCS1 = ax1.contour(X, Y, Z)\n\nfmt = {}\nstrs = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh']\nfor l, s in zip(CS1.levels, strs):\n    fmt[l] = s\n\n# Label every other level using strings\nax1.clabel(CS1, CS1.levels[::2], inline=True, fmt=fmt, fontsize=10)\n\n# %%\n# Use a Formatter\n\nfig2, ax2 = plt.subplots()\n\nCS2 = ax2.contour(X, Y, 100**Z, locator=plt.LogLocator())\nfmt = ticker.LogFormatterMathtext()\nfmt.create_dummy_axis()\nax2.clabel(CS2, CS2.levels, fmt=fmt)\nax2.set_title(\"$100^Z$\")\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.axes.Axes.clabel` / `matplotlib.pyplot.clabel`\n#    - `matplotlib.ticker.LogFormatterMathtext`\n#    - `matplotlib.ticker.TickHelper.create_dummy_axis`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_057_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============\nContourf demo\n=============\n\nHow to use the `.axes.Axes.contourf` method to create filled contour plots.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\norigin = 'lower'\n\ndelta = 0.025\n\nx = y = np.arange(-3.0, 3.01, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\nnr, nc = Z.shape\n\n# put NaNs in one corner:\nZ[-nr // 6:, -nc // 6:] = np.nan\n# contourf will convert these to masked\n\n\nZ = np.ma.array(Z)\n# mask another corner:\nZ[:nr // 6, :nc // 6] = np.ma.masked\n\n# mask a circle in the middle:\ninterior = np.sqrt(X**2 + Y**2) < 0.5\nZ[interior] = np.ma.masked\n\n# %%\n# Automatic contour levels\n# ------------------------\n# We are using automatic selection of contour levels; this is usually not such\n# a good idea, because they don't occur on nice boundaries, but we do it here\n# for purposes of illustration.\n\nfig1, ax2 = plt.subplots(layout='constrained')\nCS = ax2.contourf(X, Y, Z, 10, cmap=plt.cm.bone, origin=origin)\n\n# Note that in the following, we explicitly pass in a subset of the contour\n# levels used for the filled contours.  Alternatively, we could pass in\n# additional levels to provide extra resolution, or leave out the *levels*\n# keyword argument to use all of the original levels.\n\nCS2 = ax2.contour(CS, levels=CS.levels[::2], colors='r', origin=origin)\n\nax2.set_title('Nonsense (3 masked regions)')\nax2.set_xlabel('word length anomaly')\nax2.set_ylabel('sentence length anomaly')\n\n# Make a colorbar for the ContourSet returned by the contourf call.\ncbar = fig1.colorbar(CS)\ncbar.ax.set_ylabel('verbosity coefficient')\n# Add the contour line levels to the colorbar\ncbar.add_lines(CS2)\n\n# %%\n# Explicit contour levels\n# -----------------------\n# Now make a contour plot with the levels specified, and with the colormap\n# generated automatically from a list of colors.\n\nfig2, ax2 = plt.subplots(layout='constrained')\nlevels = [-1.5, -1, -0.5, 0, 0.5, 1]\nCS3 = ax2.contourf(X, Y, Z, levels,\n                   colors=('r', 'g', 'b'),\n                   origin=origin,\n                   extend='both')\n# Our data range extends outside the range of levels; make\n# data below the lowest contour level yellow, and above the\n# highest level cyan:\nCS3.cmap.set_under('yellow')\nCS3.cmap.set_over('cyan')\n\nCS4 = ax2.contour(X, Y, Z, levels,\n                  colors=('k',),\n                  linewidths=(3,),\n                  origin=origin)\nax2.set_title('Listed colors (3 masked regions)')\nax2.clabel(CS4, fmt='%2.1f', colors='w', fontsize=14)\n\n# Notice that the colorbar gets all the information it\n# needs from the ContourSet object, CS3.\nfig2.colorbar(CS3)\n\n# %%\n# Extension settings\n# ------------------\n# Illustrate all 4 possible \"extend\" settings:\nextends = [\"neither\", \"both\", \"min\", \"max\"]\ncmap = plt.colormaps[\"winter\"].with_extremes(under=\"magenta\", over=\"yellow\")\n# Note: contouring simply excludes masked or nan regions, so\n# instead of using the \"bad\" colormap value for them, it draws\n# nothing at all in them.  Therefore, the following would have\n# no effect:\n# cmap.set_bad(\"red\")\n\nfig, axs = plt.subplots(2, 2, layout=\"constrained\")\n\nfor ax, extend in zip(axs.flat, extends):\n    cs = ax.contourf(X, Y, Z, levels, cmap=cmap, extend=extend, origin=origin)\n    fig.colorbar(cs, ax=ax, shrink=0.9)\n    ax.set_title(\"extend = %s\" % extend)\n    ax.locator_params(nbins=4)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.axes.Axes.contourf` / `matplotlib.pyplot.contourf`\n#    - `matplotlib.axes.Axes.clabel` / `matplotlib.pyplot.clabel`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.colors.Colormap`\n#    - `matplotlib.colors.Colormap.set_bad`\n#    - `matplotlib.colors.Colormap.set_under`\n#    - `matplotlib.colors.Colormap.set_over`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_058_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================\nContourf Hatching\n=================\n\nDemo filled contour plots with hatched patterns.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# invent some numbers, turning the x and y arrays into simple\n# 2d arrays, which make combining them together easier.\nx = np.linspace(-3, 5, 150).reshape(1, -1)\ny = np.linspace(-3, 5, 120).reshape(-1, 1)\nz = np.cos(x) + np.sin(y)\n\n# we no longer need x and y to be 2 dimensional, so flatten them.\nx, y = x.flatten(), y.flatten()\n\n# %%\n# Plot 1: the simplest hatched plot with a colorbar\n\nfig1, ax1 = plt.subplots()\ncs = ax1.contourf(x, y, z, hatches=['-', '/', '\\\\', '//'],\n                  cmap='gray', extend='both', alpha=0.5)\nfig1.colorbar(cs)\n\n# %%\n# Plot 2: a plot of hatches without color with a legend\n\nfig2, ax2 = plt.subplots()\nn_levels = 6\nax2.contour(x, y, z, n_levels, colors='black', linestyles='-')\ncs = ax2.contourf(x, y, z, n_levels, colors='none',\n                  hatches=['.', '/', '\\\\', None, '\\\\\\\\', '*'],\n                  extend='lower')\n\n# create a legend for the contour set\nartists, labels = cs.legend_elements(str_format='{:2.1f}'.format)\nax2.legend(artists, labels, handleheight=2, framealpha=1)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.axes.Axes.contourf` / `matplotlib.pyplot.contourf`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.axes.Axes.legend` / `matplotlib.pyplot.legend`\n#    - `matplotlib.contour.ContourSet`\n#    - `matplotlib.contour.ContourSet.legend_elements`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_059_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============================\nContourf and log color scale\n============================\n\nDemonstrate use of a log color scale in contourf\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy import ma\n\nfrom matplotlib import cm, ticker\n\nN = 100\nx = np.linspace(-3.0, 3.0, N)\ny = np.linspace(-2.0, 2.0, N)\n\nX, Y = np.meshgrid(x, y)\n\n# A low hump with a spike coming out.\n# Needs to have z/colour axis on a log scale, so we see both hump and spike.\n# A linear scale only shows the spike.\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X * 10)**2 - (Y * 10)**2)\nz = Z1 + 50 * Z2\n\n# Put in some negative values (lower left corner) to cause trouble with logs:\nz[:5, :5] = -1\n\n# The following is not strictly essential, but it will eliminate\n# a warning.  Comment it out to see the warning.\nz = ma.masked_where(z <= 0, z)\n\n\n# Automatic selection of levels works; setting the\n# log locator tells contourf to use a log scale:\nfig, ax = plt.subplots()\ncs = ax.contourf(X, Y, z, locator=ticker.LogLocator(), cmap=cm.PuBu_r)\n\n# Alternatively, you can manually set the levels\n# and the norm:\n# lev_exp = np.arange(np.floor(np.log10(z.min())-1),\n#                    np.ceil(np.log10(z.max())+1))\n# levs = np.power(10, lev_exp)\n# cs = ax.contourf(X, Y, z, levs, norm=colors.LogNorm())\n\ncbar = fig.colorbar(cs)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contourf` / `matplotlib.pyplot.contourf`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.axes.Axes.legend` / `matplotlib.pyplot.legend`\n#    - `matplotlib.ticker.LogLocator`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_060_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============================================\nContouring the solution space of optimizations\n==============================================\n\nContour plotting is particularly handy when illustrating the solution\nspace of optimization problems.  Not only can `.axes.Axes.contour` be\nused to represent the topography of the objective function, it can be\nused to generate boundary curves of the constraint functions.  The\nconstraint lines can be drawn with\n`~matplotlib.patheffects.TickedStroke` to distinguish the valid and\ninvalid sides of the constraint boundaries.\n\n`.axes.Axes.contour` generates curves with larger values to the left\nof the contour.  The angle parameter is measured zero ahead with\nincreasing values to the left.  Consequently, when using\n`~matplotlib.patheffects.TickedStroke` to illustrate a constraint in\na typical optimization problem, the angle should be set between\nzero and 180 degrees.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import patheffects\n\nfig, ax = plt.subplots(figsize=(6, 6))\n\nnx = 101\nny = 105\n\n# Set up survey vectors\nxvec = np.linspace(0.001, 4.0, nx)\nyvec = np.linspace(0.001, 4.0, ny)\n\n# Set up survey matrices.  Design disk loading and gear ratio.\nx1, x2 = np.meshgrid(xvec, yvec)\n\n# Evaluate some stuff to plot\nobj = x1**2 + x2**2 - 2*x1 - 2*x2 + 2\ng1 = -(3*x1 + x2 - 5.5)\ng2 = -(x1 + 2*x2 - 4.5)\ng3 = 0.8 + x1**-3 - x2\n\ncntr = ax.contour(x1, x2, obj, [0.01, 0.1, 0.5, 1, 2, 4, 8, 16],\n                  colors='black')\nax.clabel(cntr, fmt=\"%2.1f\", use_clabeltext=True)\n\ncg1 = ax.contour(x1, x2, g1, [0], colors='sandybrown')\nplt.setp(cg1.collections,\n         path_effects=[patheffects.withTickedStroke(angle=135)])\n\ncg2 = ax.contour(x1, x2, g2, [0], colors='orangered')\nplt.setp(cg2.collections,\n         path_effects=[patheffects.withTickedStroke(angle=60, length=2)])\n\ncg3 = ax.contour(x1, x2, g3, [0], colors='mediumblue')\nplt.setp(cg3.collections,\n         path_effects=[patheffects.withTickedStroke(spacing=7)])\n\nax.set_xlim(0, 4)\nax.set_ylim(0, 4)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_061_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============\nBboxImage Demo\n==============\n\nA `~matplotlib.image.BboxImage` can be used to position an image according to\na bounding box. This demo shows how to show an image inside a `.text.Text`'s\nbounding box as well as how to manually create a bounding box for the image.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.image import BboxImage\nfrom matplotlib.transforms import Bbox, TransformedBbox\n\nfig, (ax1, ax2) = plt.subplots(ncols=2)\n\n# ----------------------------\n# Create a BboxImage with Text\n# ----------------------------\ntxt = ax1.text(0.5, 0.5, \"test\", size=30, ha=\"center\", color=\"w\")\nax1.add_artist(\n    BboxImage(txt.get_window_extent, data=np.arange(256).reshape((1, -1))))\n\n# ------------------------------------\n# Create a BboxImage for each colormap\n# ------------------------------------\n# List of all colormaps; skip reversed colormaps.\ncmap_names = sorted(m for m in plt.colormaps if not m.endswith(\"_r\"))\n\nncol = 2\nnrow = len(cmap_names) // ncol + 1\n\nxpad_fraction = 0.3\ndx = 1 / (ncol + xpad_fraction * (ncol - 1))\n\nypad_fraction = 0.3\ndy = 1 / (nrow + ypad_fraction * (nrow - 1))\n\nfor i, cmap_name in enumerate(cmap_names):\n    ix, iy = divmod(i, nrow)\n    bbox0 = Bbox.from_bounds(ix*dx*(1+xpad_fraction),\n                             1 - iy*dy*(1+ypad_fraction) - dy,\n                             dx, dy)\n    bbox = TransformedBbox(bbox0, ax2.transAxes)\n    ax2.add_artist(\n        BboxImage(bbox, cmap=cmap_name, data=np.arange(256).reshape((1, -1))))\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.image.BboxImage`\n#    - `matplotlib.transforms.Bbox`\n#    - `matplotlib.transforms.TransformedBbox`\n#    - `matplotlib.text.Text`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_062_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============\nFigimage Demo\n=============\n\nThis illustrates placing images directly in the figure, with no Axes objects.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nZ = np.arange(10000).reshape((100, 100))\nZ[:, 50:] = 1\n\nim1 = fig.figimage(Z, xo=50, yo=0, origin='lower')\nim2 = fig.figimage(Z, xo=100, yo=100, alpha=.8, origin='lower')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.figure.Figure`\n#    - `matplotlib.figure.Figure.figimage` / `matplotlib.pyplot.figimage`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_063_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========================\nCreating annotated heatmaps\n===========================\n\nIt is often desirable to show data which depends on two independent\nvariables as a color coded image plot. This is often referred to as a\nheatmap. If the data is categorical, this would be called a categorical\nheatmap.\n\nMatplotlib's `~matplotlib.axes.Axes.imshow` function makes\nproduction of such plots particularly easy.\n\nThe following examples show how to create a heatmap with annotations.\nWe will start with an easy example and expand it to be usable as a\nuniversal function.\n\"\"\"\n\n\n# %%\n#\n# A simple categorical heatmap\n# ----------------------------\n#\n# We may start by defining some data. What we need is a 2D list or array\n# which defines the data to color code. We then also need two lists or arrays\n# of categories; of course the number of elements in those lists\n# need to match the data along the respective axes.\n# The heatmap itself is an `~matplotlib.axes.Axes.imshow` plot\n# with the labels set to the categories we have.\n# Note that it is important to set both, the tick locations\n# (`~matplotlib.axes.Axes.set_xticks`) as well as the\n# tick labels (`~matplotlib.axes.Axes.set_xticklabels`),\n# otherwise they would become out of sync. The locations are just\n# the ascending integer numbers, while the ticklabels are the labels to show.\n# Finally, we can label the data itself by creating a `~matplotlib.text.Text`\n# within each cell showing the value of that cell.\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib\nimport matplotlib as mpl\n\n# sphinx_gallery_thumbnail_number = 2\n\nvegetables = [\"cucumber\", \"tomato\", \"lettuce\", \"asparagus\",\n              \"potato\", \"wheat\", \"barley\"]\nfarmers = [\"Farmer Joe\", \"Upland Bros.\", \"Smith Gardening\",\n           \"Agrifun\", \"Organiculture\", \"BioGoods Ltd.\", \"Cornylee Corp.\"]\n\nharvest = np.array([[0.8, 2.4, 2.5, 3.9, 0.0, 4.0, 0.0],\n                    [2.4, 0.0, 4.0, 1.0, 2.7, 0.0, 0.0],\n                    [1.1, 2.4, 0.8, 4.3, 1.9, 4.4, 0.0],\n                    [0.6, 0.0, 0.3, 0.0, 3.1, 0.0, 0.0],\n                    [0.7, 1.7, 0.6, 2.6, 2.2, 6.2, 0.0],\n                    [1.3, 1.2, 0.0, 0.0, 0.0, 3.2, 5.1],\n                    [0.1, 2.0, 0.0, 1.4, 0.0, 1.9, 6.3]])\n\n\nfig, ax = plt.subplots()\nim = ax.imshow(harvest)\n\n# Show all ticks and label them with the respective list entries\nax.set_xticks(np.arange(len(farmers)), labels=farmers)\nax.set_yticks(np.arange(len(vegetables)), labels=vegetables)\n\n# Rotate the tick labels and set their alignment.\nplt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\",\n         rotation_mode=\"anchor\")\n\n# Loop over data dimensions and create text annotations.\nfor i in range(len(vegetables)):\n    for j in range(len(farmers)):\n        text = ax.text(j, i, harvest[i, j],\n                       ha=\"center\", va=\"center\", color=\"w\")\n\nax.set_title(\"Harvest of local farmers (in tons/year)\")\nfig.tight_layout()\nplt.show()\n\n\n# %%\n# Using the helper function code style\n# ------------------------------------\n#\n# As discussed in the :ref:`Coding styles <coding_styles>`\n# one might want to reuse such code to create some kind of heatmap\n# for different input data and/or on different axes.\n# We create a function that takes the data and the row and column labels as\n# input, and allows arguments that are used to customize the plot\n#\n# Here, in addition to the above we also want to create a colorbar and\n# position the labels above of the heatmap instead of below it.\n# The annotations shall get different colors depending on a threshold\n# for better contrast against the pixel color.\n# Finally, we turn the surrounding axes spines off and create\n# a grid of white lines to separate the cells.\n\n\ndef heatmap(data, row_labels, col_labels, ax=None,\n            cbar_kw=None, cbarlabel=\"\", **kwargs):\n    \"\"\"\n    Create a heatmap from a numpy array and two lists of labels.\n\n    Parameters\n    ----------\n    data\n        A 2D numpy array of shape (M, N).\n    row_labels\n        A list or array of length M with the labels for the rows.\n    col_labels\n        A list or array of length N with the labels for the columns.\n    ax\n        A `matplotlib.axes.Axes` instance to which the heatmap is plotted.  If\n        not provided, use current axes or create a new one.  Optional.\n    cbar_kw\n        A dictionary with arguments to `matplotlib.Figure.colorbar`.  Optional.\n    cbarlabel\n        The label for the colorbar.  Optional.\n    **kwargs\n        All other arguments are forwarded to `imshow`.\n    \"\"\"\n\n    if ax is None:\n        ax = plt.gca()\n\n    if cbar_kw is None:\n        cbar_kw = {}\n\n    # Plot the heatmap\n    im = ax.imshow(data, **kwargs)\n\n    # Create colorbar\n    cbar = ax.figure.colorbar(im, ax=ax, **cbar_kw)\n    cbar.ax.set_ylabel(cbarlabel, rotation=-90, va=\"bottom\")\n\n    # Show all ticks and label them with the respective list entries.\n    ax.set_xticks(np.arange(data.shape[1]), labels=col_labels)\n    ax.set_yticks(np.arange(data.shape[0]), labels=row_labels)\n\n    # Let the horizontal axes labeling appear on top.\n    ax.tick_params(top=True, bottom=False,\n                   labeltop=True, labelbottom=False)\n\n    # Rotate the tick labels and set their alignment.\n    plt.setp(ax.get_xticklabels(), rotation=-30, ha=\"right\",\n             rotation_mode=\"anchor\")\n\n    # Turn spines off and create white grid.\n    ax.spines[:].set_visible(False)\n\n    ax.set_xticks(np.arange(data.shape[1]+1)-.5, minor=True)\n    ax.set_yticks(np.arange(data.shape[0]+1)-.5, minor=True)\n    ax.grid(which=\"minor\", color=\"w\", linestyle='-', linewidth=3)\n    ax.tick_params(which=\"minor\", bottom=False, left=False)\n\n    return im, cbar\n\n\ndef annotate_heatmap(im, data=None, valfmt=\"{x:.2f}\",\n                     textcolors=(\"black\", \"white\"),\n                     threshold=None, **textkw):\n    \"\"\"\n    A function to annotate a heatmap.\n\n    Parameters\n    ----------\n    im\n        The AxesImage to be labeled.\n    data\n        Data used to annotate.  If None, the image's data is used.  Optional.\n    valfmt\n        The format of the annotations inside the heatmap.  This should either\n        use the string format method, e.g. \"$ {x:.2f}\", or be a\n        `matplotlib.ticker.Formatter`.  Optional.\n    textcolors\n        A pair of colors.  The first is used for values below a threshold,\n        the second for those above.  Optional.\n    threshold\n        Value in data units according to which the colors from textcolors are\n        applied.  If None (the default) uses the middle of the colormap as\n        separation.  Optional.\n    **kwargs\n        All other arguments are forwarded to each call to `text` used to create\n        the text labels.\n    \"\"\"\n\n    if not isinstance(data, (list, np.ndarray)):\n        data = im.get_array()\n\n    # Normalize the threshold to the images color range.\n    if threshold is not None:\n        threshold = im.norm(threshold)\n    else:\n        threshold = im.norm(data.max())/2.\n\n    # Set default alignment to center, but allow it to be\n    # overwritten by textkw.\n    kw = dict(horizontalalignment=\"center\",\n              verticalalignment=\"center\")\n    kw.update(textkw)\n\n    # Get the formatter in case a string is supplied\n    if isinstance(valfmt, str):\n        valfmt = matplotlib.ticker.StrMethodFormatter(valfmt)\n\n    # Loop over the data and create a `Text` for each \"pixel\".\n    # Change the text's color depending on the data.\n    texts = []\n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            kw.update(color=textcolors[int(im.norm(data[i, j]) > threshold)])\n            text = im.axes.text(j, i, valfmt(data[i, j], None), **kw)\n            texts.append(text)\n\n    return texts\n\n\n# %%\n# The above now allows us to keep the actual plot creation pretty compact.\n#\n\nfig, ax = plt.subplots()\n\nim, cbar = heatmap(harvest, vegetables, farmers, ax=ax,\n                   cmap=\"YlGn\", cbarlabel=\"harvest [t/year]\")\ntexts = annotate_heatmap(im, valfmt=\"{x:.1f} t\")\n\nfig.tight_layout()\nplt.show()\n\n\n# %%\n# Some more complex heatmap examples\n# ----------------------------------\n#\n# In the following we show the versatility of the previously created\n# functions by applying it in different cases and using different arguments.\n#\n\nnp.random.seed(19680801)\n\nfig, ((ax, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(8, 6))\n\n# Replicate the above example with a different font size and colormap.\n\nim, _ = heatmap(harvest, vegetables, farmers, ax=ax,\n                cmap=\"Wistia\", cbarlabel=\"harvest [t/year]\")\nannotate_heatmap(im, valfmt=\"{x:.1f}\", size=7)\n\n# Create some new data, give further arguments to imshow (vmin),\n# use an integer format on the annotations and provide some colors.\n\ndata = np.random.randint(2, 100, size=(7, 7))\ny = [f\"Book {i}\" for i in range(1, 8)]\nx = [f\"Store {i}\" for i in list(\"ABCDEFG\")]\nim, _ = heatmap(data, y, x, ax=ax2, vmin=0,\n                cmap=\"magma_r\", cbarlabel=\"weekly sold copies\")\nannotate_heatmap(im, valfmt=\"{x:d}\", size=7, threshold=20,\n                 textcolors=(\"red\", \"white\"))\n\n# Sometimes even the data itself is categorical. Here we use a\n# `matplotlib.colors.BoundaryNorm` to get the data into classes\n# and use this to colorize the plot, but also to obtain the class\n# labels from an array of classes.\n\ndata = np.random.randn(6, 6)\ny = [f\"Prod. {i}\" for i in range(10, 70, 10)]\nx = [f\"Cycle {i}\" for i in range(1, 7)]\n\nqrates = list(\"ABCDEFG\")\nnorm = matplotlib.colors.BoundaryNorm(np.linspace(-3.5, 3.5, 8), 7)\nfmt = matplotlib.ticker.FuncFormatter(lambda x, pos: qrates[::-1][norm(x)])\n\nim, _ = heatmap(data, y, x, ax=ax3,\n                cmap=mpl.colormaps[\"PiYG\"].resampled(7), norm=norm,\n                cbar_kw=dict(ticks=np.arange(-3, 4), format=fmt),\n                cbarlabel=\"Quality Rating\")\n\nannotate_heatmap(im, valfmt=fmt, size=9, fontweight=\"bold\", threshold=-1,\n                 textcolors=(\"red\", \"black\"))\n\n# We can nicely plot a correlation matrix. Since this is bound by -1 and 1,\n# we use those as vmin and vmax. We may also remove leading zeros and hide\n# the diagonal elements (which are all 1) by using a\n# `matplotlib.ticker.FuncFormatter`.\n\ncorr_matrix = np.corrcoef(harvest)\nim, _ = heatmap(corr_matrix, vegetables, vegetables, ax=ax4,\n                cmap=\"PuOr\", vmin=-1, vmax=1,\n                cbarlabel=\"correlation coeff.\")\n\n\ndef func(x, pos):\n    return f\"{x:.2f}\".replace(\"0.\", \".\").replace(\"1.00\", \"\")\n\nannotate_heatmap(im, valfmt=matplotlib.ticker.FuncFormatter(func), size=7)\n\n\nplt.tight_layout()\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_064_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================\nImage antialiasing\n==================\n\nImages are represented by discrete pixels, either on the screen or in an\nimage file.  When data that makes up the image has a different resolution\nthan its representation on the screen we will see aliasing effects.  How\nnoticeable these are depends on how much down-sampling takes place in\nthe change of resolution (if any).\n\nWhen subsampling data, aliasing is reduced by smoothing first and then\nsubsampling the smoothed data.  In Matplotlib, we can do that\nsmoothing before mapping the data to colors, or we can do the smoothing\non the RGB(A) data in the final image.  The differences between these are\nshown below, and controlled with the *interpolation_stage* keyword argument.\n\nThe default image interpolation in Matplotlib is 'antialiased', and\nit is applied to the data.  This uses a\nhanning interpolation on the data provided by the user for reduced aliasing\nin most situations. Only when there is upsampling by a factor of 1, 2 or\n>=3 is 'nearest' neighbor interpolation used.\n\nOther anti-aliasing filters can be specified in `.Axes.imshow` using the\n*interpolation* keyword argument.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# %%\n# First we generate a 450x450 pixel image with varying frequency content:\nN = 450\nx = np.arange(N) / N - 0.5\ny = np.arange(N) / N - 0.5\naa = np.ones((N, N))\naa[::2, :] = -1\n\nX, Y = np.meshgrid(x, y)\nR = np.sqrt(X**2 + Y**2)\nf0 = 5\nk = 100\na = np.sin(np.pi * 2 * (f0 * R + k * R**2 / 2))\n# make the left hand side of this\na[:int(N / 2), :][R[:int(N / 2), :] < 0.4] = -1\na[:int(N / 2), :][R[:int(N / 2), :] < 0.3] = 1\naa[:, int(N / 3):] = a[:, int(N / 3):]\na = aa\n# %%\n# The following images are subsampled from 450 data pixels to either\n# 125 pixels or 250 pixels (depending on your display).\n# The Moir\u00e9 patterns in the 'nearest' interpolation are caused by the\n# high-frequency data being subsampled.  The 'antialiased' imaged\n# still has some Moir\u00e9 patterns as well, but they are greatly reduced.\n#\n# There are substantial differences between the 'data' interpolation and\n# the 'rgba' interpolation.  The alternating bands of red and blue on the\n# left third of the image are subsampled.  By interpolating in 'data' space\n# (the default) the antialiasing filter makes the stripes close to white,\n# because the average of -1 and +1 is zero, and zero is white in this\n# colormap.\n#\n# Conversely, when the anti-aliasing occurs in 'rgba' space, the red and\n# blue are combined visually to make purple.  This behaviour is more like a\n# typical image processing package, but note that purple is not in the\n# original colormap, so it is no longer possible to invert individual\n# pixels back to their data value.\n\nfig, axs = plt.subplots(2, 2, figsize=(5, 6), layout='constrained')\naxs[0, 0].imshow(a, interpolation='nearest', cmap='RdBu_r')\naxs[0, 0].set_xlim(100, 200)\naxs[0, 0].set_ylim(275, 175)\naxs[0, 0].set_title('Zoom')\n\nfor ax, interp, space in zip(axs.flat[1:],\n                             ['nearest', 'antialiased', 'antialiased'],\n                             ['data', 'data', 'rgba']):\n    ax.imshow(a, interpolation=interp, interpolation_stage=space,\n              cmap='RdBu_r')\n    ax.set_title(f\"interpolation='{interp}'\\nspace='{space}'\")\nplt.show()\n\n# %%\n# Even up-sampling an image with 'nearest' interpolation will lead to Moir\u00e9\n# patterns when the upsampling factor is not integer. The following image\n# upsamples 500 data pixels to 530 rendered pixels. You may note a grid of\n# 30 line-like artifacts which stem from the 524 - 500 = 24 extra pixels that\n# had to be made up. Since interpolation is 'nearest' they are the same as a\n# neighboring line of pixels and thus stretch the image locally so that it\n# looks distorted.\nfig, ax = plt.subplots(figsize=(6.8, 6.8))\nax.imshow(a, interpolation='nearest', cmap='gray')\nax.set_title(\"upsampled by factor a 1.048, interpolation='nearest'\")\nplt.show()\n\n# %%\n# Better antialiasing algorithms can reduce this effect:\nfig, ax = plt.subplots(figsize=(6.8, 6.8))\nax.imshow(a, interpolation='antialiased', cmap='gray')\nax.set_title(\"upsampled by factor a 1.048, interpolation='antialiased'\")\nplt.show()\n\n# %%\n# Apart from the default 'hanning' antialiasing, `~.Axes.imshow` supports a\n# number of different interpolation algorithms, which may work better or\n# worse depending on the pattern.\nfig, axs = plt.subplots(1, 2, figsize=(7, 4), layout='constrained')\nfor ax, interp in zip(axs, ['hanning', 'lanczos']):\n    ax.imshow(a, interpolation=interp, cmap='gray')\n    ax.set_title(f\"interpolation='{interp}'\")\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_065_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============\nImage Masked\n============\n\nimshow with masked array input and out-of-range colors.\n\nThe second subplot illustrates the use of BoundaryNorm to\nget a filled contour effect.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors as colors\n\n# compute some interesting data\nx0, x1 = -5, 5\ny0, y1 = -3, 3\nx = np.linspace(x0, x1, 500)\ny = np.linspace(y0, y1, 500)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\n# Set up a colormap:\npalette = plt.cm.gray.with_extremes(over='r', under='g', bad='b')\n# Alternatively, we could use\n# palette.set_bad(alpha = 0.0)\n# to make the bad region transparent.  This is the default.\n# If you comment out all the palette.set* lines, you will see\n# all the defaults; under and over will be colored with the\n# first and last colors in the palette, respectively.\nZm = np.ma.masked_where(Z > 1.2, Z)\n\n# By setting vmin and vmax in the norm, we establish the\n# range to which the regular palette color scale is applied.\n# Anything above that range is colored based on palette.set_over, etc.\n\n# set up the Axes objects\nfig, (ax1, ax2) = plt.subplots(nrows=2, figsize=(6, 5.4))\n\n# plot using 'continuous' colormap\nim = ax1.imshow(Zm, interpolation='bilinear',\n                cmap=palette,\n                norm=colors.Normalize(vmin=-1.0, vmax=1.0),\n                aspect='auto',\n                origin='lower',\n                extent=[x0, x1, y0, y1])\nax1.set_title('Green=low, Red=high, Blue=masked')\ncbar = fig.colorbar(im, extend='both', shrink=0.9, ax=ax1)\ncbar.set_label('uniform')\nax1.tick_params(axis='x', labelbottom=False)\n\n# Plot using a small number of colors, with unevenly spaced boundaries.\nim = ax2.imshow(Zm, interpolation='nearest',\n                cmap=palette,\n                norm=colors.BoundaryNorm([-1, -0.5, -0.2, 0, 0.2, 0.5, 1],\n                                         ncolors=palette.N),\n                aspect='auto',\n                origin='lower',\n                extent=[x0, x1, y0, y1])\nax2.set_title('With BoundaryNorm')\ncbar = fig.colorbar(im, extend='both', spacing='proportional',\n                    shrink=0.9, ax=ax2)\ncbar.set_label('proportional')\n\nfig.suptitle('imshow, with out-of-range and masked data')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.colors.BoundaryNorm`\n#    - `matplotlib.colorbar.Colorbar.set_label`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_066_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nImage nonuniform\n================\n\nThis illustrates the NonUniformImage class.  It is not\navailable via an Axes method, but it is easily added to an\nAxes instance as shown here.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\nfrom matplotlib.image import NonUniformImage\n\ninterp = 'nearest'\n\n# Linear x array for cell centers:\nx = np.linspace(-4, 4, 9)\n\n# Highly nonlinear x array:\nx2 = x**3\n\ny = np.linspace(-4, 4, 9)\n\nz = np.sqrt(x[np.newaxis, :]**2 + y[:, np.newaxis]**2)\n\nfig, axs = plt.subplots(nrows=2, ncols=2, layout='constrained')\nfig.suptitle('NonUniformImage class', fontsize='large')\nax = axs[0, 0]\nim = NonUniformImage(ax, interpolation=interp, extent=(-4, 4, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x, y, z)\nax.add_image(im)\nax.set_xlim(-4, 4)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\nax = axs[0, 1]\nim = NonUniformImage(ax, interpolation=interp, extent=(-64, 64, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x2, y, z)\nax.add_image(im)\nax.set_xlim(-64, 64)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\ninterp = 'bilinear'\n\nax = axs[1, 0]\nim = NonUniformImage(ax, interpolation=interp, extent=(-4, 4, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x, y, z)\nax.add_image(im)\nax.set_xlim(-4, 4)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\nax = axs[1, 1]\nim = NonUniformImage(ax, interpolation=interp, extent=(-64, 64, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x2, y, z)\nax.add_image(im)\nax.set_xlim(-64, 64)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_067_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========================================\nBlend transparency with color in 2D images\n==========================================\n\nBlend transparency with color to highlight parts of data with imshow.\n\nA common use for `matplotlib.pyplot.imshow` is to plot a 2D statistical\nmap. The function makes it easy to visualize a 2D matrix as an image and add\ntransparency to the output. For example, one can plot a statistic (such as a\nt-statistic) and color the transparency of each pixel according to its p-value.\nThis example demonstrates how you can achieve this effect.\n\nFirst we will generate some data, in this case, we'll create two 2D \"blobs\"\nin a 2D grid. One blob will be positive, and the other negative.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n# sphinx_gallery_thumbnail_number = 3\nimport numpy as np\n\nfrom matplotlib.colors import Normalize\n\n\ndef normal_pdf(x, mean, var):\n    return np.exp(-(x - mean)**2 / (2*var))\n\n\n# Generate the space in which the blobs will live\nxmin, xmax, ymin, ymax = (0, 100, 0, 100)\nn_bins = 100\nxx = np.linspace(xmin, xmax, n_bins)\nyy = np.linspace(ymin, ymax, n_bins)\n\n# Generate the blobs. The range of the values is roughly -.0002 to .0002\nmeans_high = [20, 50]\nmeans_low = [50, 60]\nvar = [150, 200]\n\ngauss_x_high = normal_pdf(xx, means_high[0], var[0])\ngauss_y_high = normal_pdf(yy, means_high[1], var[0])\n\ngauss_x_low = normal_pdf(xx, means_low[0], var[1])\ngauss_y_low = normal_pdf(yy, means_low[1], var[1])\n\nweights = (np.outer(gauss_y_high, gauss_x_high)\n           - np.outer(gauss_y_low, gauss_x_low))\n\n# We'll also create a grey background into which the pixels will fade\ngreys = np.full((*weights.shape, 3), 70, dtype=np.uint8)\n\n# First we'll plot these blobs using ``imshow`` without transparency.\nvmax = np.abs(weights).max()\nimshow_kwargs = {\n    'vmax': vmax,\n    'vmin': -vmax,\n    'cmap': 'RdYlBu',\n    'extent': (xmin, xmax, ymin, ymax),\n}\n\nfig, ax = plt.subplots()\nax.imshow(greys)\nax.imshow(weights, **imshow_kwargs)\nax.set_axis_off()\n\n# %%\n# Blending in transparency\n# ========================\n#\n# The simplest way to include transparency when plotting data with\n# `matplotlib.pyplot.imshow` is to pass an array matching the shape of\n# the data to the ``alpha`` argument. For example, we'll create a gradient\n# moving from left to right below.\n\n# Create an alpha channel of linearly increasing values moving to the right.\nalphas = np.ones(weights.shape)\nalphas[:, 30:] = np.linspace(1, 0, 70)\n\n# Create the figure and image\n# Note that the absolute values may be slightly different\nfig, ax = plt.subplots()\nax.imshow(greys)\nax.imshow(weights, alpha=alphas, **imshow_kwargs)\nax.set_axis_off()\n\n# %%\n# Using transparency to highlight values with high amplitude\n# ==========================================================\n#\n# Finally, we'll recreate the same plot, but this time we'll use transparency\n# to highlight the extreme values in the data. This is often used to highlight\n# data points with smaller p-values. We'll also add in contour lines to\n# highlight the image values.\n\n# Create an alpha channel based on weight values\n# Any value whose absolute value is > .0001 will have zero transparency\nalphas = Normalize(0, .3, clip=True)(np.abs(weights))\nalphas = np.clip(alphas, .4, 1)  # alpha value clipped at the bottom at .4\n\n# Create the figure and image\n# Note that the absolute values may be slightly different\nfig, ax = plt.subplots()\nax.imshow(greys)\nax.imshow(weights, alpha=alphas, **imshow_kwargs)\n\n# Add contour lines to further highlight different levels.\nax.contour(weights[::-1], levels=[-.1, .1], colors='k', linestyles='-')\nax.set_axis_off()\nplt.show()\n\nax.contour(weights[::-1], levels=[-.0001, .0001], colors='k', linestyles='-')\nax.set_axis_off()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.colors.Normalize`\n#    - `matplotlib.axes.Axes.set_axis_off`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_068_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================================\nModifying the coordinate formatter\n==================================\n\nModify the coordinate formatter to report the image \"z\" value of the nearest\npixel given x and y.  This functionality is built in by default; this example\njust showcases how to customize the `~.axes.Axes.format_coord` function.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nX = 10*np.random.rand(5, 3)\n\nfig, ax = plt.subplots()\nax.imshow(X)\n\n\ndef format_coord(x, y):\n    col = round(x)\n    row = round(y)\n    nrows, ncols = X.shape\n    if 0 <= col < ncols and 0 <= row < nrows:\n        z = X[row, col]\n        return f'x={x:1.4f}, y={y:1.4f}, z={z:1.4f}'\n    else:\n        return f'x={x:1.4f}, y={y:1.4f}'\n\n\nax.format_coord = format_coord\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.format_coord`\n#    - `matplotlib.axes.Axes.imshow`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_069_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========================\nInterpolations for imshow\n=========================\n\nThis example displays the difference between interpolation methods for\n`~.axes.Axes.imshow`.\n\nIf *interpolation* is None, it defaults to the :rc:`image.interpolation`.\nIf the interpolation is ``'none'``, then no interpolation is performed for the\nAgg, ps and pdf backends. Other backends will default to ``'antialiased'``.\n\nFor the Agg, ps and pdf backends, ``interpolation='none'`` works well when a\nbig image is scaled down, while ``interpolation='nearest'`` works well when\na small image is scaled up.\n\nSee :doc:`/gallery/images_contours_and_fields/image_antialiasing` for a\ndiscussion on the default ``interpolation='antialiased'`` option.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nmethods = [None, 'none', 'nearest', 'bilinear', 'bicubic', 'spline16',\n           'spline36', 'hanning', 'hamming', 'hermite', 'kaiser', 'quadric',\n           'catrom', 'gaussian', 'bessel', 'mitchell', 'sinc', 'lanczos']\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\ngrid = np.random.rand(4, 4)\n\nfig, axs = plt.subplots(nrows=3, ncols=6, figsize=(9, 6),\n                        subplot_kw={'xticks': [], 'yticks': []})\n\nfor ax, interp_method in zip(axs.flat, methods):\n    ax.imshow(grid, interpolation=interp_method, cmap='viridis')\n    ax.set_title(str(interp_method))\n\nplt.tight_layout()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_070_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======================================\nContour plot of irregularly spaced data\n=======================================\n\nComparison of a contour plot of irregularly spaced data interpolated\non a regular grid versus a tricontour plot for an unstructured triangular grid.\n\nSince `~.axes.Axes.contour` and `~.axes.Axes.contourf` expect the data to live\non a regular grid, plotting a contour plot of irregularly spaced data requires\ndifferent methods. The two options are:\n\n* Interpolate the data to a regular grid first. This can be done with on-board\n  means, e.g. via `~.tri.LinearTriInterpolator` or using external functionality\n  e.g. via `scipy.interpolate.griddata`. Then plot the interpolated data with\n  the usual `~.axes.Axes.contour`.\n* Directly use `~.axes.Axes.tricontour` or `~.axes.Axes.tricontourf` which will\n  perform a triangulation internally.\n\nThis example shows both methods in action.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\nnp.random.seed(19680801)\nnpts = 200\nngridx = 100\nngridy = 200\nx = np.random.uniform(-2, 2, npts)\ny = np.random.uniform(-2, 2, npts)\nz = x * np.exp(-x**2 - y**2)\n\nfig, (ax1, ax2) = plt.subplots(nrows=2)\n\n# -----------------------\n# Interpolation on a grid\n# -----------------------\n# A contour plot of irregularly spaced data coordinates\n# via interpolation on a grid.\n\n# Create grid values first.\nxi = np.linspace(-2.1, 2.1, ngridx)\nyi = np.linspace(-2.1, 2.1, ngridy)\n\n# Linearly interpolate the data (x, y) on a grid defined by (xi, yi).\ntriang = tri.Triangulation(x, y)\ninterpolator = tri.LinearTriInterpolator(triang, z)\nXi, Yi = np.meshgrid(xi, yi)\nzi = interpolator(Xi, Yi)\n\n# Note that scipy.interpolate provides means to interpolate data on a grid\n# as well. The following would be an alternative to the four lines above:\n# from scipy.interpolate import griddata\n# zi = griddata((x, y), z, (xi[None, :], yi[:, None]), method='linear')\n\nax1.contour(xi, yi, zi, levels=14, linewidths=0.5, colors='k')\ncntr1 = ax1.contourf(xi, yi, zi, levels=14, cmap=\"RdBu_r\")\n\nfig.colorbar(cntr1, ax=ax1)\nax1.plot(x, y, 'ko', ms=3)\nax1.set(xlim=(-2, 2), ylim=(-2, 2))\nax1.set_title('grid and contour (%d points, %d grid points)' %\n              (npts, ngridx * ngridy))\n\n# ----------\n# Tricontour\n# ----------\n# Directly supply the unordered, irregularly spaced coordinates\n# to tricontour.\n\nax2.tricontour(x, y, z, levels=14, linewidths=0.5, colors='k')\ncntr2 = ax2.tricontourf(x, y, z, levels=14, cmap=\"RdBu_r\")\n\nfig.colorbar(cntr2, ax=ax2)\nax2.plot(x, y, 'ko', ms=3)\nax2.set(xlim=(-2, 2), ylim=(-2, 2))\nax2.set_title('tricontour (%d points)' % npts)\n\nplt.subplots_adjust(hspace=0.5)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.axes.Axes.contourf` / `matplotlib.pyplot.contourf`\n#    - `matplotlib.axes.Axes.tricontour` / `matplotlib.pyplot.tricontour`\n#    - `matplotlib.axes.Axes.tricontourf` / `matplotlib.pyplot.tricontourf`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_071_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============\nLayer Images\n============\n\nLayer images above one another using alpha blending\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef func3(x, y):\n    return (1 - x / 2 + x**5 + y**3) * np.exp(-(x**2 + y**2))\n\n\n# make these smaller to increase the resolution\ndx, dy = 0.05, 0.05\n\nx = np.arange(-3.0, 3.0, dx)\ny = np.arange(-3.0, 3.0, dy)\nX, Y = np.meshgrid(x, y)\n\n# when layering multiple images, the images need to have the same\n# extent.  This does not mean they need to have the same shape, but\n# they both need to render to the same coordinate system determined by\n# xmin, xmax, ymin, ymax.  Note if you use different interpolations\n# for the images their apparent extent could be different due to\n# interpolation edge effects\n\nextent = np.min(x), np.max(x), np.min(y), np.max(y)\nfig = plt.figure(frameon=False)\n\nZ1 = np.add.outer(range(8), range(8)) % 2  # chessboard\nim1 = plt.imshow(Z1, cmap=plt.cm.gray, interpolation='nearest',\n                 extent=extent)\n\nZ2 = func3(X, Y)\n\nim2 = plt.imshow(Z2, cmap=plt.cm.viridis, alpha=.9, interpolation='bilinear',\n                 extent=extent)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_072_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============================\nVisualize matrices with matshow\n===============================\n\n`~.axes.Axes.matshow` visualizes a 2D matrix or array as color-coded image.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# a 2D array with linearly increasing values on the diagonal\na = np.diag(range(15))\n\nplt.matshow(a)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_073_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============\nMultiple images\n===============\n\nMake a set of images with a single colormap, norm, and colorbar.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import colors\n\nnp.random.seed(19680801)\nNr = 3\nNc = 2\n\nfig, axs = plt.subplots(Nr, Nc)\nfig.suptitle('Multiple images')\n\nimages = []\nfor i in range(Nr):\n    for j in range(Nc):\n        # Generate data with a range that varies from one plot to the next.\n        data = ((1 + i + j) / 10) * np.random.rand(10, 20)\n        images.append(axs[i, j].imshow(data))\n        axs[i, j].label_outer()\n\n# Find the min and max of all colors for use in setting the color scale.\nvmin = min(image.get_array().min() for image in images)\nvmax = max(image.get_array().max() for image in images)\nnorm = colors.Normalize(vmin=vmin, vmax=vmax)\nfor im in images:\n    im.set_norm(norm)\n\nfig.colorbar(images[0], ax=axs, orientation='horizontal', fraction=.1)\n\n\n# Make images respond to changes in the norm of other images (e.g. via the\n# \"edit axis, curves and images parameters\" GUI on Qt), but be careful not to\n# recurse infinitely!\ndef update(changed_image):\n    for im in images:\n        if (changed_image.get_cmap() != im.get_cmap()\n                or changed_image.get_clim() != im.get_clim()):\n            im.set_cmap(changed_image.get_cmap())\n            im.set_clim(changed_image.get_clim())\n\n\nfor im in images:\n    im.callbacks.connect('changed', update)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.colors.Normalize`\n#    - `matplotlib.cm.ScalarMappable.set_cmap`\n#    - `matplotlib.cm.ScalarMappable.set_norm`\n#    - `matplotlib.cm.ScalarMappable.set_clim`\n#    - `matplotlib.cbook.CallbackRegistry.connect`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_074_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========\nPcolor demo\n===========\n\nGenerating images with `~.axes.Axes.pcolor`.\n\nPcolor allows you to generate 2D image-style plots. Below we will show how\nto do so in Matplotlib.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import LogNorm\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# %%\n# A simple pcolor demo\n# --------------------\n\nZ = np.random.rand(6, 10)\n\nfig, (ax0, ax1) = plt.subplots(2, 1)\n\nc = ax0.pcolor(Z)\nax0.set_title('default: no edges')\n\nc = ax1.pcolor(Z, edgecolors='k', linewidths=4)\nax1.set_title('thick edges')\n\nfig.tight_layout()\nplt.show()\n\n# %%\n# Comparing pcolor with similar functions\n# ---------------------------------------\n#\n# Demonstrates similarities between `~.axes.Axes.pcolor`,\n# `~.axes.Axes.pcolormesh`, `~.axes.Axes.imshow` and\n# `~.axes.Axes.pcolorfast` for drawing quadrilateral grids.\n# Note that we call ``imshow`` with ``aspect=\"auto\"`` so that it doesn't force\n# the data pixels to be square (the default is ``aspect=\"equal\"``).\n\n# make these smaller to increase the resolution\ndx, dy = 0.15, 0.05\n\n# generate 2 2d grids for the x & y bounds\ny, x = np.mgrid[-3:3+dy:dy, -3:3+dx:dx]\nz = (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)\n# x and y are bounds, so z should be the value *inside* those bounds.\n# Therefore, remove the last value from the z array.\nz = z[:-1, :-1]\nz_min, z_max = -abs(z).max(), abs(z).max()\n\nfig, axs = plt.subplots(2, 2)\n\nax = axs[0, 0]\nc = ax.pcolor(x, y, z, cmap='RdBu', vmin=z_min, vmax=z_max)\nax.set_title('pcolor')\nfig.colorbar(c, ax=ax)\n\nax = axs[0, 1]\nc = ax.pcolormesh(x, y, z, cmap='RdBu', vmin=z_min, vmax=z_max)\nax.set_title('pcolormesh')\nfig.colorbar(c, ax=ax)\n\nax = axs[1, 0]\nc = ax.imshow(z, cmap='RdBu', vmin=z_min, vmax=z_max,\n              extent=[x.min(), x.max(), y.min(), y.max()],\n              interpolation='nearest', origin='lower', aspect='auto')\nax.set_title('image (nearest, aspect=\"auto\")')\nfig.colorbar(c, ax=ax)\n\nax = axs[1, 1]\nc = ax.pcolorfast(x, y, z, cmap='RdBu', vmin=z_min, vmax=z_max)\nax.set_title('pcolorfast')\nfig.colorbar(c, ax=ax)\n\nfig.tight_layout()\nplt.show()\n\n\n# %%\n# Pcolor with a log scale\n# -----------------------\n#\n# The following shows pcolor plots with a log scale.\n\nN = 100\nX, Y = np.meshgrid(np.linspace(-3, 3, N), np.linspace(-2, 2, N))\n\n# A low hump with a spike coming out.\n# Needs to have z/colour axis on a log scale, so we see both hump and spike.\n# A linear scale only shows the spike.\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X * 10)**2 - (Y * 10)**2)\nZ = Z1 + 50 * Z2\n\nfig, (ax0, ax1) = plt.subplots(2, 1)\n\nc = ax0.pcolor(X, Y, Z, shading='auto',\n               norm=LogNorm(vmin=Z.min(), vmax=Z.max()), cmap='PuBu_r')\nfig.colorbar(c, ax=ax0)\n\nc = ax1.pcolor(X, Y, Z, cmap='PuBu_r', shading='auto')\nfig.colorbar(c, ax=ax1)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pcolor` / `matplotlib.pyplot.pcolor`\n#    - `matplotlib.axes.Axes.pcolormesh` / `matplotlib.pyplot.pcolormesh`\n#    - `matplotlib.axes.Axes.pcolorfast`\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.colors.LogNorm`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_075_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============================\npcolormesh grids and shading\n============================\n\n`.axes.Axes.pcolormesh` and `~.axes.Axes.pcolor` have a few options for\nhow grids are laid out and the shading between the grid points.\n\nGenerally, if *Z* has shape *(M, N)* then the grid *X* and *Y* can be\nspecified with either shape *(M+1, N+1)* or *(M, N)*, depending on the\nargument for the ``shading`` keyword argument.  Note that below we specify\nvectors *x* as either length N or N+1 and *y* as length M or M+1, and\n`~.axes.Axes.pcolormesh` internally makes the mesh matrices *X* and *Y* from\nthe input vectors.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# %%\n# Flat Shading\n# ------------\n#\n# The grid specification with the least assumptions is ``shading='flat'``\n# and if the grid is one larger than the data in each dimension, i.e. has shape\n# *(M+1, N+1)*.  In that case *X* and *Y* specify the corners of quadrilaterals\n# that are colored with the values in *Z*. Here we specify the edges of the\n# *(3, 5)* quadrilaterals with *X* and *Y* that are *(4, 6)*.\n\nnrows = 3\nncols = 5\nZ = np.arange(nrows * ncols).reshape(nrows, ncols)\nx = np.arange(ncols + 1)\ny = np.arange(nrows + 1)\n\nfig, ax = plt.subplots()\nax.pcolormesh(x, y, Z, shading='flat', vmin=Z.min(), vmax=Z.max())\n\n\ndef _annotate(ax, x, y, title):\n    # this all gets repeated below:\n    X, Y = np.meshgrid(x, y)\n    ax.plot(X.flat, Y.flat, 'o', color='m')\n    ax.set_xlim(-0.7, 5.2)\n    ax.set_ylim(-0.7, 3.2)\n    ax.set_title(title)\n\n_annotate(ax, x, y, \"shading='flat'\")\n\n\n# %%\n# Flat Shading, same shape grid\n# -----------------------------\n#\n# Often, however, data is provided where *X* and *Y* match the shape of *Z*.\n# While this makes sense for other ``shading`` types, it is not permitted\n# when ``shading='flat'``. Historically, Matplotlib silently dropped the last\n# row and column of *Z* in this case, to match Matlab's behavior. If this\n# behavior is still desired, simply drop the last row and column manually:\n\nx = np.arange(ncols)  # note *not* ncols + 1 as before\ny = np.arange(nrows)\nfig, ax = plt.subplots()\nax.pcolormesh(x, y, Z[:-1, :-1], shading='flat', vmin=Z.min(), vmax=Z.max())\n_annotate(ax, x, y, \"shading='flat': X, Y, C same shape\")\n\n# %%\n# Nearest Shading, same shape grid\n# --------------------------------\n#\n# Usually, dropping a row and column of data is not what the user means when\n# they make *X*, *Y* and *Z* all the same shape.  For this case, Matplotlib\n# allows ``shading='nearest'`` and centers the colored quadrilaterals on the\n# grid points.\n#\n# If a grid that is not the correct shape is passed with ``shading='nearest'``\n# an error is raised.\n\nfig, ax = plt.subplots()\nax.pcolormesh(x, y, Z, shading='nearest', vmin=Z.min(), vmax=Z.max())\n_annotate(ax, x, y, \"shading='nearest'\")\n\n# %%\n# Auto Shading\n# ------------\n#\n# It's possible that the user would like the code to automatically choose which\n# to use, in this case ``shading='auto'`` will decide whether to use 'flat' or\n# 'nearest' shading based on the shapes of *X*, *Y* and *Z*.\n\nfig, axs = plt.subplots(2, 1, layout='constrained')\nax = axs[0]\nx = np.arange(ncols)\ny = np.arange(nrows)\nax.pcolormesh(x, y, Z, shading='auto', vmin=Z.min(), vmax=Z.max())\n_annotate(ax, x, y, \"shading='auto'; X, Y, Z: same shape (nearest)\")\n\nax = axs[1]\nx = np.arange(ncols + 1)\ny = np.arange(nrows + 1)\nax.pcolormesh(x, y, Z, shading='auto', vmin=Z.min(), vmax=Z.max())\n_annotate(ax, x, y, \"shading='auto'; X, Y one larger than Z (flat)\")\n\n# %%\n# Gouraud Shading\n# ---------------\n#\n# `Gouraud shading <https://en.wikipedia.org/wiki/Gouraud_shading>`_ can also\n# be specified, where the color in the quadrilaterals is linearly interpolated\n# between the grid points.  The shapes of *X*, *Y*, *Z* must be the same.\n\nfig, ax = plt.subplots(layout='constrained')\nx = np.arange(ncols)\ny = np.arange(nrows)\nax.pcolormesh(x, y, Z, shading='gouraud', vmin=Z.min(), vmax=Z.max())\n_annotate(ax, x, y, \"shading='gouraud'; X, Y same shape as Z\")\n\nplt.show()\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pcolormesh` / `matplotlib.pyplot.pcolormesh`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_076_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========\npcolormesh\n==========\n\n`.axes.Axes.pcolormesh` allows you to generate 2D image-style plots.\nNote that it is faster than the similar `~.axes.Axes.pcolor`.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import BoundaryNorm\nfrom matplotlib.ticker import MaxNLocator\n\n# %%\n# Basic pcolormesh\n# ----------------\n#\n# We usually specify a pcolormesh by defining the edge of quadrilaterals and\n# the value of the quadrilateral.  Note that here *x* and *y* each have one\n# extra element than Z in the respective dimension.\n\nnp.random.seed(19680801)\nZ = np.random.rand(6, 10)\nx = np.arange(-0.5, 10, 1)  # len = 11\ny = np.arange(4.5, 11, 1)  # len = 7\n\nfig, ax = plt.subplots()\nax.pcolormesh(x, y, Z)\n\n# %%\n# Non-rectilinear pcolormesh\n# --------------------------\n#\n# Note that we can also specify matrices for *X* and *Y* and have\n# non-rectilinear quadrilaterals.\n\nx = np.arange(-0.5, 10, 1)  # len = 11\ny = np.arange(4.5, 11, 1)  # len = 7\nX, Y = np.meshgrid(x, y)\nX = X + 0.2 * Y  # tilt the coordinates.\nY = Y + 0.3 * X\n\nfig, ax = plt.subplots()\nax.pcolormesh(X, Y, Z)\n\n# %%\n# Centered Coordinates\n# ---------------------\n#\n# Often a user wants to pass *X* and *Y* with the same sizes as *Z* to\n# `.axes.Axes.pcolormesh`. This is also allowed if ``shading='auto'`` is\n# passed (default set by :rc:`pcolor.shading`). Pre Matplotlib 3.3,\n# ``shading='flat'`` would drop the last column and row of *Z*, but now gives\n# an error. If this is really what you want, then simply drop the last row and\n# column of Z manually:\n\nx = np.arange(10)  # len = 10\ny = np.arange(6)  # len = 6\nX, Y = np.meshgrid(x, y)\n\nfig, axs = plt.subplots(2, 1, sharex=True, sharey=True)\naxs[0].pcolormesh(X, Y, Z, vmin=np.min(Z), vmax=np.max(Z), shading='auto')\naxs[0].set_title(\"shading='auto' = 'nearest'\")\naxs[1].pcolormesh(X, Y, Z[:-1, :-1], vmin=np.min(Z), vmax=np.max(Z),\n                  shading='flat')\naxs[1].set_title(\"shading='flat'\")\n\n# %%\n# Making levels using Norms\n# -------------------------\n#\n# Shows how to combine Normalization and Colormap instances to draw\n# \"levels\" in `.axes.Axes.pcolor`, `.axes.Axes.pcolormesh`\n# and `.axes.Axes.imshow` type plots in a similar\n# way to the levels keyword argument to contour/contourf.\n\n# make these smaller to increase the resolution\ndx, dy = 0.05, 0.05\n\n# generate 2 2d grids for the x & y bounds\ny, x = np.mgrid[slice(1, 5 + dy, dy),\n                slice(1, 5 + dx, dx)]\n\nz = np.sin(x)**10 + np.cos(10 + y*x) * np.cos(x)\n\n# x and y are bounds, so z should be the value *inside* those bounds.\n# Therefore, remove the last value from the z array.\nz = z[:-1, :-1]\nlevels = MaxNLocator(nbins=15).tick_values(z.min(), z.max())\n\n\n# pick the desired colormap, sensible levels, and define a normalization\n# instance which takes data values and translates those into levels.\ncmap = plt.colormaps['PiYG']\nnorm = BoundaryNorm(levels, ncolors=cmap.N, clip=True)\n\nfig, (ax0, ax1) = plt.subplots(nrows=2)\n\nim = ax0.pcolormesh(x, y, z, cmap=cmap, norm=norm)\nfig.colorbar(im, ax=ax0)\nax0.set_title('pcolormesh with levels')\n\n\n# contours are *point* based plots, so convert our bound into point\n# centers\ncf = ax1.contourf(x[:-1, :-1] + dx/2.,\n                  y[:-1, :-1] + dy/2., z, levels=levels,\n                  cmap=cmap)\nfig.colorbar(cf, ax=ax1)\nax1.set_title('contourf with levels')\n\n# adjust spacing between subplots so `ax1` title and `ax0` tick labels\n# don't overlap\nfig.tight_layout()\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pcolormesh` / `matplotlib.pyplot.pcolormesh`\n#    - `matplotlib.axes.Axes.contourf` / `matplotlib.pyplot.contourf`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.colors.BoundaryNorm`\n#    - `matplotlib.ticker.MaxNLocator`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_077_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========\nStreamplot\n==========\n\nA stream plot, or streamline plot, is used to display 2D vector fields. This\nexample shows a few features of the `~.axes.Axes.streamplot` function:\n\n* Varying the color along a streamline.\n* Varying the density of streamlines.\n* Varying the line width along a streamline.\n* Controlling the starting points of streamlines.\n* Streamlines skipping masked regions and NaN values.\n* Unbroken streamlines even when exceeding the limit of lines within a single\n  grid cell.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nw = 3\nY, X = np.mgrid[-w:w:100j, -w:w:100j]\nU = -1 - X**2 + Y\nV = 1 + X - Y**2\nspeed = np.sqrt(U**2 + V**2)\n\nfig, axs = plt.subplots(3, 2, figsize=(7, 9), height_ratios=[1, 1, 2])\naxs = axs.flat\n\n#  Varying density along a streamline\naxs[0].streamplot(X, Y, U, V, density=[0.5, 1])\naxs[0].set_title('Varying Density')\n\n# Varying color along a streamline\nstrm = axs[1].streamplot(X, Y, U, V, color=U, linewidth=2, cmap='autumn')\nfig.colorbar(strm.lines)\naxs[1].set_title('Varying Color')\n\n#  Varying line width along a streamline\nlw = 5*speed / speed.max()\naxs[2].streamplot(X, Y, U, V, density=0.6, color='k', linewidth=lw)\naxs[2].set_title('Varying Line Width')\n\n# Controlling the starting points of the streamlines\nseed_points = np.array([[-2, -1, 0, 1, 2, -1], [-2, -1,  0, 1, 2, 2]])\n\nstrm = axs[3].streamplot(X, Y, U, V, color=U, linewidth=2,\n                         cmap='autumn', start_points=seed_points.T)\nfig.colorbar(strm.lines)\naxs[3].set_title('Controlling Starting Points')\n\n# Displaying the starting points with blue symbols.\naxs[3].plot(seed_points[0], seed_points[1], 'bo')\naxs[3].set(xlim=(-w, w), ylim=(-w, w))\n\n# Create a mask\nmask = np.zeros(U.shape, dtype=bool)\nmask[40:60, 40:60] = True\nU[:20, :20] = np.nan\nU = np.ma.array(U, mask=mask)\n\naxs[4].streamplot(X, Y, U, V, color='r')\naxs[4].set_title('Streamplot with Masking')\n\naxs[4].imshow(~mask, extent=(-w, w, -w, w), alpha=0.5, cmap='gray',\n              aspect='auto')\naxs[4].set_aspect('equal')\n\naxs[5].streamplot(X, Y, U, V, broken_streamlines=False)\naxs[5].set_title('Streamplot with unbroken streamlines')\n\nplt.tight_layout()\nplt.show()\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.streamplot` / `matplotlib.pyplot.streamplot`\n#    - `matplotlib.gridspec.GridSpec`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_078_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============\nQuadMesh Demo\n=============\n\n`~.axes.Axes.pcolormesh` uses a `~matplotlib.collections.QuadMesh`,\na faster generalization of `~.axes.Axes.pcolor`, but with some restrictions.\n\nThis demo illustrates a bug in quadmesh with masked data.\n\"\"\"\n\nimport numpy as np\n\nfrom matplotlib import pyplot as plt\n\nn = 12\nx = np.linspace(-1.5, 1.5, n)\ny = np.linspace(-1.5, 1.5, n * 2)\nX, Y = np.meshgrid(x, y)\nQx = np.cos(Y) - np.cos(X)\nQz = np.sin(Y) + np.sin(X)\nZ = np.sqrt(X**2 + Y**2) / 5\nZ = (Z - Z.min()) / (Z.max() - Z.min())\n\n# The color array can include masked values.\nZm = np.ma.masked_where(np.abs(Qz) < 0.5 * np.max(Qz), Z)\n\nfig, axs = plt.subplots(nrows=1, ncols=3)\naxs[0].pcolormesh(Qx, Qz, Z, shading='gouraud')\naxs[0].set_title('Without masked values')\n\n# You can control the color of the masked region.\ncmap = plt.colormaps[plt.rcParams['image.cmap']].with_extremes(bad='y')\naxs[1].pcolormesh(Qx, Qz, Zm, shading='gouraud', cmap=cmap)\naxs[1].set_title('With masked values')\n\n# Or use the default, which is transparent.\naxs[2].pcolormesh(Qx, Qz, Zm, shading='gouraud')\naxs[2].set_title('With masked values')\n\nfig.tight_layout()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pcolormesh` / `matplotlib.pyplot.pcolormesh`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_079_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======================================\nAdvanced quiver and quiverkey functions\n=======================================\n\nDemonstrates some more advanced options for `~.axes.Axes.quiver`.  For a simple\nexample refer to :doc:`/gallery/images_contours_and_fields/quiver_simple_demo`.\n\nNote: The plot autoscaling does not take into account the arrows, so\nthose on the boundaries may reach out of the picture.  This is not an easy\nproblem to solve in a perfectly general way.  The recommended workaround is to\nmanually set the Axes limits in such a case.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nX, Y = np.meshgrid(np.arange(0, 2 * np.pi, .2), np.arange(0, 2 * np.pi, .2))\nU = np.cos(X)\nV = np.sin(Y)\n\n# %%\n\nfig1, ax1 = plt.subplots()\nax1.set_title('Arrows scale with plot width, not view')\nQ = ax1.quiver(X, Y, U, V, units='width')\nqk = ax1.quiverkey(Q, 0.9, 0.9, 2, r'$2 \\frac{m}{s}$', labelpos='E',\n                   coordinates='figure')\n\n# %%\n\nfig2, ax2 = plt.subplots()\nax2.set_title(\"pivot='mid'; every third arrow; units='inches'\")\nQ = ax2.quiver(X[::3, ::3], Y[::3, ::3], U[::3, ::3], V[::3, ::3],\n               pivot='mid', units='inches')\nqk = ax2.quiverkey(Q, 0.9, 0.9, 1, r'$1 \\frac{m}{s}$', labelpos='E',\n                   coordinates='figure')\nax2.scatter(X[::3, ::3], Y[::3, ::3], color='r', s=5)\n\n# %%\n\n# sphinx_gallery_thumbnail_number = 3\n\nfig3, ax3 = plt.subplots()\nax3.set_title(\"pivot='tip'; scales with x view\")\nM = np.hypot(U, V)\nQ = ax3.quiver(X, Y, U, V, M, units='x', pivot='tip', width=0.022,\n               scale=1 / 0.15)\nqk = ax3.quiverkey(Q, 0.9, 0.9, 1, r'$1 \\frac{m}{s}$', labelpos='E',\n                   coordinates='figure')\nax3.scatter(X, Y, color='0.5', s=1)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.quiver` / `matplotlib.pyplot.quiver`\n#    - `matplotlib.axes.Axes.quiverkey` / `matplotlib.pyplot.quiverkey`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_080_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================\nQuiver Simple Demo\n==================\n\nA simple example of a `~.axes.Axes.quiver` plot with a `~.axes.Axes.quiverkey`.\n\nFor more advanced options refer to\n:doc:`/gallery/images_contours_and_fields/quiver_demo`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nX = np.arange(-10, 10, 1)\nY = np.arange(-10, 10, 1)\nU, V = np.meshgrid(X, Y)\n\nfig, ax = plt.subplots()\nq = ax.quiver(X, Y, U, V)\nax.quiverkey(q, X=0.3, Y=1.1, U=10,\n             label='Quiver key, length = 10', labelpos='E')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.quiver` / `matplotlib.pyplot.quiver`\n#    - `matplotlib.axes.Axes.quiverkey` / `matplotlib.pyplot.quiverkey`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_081_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nSpectrogram Demo\n================\n\nDemo of a spectrogram plot (`~.axes.Axes.specgram`).\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\ndt = 0.0005\nt = np.arange(0.0, 20.0, dt)\ns1 = np.sin(2 * np.pi * 100 * t)\ns2 = 2 * np.sin(2 * np.pi * 400 * t)\n\n# create a transient \"chirp\"\ns2[t <= 10] = s2[12 <= t] = 0\n\n# add some noise into the mix\nnse = 0.01 * np.random.random(size=len(t))\n\nx = s1 + s2 + nse  # the signal\nNFFT = 1024  # the length of the windowing segments\nFs = int(1.0 / dt)  # the sampling frequency\n\nfig, (ax1, ax2) = plt.subplots(nrows=2)\nax1.plot(t, x)\nPxx, freqs, bins, im = ax2.specgram(x, NFFT=NFFT, Fs=Fs, noverlap=900)\n# The `specgram` method returns 4 objects. They are:\n# - Pxx: the periodogram\n# - freqs: the frequency vector\n# - bins: the centers of the time bins\n# - im: the .image.AxesImage instance representing the data in the plot\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.specgram` / `matplotlib.pyplot.specgram`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_082_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========\nSpy Demos\n=========\n\nPlot the sparsity pattern of arrays.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, axs = plt.subplots(2, 2)\nax1 = axs[0, 0]\nax2 = axs[0, 1]\nax3 = axs[1, 0]\nax4 = axs[1, 1]\n\nx = np.random.randn(20, 20)\nx[5, :] = 0.\nx[:, 12] = 0.\n\nax1.spy(x, markersize=5)\nax2.spy(x, precision=0.1, markersize=5)\n\nax3.spy(x)\nax4.spy(x, precision=0.1)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.spy` / `matplotlib.pyplot.spy`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_083_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============\nTricontour Demo\n===============\n\nContour plots of unstructured triangular grids.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\n# %%\n# Creating a Triangulation without specifying the triangles results in the\n# Delaunay triangulation of the points.\n\n# First create the x and y coordinates of the points.\nn_angles = 48\nn_radii = 8\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii * np.cos(angles)).flatten()\ny = (radii * np.sin(angles)).flatten()\nz = (np.cos(radii) * np.cos(3 * angles)).flatten()\n\n# Create the Triangulation; no triangles so Delaunay triangulation created.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# %%\n# pcolor plot.\n\nfig1, ax1 = plt.subplots()\nax1.set_aspect('equal')\ntcf = ax1.tricontourf(triang, z)\nfig1.colorbar(tcf)\nax1.tricontour(triang, z, colors='k')\nax1.set_title('Contour plot of Delaunay triangulation')\n\n\n# %%\n# You could also specify hatching patterns along with different cmaps.\n\nfig2, ax2 = plt.subplots()\nax2.set_aspect(\"equal\")\ntcf = ax2.tricontourf(\n    triang,\n    z,\n    hatches=[\"*\", \"-\", \"/\", \"//\", \"\\\\\", None],\n    cmap=\"cividis\"\n)\nfig2.colorbar(tcf)\nax2.tricontour(triang, z, linestyles=\"solid\", colors=\"k\", linewidths=2.0)\nax2.set_title(\"Hatched Contour plot of Delaunay triangulation\")\n\n# %%\n# You could also generate hatching patterns labeled with no color.\n\nfig3, ax3 = plt.subplots()\nn_levels = 7\ntcf = ax3.tricontourf(\n    triang,\n    z,\n    n_levels,\n    colors=\"none\",\n    hatches=[\".\", \"/\", \"\\\\\", None, \"\\\\\\\\\", \"*\"],\n)\nax3.tricontour(triang, z, n_levels, colors=\"black\", linestyles=\"-\")\n\n\n# create a legend for the contour set\nartists, labels = tcf.legend_elements(str_format=\"{:2.1f}\".format)\nax3.legend(artists, labels, handleheight=2, framealpha=1)\n\n# %%\n# You can specify your own triangulation rather than perform a Delaunay\n# triangulation of the points, where each triangle is given by the indices of\n# the three points that make up the triangle, ordered in either a clockwise or\n# anticlockwise manner.\n\nxy = np.asarray([\n    [-0.101, 0.872], [-0.080, 0.883], [-0.069, 0.888], [-0.054, 0.890],\n    [-0.045, 0.897], [-0.057, 0.895], [-0.073, 0.900], [-0.087, 0.898],\n    [-0.090, 0.904], [-0.069, 0.907], [-0.069, 0.921], [-0.080, 0.919],\n    [-0.073, 0.928], [-0.052, 0.930], [-0.048, 0.942], [-0.062, 0.949],\n    [-0.054, 0.958], [-0.069, 0.954], [-0.087, 0.952], [-0.087, 0.959],\n    [-0.080, 0.966], [-0.085, 0.973], [-0.087, 0.965], [-0.097, 0.965],\n    [-0.097, 0.975], [-0.092, 0.984], [-0.101, 0.980], [-0.108, 0.980],\n    [-0.104, 0.987], [-0.102, 0.993], [-0.115, 1.001], [-0.099, 0.996],\n    [-0.101, 1.007], [-0.090, 1.010], [-0.087, 1.021], [-0.069, 1.021],\n    [-0.052, 1.022], [-0.052, 1.017], [-0.069, 1.010], [-0.064, 1.005],\n    [-0.048, 1.005], [-0.031, 1.005], [-0.031, 0.996], [-0.040, 0.987],\n    [-0.045, 0.980], [-0.052, 0.975], [-0.040, 0.973], [-0.026, 0.968],\n    [-0.020, 0.954], [-0.006, 0.947], [ 0.003, 0.935], [ 0.006, 0.926],\n    [ 0.005, 0.921], [ 0.022, 0.923], [ 0.033, 0.912], [ 0.029, 0.905],\n    [ 0.017, 0.900], [ 0.012, 0.895], [ 0.027, 0.893], [ 0.019, 0.886],\n    [ 0.001, 0.883], [-0.012, 0.884], [-0.029, 0.883], [-0.038, 0.879],\n    [-0.057, 0.881], [-0.062, 0.876], [-0.078, 0.876], [-0.087, 0.872],\n    [-0.030, 0.907], [-0.007, 0.905], [-0.057, 0.916], [-0.025, 0.933],\n    [-0.077, 0.990], [-0.059, 0.993]])\nx = np.degrees(xy[:, 0])\ny = np.degrees(xy[:, 1])\nx0 = -5\ny0 = 52\nz = np.exp(-0.01 * ((x - x0) ** 2 + (y - y0) ** 2))\n\ntriangles = np.asarray([\n    [67, 66,  1], [65,  2, 66], [ 1, 66,  2], [64,  2, 65], [63,  3, 64],\n    [60, 59, 57], [ 2, 64,  3], [ 3, 63,  4], [ 0, 67,  1], [62,  4, 63],\n    [57, 59, 56], [59, 58, 56], [61, 60, 69], [57, 69, 60], [ 4, 62, 68],\n    [ 6,  5,  9], [61, 68, 62], [69, 68, 61], [ 9,  5, 70], [ 6,  8,  7],\n    [ 4, 70,  5], [ 8,  6,  9], [56, 69, 57], [69, 56, 52], [70, 10,  9],\n    [54, 53, 55], [56, 55, 53], [68, 70,  4], [52, 56, 53], [11, 10, 12],\n    [69, 71, 68], [68, 13, 70], [10, 70, 13], [51, 50, 52], [13, 68, 71],\n    [52, 71, 69], [12, 10, 13], [71, 52, 50], [71, 14, 13], [50, 49, 71],\n    [49, 48, 71], [14, 16, 15], [14, 71, 48], [17, 19, 18], [17, 20, 19],\n    [48, 16, 14], [48, 47, 16], [47, 46, 16], [16, 46, 45], [23, 22, 24],\n    [21, 24, 22], [17, 16, 45], [20, 17, 45], [21, 25, 24], [27, 26, 28],\n    [20, 72, 21], [25, 21, 72], [45, 72, 20], [25, 28, 26], [44, 73, 45],\n    [72, 45, 73], [28, 25, 29], [29, 25, 31], [43, 73, 44], [73, 43, 40],\n    [72, 73, 39], [72, 31, 25], [42, 40, 43], [31, 30, 29], [39, 73, 40],\n    [42, 41, 40], [72, 33, 31], [32, 31, 33], [39, 38, 72], [33, 72, 38],\n    [33, 38, 34], [37, 35, 38], [34, 38, 35], [35, 37, 36]])\n\n# %%\n# Rather than create a Triangulation object, can simply pass x, y and triangles\n# arrays to tripcolor directly.  It would be better to use a Triangulation\n# object if the same triangulation was to be used more than once to save\n# duplicated calculations.\n\nfig4, ax4 = plt.subplots()\nax4.set_aspect('equal')\ntcf = ax4.tricontourf(x, y, triangles, z)\nfig4.colorbar(tcf)\nax4.set_title('Contour plot of user-specified triangulation')\nax4.set_xlabel('Longitude (degrees)')\nax4.set_ylabel('Latitude (degrees)')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.tricontourf` / `matplotlib.pyplot.tricontourf`\n#    - `matplotlib.tri.Triangulation`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.axes.Axes.legend` / `matplotlib.pyplot.legend`\n#    - `matplotlib.contour.ContourSet.legend_elements`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_084_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========================\nTricontour Smooth Delaunay\n==========================\n\nDemonstrates high-resolution tricontouring of a random set of points;\na `matplotlib.tri.TriAnalyzer` is used to improve the plot quality.\n\nThe initial data points and triangular grid for this demo are:\n\n- a set of random points is instantiated, inside [-1, 1] x [-1, 1] square\n- A Delaunay triangulation of these points is then computed, of which a\n  random subset of triangles is masked out by the user (based on\n  *init_mask_frac* parameter). This simulates invalidated data.\n\nThe proposed generic procedure to obtain a high resolution contouring of such\na data set is the following:\n\n1. Compute an extended mask with a `matplotlib.tri.TriAnalyzer`, which will\n   exclude badly shaped (flat) triangles from the border of the\n   triangulation. Apply the mask to the triangulation (using set_mask).\n2. Refine and interpolate the data using a `matplotlib.tri.UniformTriRefiner`.\n3. Plot the refined data with `~.axes.Axes.tricontour`.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.tri import TriAnalyzer, Triangulation, UniformTriRefiner\n\n\n# ----------------------------------------------------------------------------\n# Analytical test function\n# ----------------------------------------------------------------------------\ndef experiment_res(x, y):\n    \"\"\"An analytic function representing experiment results.\"\"\"\n    x = 2 * x\n    r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2)\n    theta1 = np.arctan2(0.5 - x, 0.5 - y)\n    r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2)\n    theta2 = np.arctan2(-x - 0.2, -y - 0.2)\n    z = (4 * (np.exp((r1/10)**2) - 1) * 30 * np.cos(3 * theta1) +\n         (np.exp((r2/10)**2) - 1) * 30 * np.cos(5 * theta2) +\n         2 * (x**2 + y**2))\n    return (np.max(z) - z) / (np.max(z) - np.min(z))\n\n# ----------------------------------------------------------------------------\n# Generating the initial data test points and triangulation for the demo\n# ----------------------------------------------------------------------------\n# User parameters for data test points\n\n# Number of test data points, tested from 3 to 5000 for subdiv=3\nn_test = 200\n\n# Number of recursive subdivisions of the initial mesh for smooth plots.\n# Values >3 might result in a very high number of triangles for the refine\n# mesh: new triangles numbering = (4**subdiv)*ntri\nsubdiv = 3\n\n# Float > 0. adjusting the proportion of (invalid) initial triangles which will\n# be masked out. Enter 0 for no mask.\ninit_mask_frac = 0.0\n\n# Minimum circle ratio - border triangles with circle ratio below this will be\n# masked if they touch a border. Suggested value 0.01; use -1 to keep all\n# triangles.\nmin_circle_ratio = .01\n\n# Random points\nrandom_gen = np.random.RandomState(seed=19680801)\nx_test = random_gen.uniform(-1., 1., size=n_test)\ny_test = random_gen.uniform(-1., 1., size=n_test)\nz_test = experiment_res(x_test, y_test)\n\n# meshing with Delaunay triangulation\ntri = Triangulation(x_test, y_test)\nntri = tri.triangles.shape[0]\n\n# Some invalid data are masked out\nmask_init = np.zeros(ntri, dtype=bool)\nmasked_tri = random_gen.randint(0, ntri, int(ntri * init_mask_frac))\nmask_init[masked_tri] = True\ntri.set_mask(mask_init)\n\n\n# ----------------------------------------------------------------------------\n# Improving the triangulation before high-res plots: removing flat triangles\n# ----------------------------------------------------------------------------\n# masking badly shaped triangles at the border of the triangular mesh.\nmask = TriAnalyzer(tri).get_flat_tri_mask(min_circle_ratio)\ntri.set_mask(mask)\n\n# refining the data\nrefiner = UniformTriRefiner(tri)\ntri_refi, z_test_refi = refiner.refine_field(z_test, subdiv=subdiv)\n\n# analytical 'results' for comparison\nz_expected = experiment_res(tri_refi.x, tri_refi.y)\n\n# for the demo: loading the 'flat' triangles for plot\nflat_tri = Triangulation(x_test, y_test)\nflat_tri.set_mask(~mask)\n\n\n# ----------------------------------------------------------------------------\n# Now the plots\n# ----------------------------------------------------------------------------\n# User options for plots\nplot_tri = True          # plot of base triangulation\nplot_masked_tri = True   # plot of excessively flat excluded triangles\nplot_refi_tri = False    # plot of refined triangulation\nplot_expected = False    # plot of analytical function values for comparison\n\n\n# Graphical options for tricontouring\nlevels = np.arange(0., 1., 0.025)\n\nfig, ax = plt.subplots()\nax.set_aspect('equal')\nax.set_title(\"Filtering a Delaunay mesh\\n\"\n             \"(application to high-resolution tricontouring)\")\n\n# 1) plot of the refined (computed) data contours:\nax.tricontour(tri_refi, z_test_refi, levels=levels, cmap='Blues',\n              linewidths=[2.0, 0.5, 1.0, 0.5])\n# 2) plot of the expected (analytical) data contours (dashed):\nif plot_expected:\n    ax.tricontour(tri_refi, z_expected, levels=levels, cmap='Blues',\n                  linestyles='--')\n# 3) plot of the fine mesh on which interpolation was done:\nif plot_refi_tri:\n    ax.triplot(tri_refi, color='0.97')\n# 4) plot of the initial 'coarse' mesh:\nif plot_tri:\n    ax.triplot(tri, color='0.7')\n# 4) plot of the unvalidated triangles from naive Delaunay Triangulation:\nif plot_masked_tri:\n    ax.triplot(flat_tri, color='red')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.tricontour` / `matplotlib.pyplot.tricontour`\n#    - `matplotlib.axes.Axes.tricontourf` / `matplotlib.pyplot.tricontourf`\n#    - `matplotlib.axes.Axes.triplot` / `matplotlib.pyplot.triplot`\n#    - `matplotlib.tri`\n#    - `matplotlib.tri.Triangulation`\n#    - `matplotlib.tri.TriAnalyzer`\n#    - `matplotlib.tri.UniformTriRefiner`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_085_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n======================\nTricontour Smooth User\n======================\n\nDemonstrates high-resolution tricontouring on user-defined triangular grids\nwith `matplotlib.tri.UniformTriRefiner`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\n\n# ----------------------------------------------------------------------------\n# Analytical test function\n# ----------------------------------------------------------------------------\ndef function_z(x, y):\n    r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2)\n    theta1 = np.arctan2(0.5 - x, 0.5 - y)\n    r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2)\n    theta2 = np.arctan2(-x - 0.2, -y - 0.2)\n    z = -(2 * (np.exp((r1 / 10)**2) - 1) * 30. * np.cos(7. * theta1) +\n          (np.exp((r2 / 10)**2) - 1) * 30. * np.cos(11. * theta2) +\n          0.7 * (x**2 + y**2))\n    return (np.max(z) - z) / (np.max(z) - np.min(z))\n\n# ----------------------------------------------------------------------------\n# Creating a Triangulation\n# ----------------------------------------------------------------------------\n# First create the x and y coordinates of the points.\nn_angles = 20\nn_radii = 10\nmin_radius = 0.15\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii * np.cos(angles)).flatten()\ny = (radii * np.sin(angles)).flatten()\nz = function_z(x, y)\n\n# Now create the Triangulation.\n# (Creating a Triangulation without specifying the triangles results in the\n# Delaunay triangulation of the points.)\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# ----------------------------------------------------------------------------\n# Refine data\n# ----------------------------------------------------------------------------\nrefiner = tri.UniformTriRefiner(triang)\ntri_refi, z_test_refi = refiner.refine_field(z, subdiv=3)\n\n# ----------------------------------------------------------------------------\n# Plot the triangulation and the high-res iso-contours\n# ----------------------------------------------------------------------------\nfig, ax = plt.subplots()\nax.set_aspect('equal')\nax.triplot(triang, lw=0.5, color='white')\n\nlevels = np.arange(0., 1., 0.025)\nax.tricontourf(tri_refi, z_test_refi, levels=levels, cmap='terrain')\nax.tricontour(tri_refi, z_test_refi, levels=levels,\n              colors=['0.25', '0.5', '0.5', '0.5', '0.5'],\n              linewidths=[1.0, 0.5, 0.5, 0.5, 0.5])\n\nax.set_title(\"High-resolution tricontouring\")\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.tricontour` / `matplotlib.pyplot.tricontour`\n#    - `matplotlib.axes.Axes.tricontourf` / `matplotlib.pyplot.tricontourf`\n#    - `matplotlib.tri`\n#    - `matplotlib.tri.Triangulation`\n#    - `matplotlib.tri.UniformTriRefiner`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_086_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nTrigradient Demo\n================\n\nDemonstrates computation of gradient with\n`matplotlib.tri.CubicTriInterpolator`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.tri import (CubicTriInterpolator, Triangulation,\n                            UniformTriRefiner)\n\n\n# ----------------------------------------------------------------------------\n# Electrical potential of a dipole\n# ----------------------------------------------------------------------------\ndef dipole_potential(x, y):\n    \"\"\"The electric dipole potential V, at position *x*, *y*.\"\"\"\n    r_sq = x**2 + y**2\n    theta = np.arctan2(y, x)\n    z = np.cos(theta)/r_sq\n    return (np.max(z) - z) / (np.max(z) - np.min(z))\n\n\n# ----------------------------------------------------------------------------\n# Creating a Triangulation\n# ----------------------------------------------------------------------------\n# First create the x and y coordinates of the points.\nn_angles = 30\nn_radii = 10\nmin_radius = 0.2\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nV = dipole_potential(x, y)\n\n# Create the Triangulation; no triangles specified so Delaunay triangulation\n# created.\ntriang = Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# ----------------------------------------------------------------------------\n# Refine data - interpolates the electrical potential V\n# ----------------------------------------------------------------------------\nrefiner = UniformTriRefiner(triang)\ntri_refi, z_test_refi = refiner.refine_field(V, subdiv=3)\n\n# ----------------------------------------------------------------------------\n# Computes the electrical field (Ex, Ey) as gradient of electrical potential\n# ----------------------------------------------------------------------------\ntci = CubicTriInterpolator(triang, -V)\n# Gradient requested here at the mesh nodes but could be anywhere else:\n(Ex, Ey) = tci.gradient(triang.x, triang.y)\nE_norm = np.sqrt(Ex**2 + Ey**2)\n\n# ----------------------------------------------------------------------------\n# Plot the triangulation, the potential iso-contours and the vector field\n# ----------------------------------------------------------------------------\nfig, ax = plt.subplots()\nax.set_aspect('equal')\n# Enforce the margins, and enlarge them to give room for the vectors.\nax.use_sticky_edges = False\nax.margins(0.07)\n\nax.triplot(triang, color='0.8')\n\nlevels = np.arange(0., 1., 0.01)\nax.tricontour(tri_refi, z_test_refi, levels=levels, cmap='hot',\n              linewidths=[2.0, 1.0, 1.0, 1.0])\n# Plots direction of the electrical vector field\nax.quiver(triang.x, triang.y, Ex/E_norm, Ey/E_norm,\n          units='xy', scale=10., zorder=3, color='blue',\n          width=0.007, headwidth=3., headlength=4.)\n\nax.set_title('Gradient plot: an electrical dipole')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.tricontour` / `matplotlib.pyplot.tricontour`\n#    - `matplotlib.axes.Axes.triplot` / `matplotlib.pyplot.triplot`\n#    - `matplotlib.tri`\n#    - `matplotlib.tri.Triangulation`\n#    - `matplotlib.tri.CubicTriInterpolator`\n#    - `matplotlib.tri.CubicTriInterpolator.gradient`\n#    - `matplotlib.tri.UniformTriRefiner`\n#    - `matplotlib.axes.Axes.quiver` / `matplotlib.pyplot.quiver`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_087_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============\nTriinterp Demo\n==============\n\nInterpolation from triangular grid to quad grid.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as mtri\n\n# Create triangulation.\nx = np.asarray([0, 1, 2, 3, 0.5, 1.5, 2.5, 1, 2, 1.5])\ny = np.asarray([0, 0, 0, 0, 1.0, 1.0, 1.0, 2, 2, 3.0])\ntriangles = [[0, 1, 4], [1, 2, 5], [2, 3, 6], [1, 5, 4], [2, 6, 5], [4, 5, 7],\n             [5, 6, 8], [5, 8, 7], [7, 8, 9]]\ntriang = mtri.Triangulation(x, y, triangles)\n\n# Interpolate to regularly-spaced quad grid.\nz = np.cos(1.5 * x) * np.cos(1.5 * y)\nxi, yi = np.meshgrid(np.linspace(0, 3, 20), np.linspace(0, 3, 20))\n\ninterp_lin = mtri.LinearTriInterpolator(triang, z)\nzi_lin = interp_lin(xi, yi)\n\ninterp_cubic_geom = mtri.CubicTriInterpolator(triang, z, kind='geom')\nzi_cubic_geom = interp_cubic_geom(xi, yi)\n\ninterp_cubic_min_E = mtri.CubicTriInterpolator(triang, z, kind='min_E')\nzi_cubic_min_E = interp_cubic_min_E(xi, yi)\n\n# Set up the figure\nfig, axs = plt.subplots(nrows=2, ncols=2)\naxs = axs.flatten()\n\n# Plot the triangulation.\naxs[0].tricontourf(triang, z)\naxs[0].triplot(triang, 'ko-')\naxs[0].set_title('Triangular grid')\n\n# Plot linear interpolation to quad grid.\naxs[1].contourf(xi, yi, zi_lin)\naxs[1].plot(xi, yi, 'k-', lw=0.5, alpha=0.5)\naxs[1].plot(xi.T, yi.T, 'k-', lw=0.5, alpha=0.5)\naxs[1].set_title(\"Linear interpolation\")\n\n# Plot cubic interpolation to quad grid, kind=geom\naxs[2].contourf(xi, yi, zi_cubic_geom)\naxs[2].plot(xi, yi, 'k-', lw=0.5, alpha=0.5)\naxs[2].plot(xi.T, yi.T, 'k-', lw=0.5, alpha=0.5)\naxs[2].set_title(\"Cubic interpolation,\\nkind='geom'\")\n\n# Plot cubic interpolation to quad grid, kind=min_E\naxs[3].contourf(xi, yi, zi_cubic_min_E)\naxs[3].plot(xi, yi, 'k-', lw=0.5, alpha=0.5)\naxs[3].plot(xi.T, yi.T, 'k-', lw=0.5, alpha=0.5)\naxs[3].set_title(\"Cubic interpolation,\\nkind='min_E'\")\n\nfig.tight_layout()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.tricontourf` / `matplotlib.pyplot.tricontourf`\n#    - `matplotlib.axes.Axes.triplot` / `matplotlib.pyplot.triplot`\n#    - `matplotlib.axes.Axes.contourf` / `matplotlib.pyplot.contourf`\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`\n#    - `matplotlib.tri`\n#    - `matplotlib.tri.LinearTriInterpolator`\n#    - `matplotlib.tri.CubicTriInterpolator`\n#    - `matplotlib.tri.Triangulation`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_088_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============\nTripcolor Demo\n==============\n\nPseudocolor plots of unstructured triangular grids.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\n# %%\n# Creating a Triangulation without specifying the triangles results in the\n# Delaunay triangulation of the points.\n\n# First create the x and y coordinates of the points.\nn_angles = 36\nn_radii = 8\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii * np.cos(angles)).flatten()\ny = (radii * np.sin(angles)).flatten()\nz = (np.cos(radii) * np.cos(3 * angles)).flatten()\n\n# Create the Triangulation; no triangles so Delaunay triangulation created.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# %%\n# tripcolor plot.\n\nfig1, ax1 = plt.subplots()\nax1.set_aspect('equal')\ntpc = ax1.tripcolor(triang, z, shading='flat')\nfig1.colorbar(tpc)\nax1.set_title('tripcolor of Delaunay triangulation, flat shading')\n\n# %%\n# Illustrate Gouraud shading.\n\nfig2, ax2 = plt.subplots()\nax2.set_aspect('equal')\ntpc = ax2.tripcolor(triang, z, shading='gouraud')\nfig2.colorbar(tpc)\nax2.set_title('tripcolor of Delaunay triangulation, gouraud shading')\n\n\n# %%\n# You can specify your own triangulation rather than perform a Delaunay\n# triangulation of the points, where each triangle is given by the indices of\n# the three points that make up the triangle, ordered in either a clockwise or\n# anticlockwise manner.\n\nxy = np.asarray([\n    [-0.101, 0.872], [-0.080, 0.883], [-0.069, 0.888], [-0.054, 0.890],\n    [-0.045, 0.897], [-0.057, 0.895], [-0.073, 0.900], [-0.087, 0.898],\n    [-0.090, 0.904], [-0.069, 0.907], [-0.069, 0.921], [-0.080, 0.919],\n    [-0.073, 0.928], [-0.052, 0.930], [-0.048, 0.942], [-0.062, 0.949],\n    [-0.054, 0.958], [-0.069, 0.954], [-0.087, 0.952], [-0.087, 0.959],\n    [-0.080, 0.966], [-0.085, 0.973], [-0.087, 0.965], [-0.097, 0.965],\n    [-0.097, 0.975], [-0.092, 0.984], [-0.101, 0.980], [-0.108, 0.980],\n    [-0.104, 0.987], [-0.102, 0.993], [-0.115, 1.001], [-0.099, 0.996],\n    [-0.101, 1.007], [-0.090, 1.010], [-0.087, 1.021], [-0.069, 1.021],\n    [-0.052, 1.022], [-0.052, 1.017], [-0.069, 1.010], [-0.064, 1.005],\n    [-0.048, 1.005], [-0.031, 1.005], [-0.031, 0.996], [-0.040, 0.987],\n    [-0.045, 0.980], [-0.052, 0.975], [-0.040, 0.973], [-0.026, 0.968],\n    [-0.020, 0.954], [-0.006, 0.947], [ 0.003, 0.935], [ 0.006, 0.926],\n    [ 0.005, 0.921], [ 0.022, 0.923], [ 0.033, 0.912], [ 0.029, 0.905],\n    [ 0.017, 0.900], [ 0.012, 0.895], [ 0.027, 0.893], [ 0.019, 0.886],\n    [ 0.001, 0.883], [-0.012, 0.884], [-0.029, 0.883], [-0.038, 0.879],\n    [-0.057, 0.881], [-0.062, 0.876], [-0.078, 0.876], [-0.087, 0.872],\n    [-0.030, 0.907], [-0.007, 0.905], [-0.057, 0.916], [-0.025, 0.933],\n    [-0.077, 0.990], [-0.059, 0.993]])\nx, y = np.rad2deg(xy).T\n\ntriangles = np.asarray([\n    [67, 66,  1], [65,  2, 66], [ 1, 66,  2], [64,  2, 65], [63,  3, 64],\n    [60, 59, 57], [ 2, 64,  3], [ 3, 63,  4], [ 0, 67,  1], [62,  4, 63],\n    [57, 59, 56], [59, 58, 56], [61, 60, 69], [57, 69, 60], [ 4, 62, 68],\n    [ 6,  5,  9], [61, 68, 62], [69, 68, 61], [ 9,  5, 70], [ 6,  8,  7],\n    [ 4, 70,  5], [ 8,  6,  9], [56, 69, 57], [69, 56, 52], [70, 10,  9],\n    [54, 53, 55], [56, 55, 53], [68, 70,  4], [52, 56, 53], [11, 10, 12],\n    [69, 71, 68], [68, 13, 70], [10, 70, 13], [51, 50, 52], [13, 68, 71],\n    [52, 71, 69], [12, 10, 13], [71, 52, 50], [71, 14, 13], [50, 49, 71],\n    [49, 48, 71], [14, 16, 15], [14, 71, 48], [17, 19, 18], [17, 20, 19],\n    [48, 16, 14], [48, 47, 16], [47, 46, 16], [16, 46, 45], [23, 22, 24],\n    [21, 24, 22], [17, 16, 45], [20, 17, 45], [21, 25, 24], [27, 26, 28],\n    [20, 72, 21], [25, 21, 72], [45, 72, 20], [25, 28, 26], [44, 73, 45],\n    [72, 45, 73], [28, 25, 29], [29, 25, 31], [43, 73, 44], [73, 43, 40],\n    [72, 73, 39], [72, 31, 25], [42, 40, 43], [31, 30, 29], [39, 73, 40],\n    [42, 41, 40], [72, 33, 31], [32, 31, 33], [39, 38, 72], [33, 72, 38],\n    [33, 38, 34], [37, 35, 38], [34, 38, 35], [35, 37, 36]])\n\nxmid = x[triangles].mean(axis=1)\nymid = y[triangles].mean(axis=1)\nx0 = -5\ny0 = 52\nzfaces = np.exp(-0.01 * ((xmid - x0) * (xmid - x0) +\n                         (ymid - y0) * (ymid - y0)))\n\n# %%\n# Rather than create a Triangulation object, can simply pass x, y and triangles\n# arrays to tripcolor directly.  It would be better to use a Triangulation\n# object if the same triangulation was to be used more than once to save\n# duplicated calculations.\n# Can specify one color value per face rather than one per point by using the\n# *facecolors* keyword argument.\n\nfig3, ax3 = plt.subplots()\nax3.set_aspect('equal')\ntpc = ax3.tripcolor(x, y, triangles, facecolors=zfaces, edgecolors='k')\nfig3.colorbar(tpc)\nax3.set_title('tripcolor of user-specified triangulation')\nax3.set_xlabel('Longitude (degrees)')\nax3.set_ylabel('Latitude (degrees)')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.tripcolor` / `matplotlib.pyplot.tripcolor`\n#    - `matplotlib.tri`\n#    - `matplotlib.tri.Triangulation`"
      },
      {
        "image_path": "gallery_assets/02images_contours_and_fields_089_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============\nTriplot Demo\n============\n\nCreating and plotting unstructured triangular grids.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\n# %%\n# Creating a Triangulation without specifying the triangles results in the\n# Delaunay triangulation of the points.\n\n# First create the x and y coordinates of the points.\nn_angles = 36\nn_radii = 8\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii * np.cos(angles)).flatten()\ny = (radii * np.sin(angles)).flatten()\n\n# Create the Triangulation; no triangles so Delaunay triangulation created.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# %%\n# Plot the triangulation.\n\nfig1, ax1 = plt.subplots()\nax1.set_aspect('equal')\nax1.triplot(triang, 'bo-', lw=1)\nax1.set_title('triplot of Delaunay triangulation')\n\n\n# %%\n# You can specify your own triangulation rather than perform a Delaunay\n# triangulation of the points, where each triangle is given by the indices of\n# the three points that make up the triangle, ordered in either a clockwise or\n# anticlockwise manner.\n\nxy = np.asarray([\n    [-0.101, 0.872], [-0.080, 0.883], [-0.069, 0.888], [-0.054, 0.890],\n    [-0.045, 0.897], [-0.057, 0.895], [-0.073, 0.900], [-0.087, 0.898],\n    [-0.090, 0.904], [-0.069, 0.907], [-0.069, 0.921], [-0.080, 0.919],\n    [-0.073, 0.928], [-0.052, 0.930], [-0.048, 0.942], [-0.062, 0.949],\n    [-0.054, 0.958], [-0.069, 0.954], [-0.087, 0.952], [-0.087, 0.959],\n    [-0.080, 0.966], [-0.085, 0.973], [-0.087, 0.965], [-0.097, 0.965],\n    [-0.097, 0.975], [-0.092, 0.984], [-0.101, 0.980], [-0.108, 0.980],\n    [-0.104, 0.987], [-0.102, 0.993], [-0.115, 1.001], [-0.099, 0.996],\n    [-0.101, 1.007], [-0.090, 1.010], [-0.087, 1.021], [-0.069, 1.021],\n    [-0.052, 1.022], [-0.052, 1.017], [-0.069, 1.010], [-0.064, 1.005],\n    [-0.048, 1.005], [-0.031, 1.005], [-0.031, 0.996], [-0.040, 0.987],\n    [-0.045, 0.980], [-0.052, 0.975], [-0.040, 0.973], [-0.026, 0.968],\n    [-0.020, 0.954], [-0.006, 0.947], [ 0.003, 0.935], [ 0.006, 0.926],\n    [ 0.005, 0.921], [ 0.022, 0.923], [ 0.033, 0.912], [ 0.029, 0.905],\n    [ 0.017, 0.900], [ 0.012, 0.895], [ 0.027, 0.893], [ 0.019, 0.886],\n    [ 0.001, 0.883], [-0.012, 0.884], [-0.029, 0.883], [-0.038, 0.879],\n    [-0.057, 0.881], [-0.062, 0.876], [-0.078, 0.876], [-0.087, 0.872],\n    [-0.030, 0.907], [-0.007, 0.905], [-0.057, 0.916], [-0.025, 0.933],\n    [-0.077, 0.990], [-0.059, 0.993]])\nx = np.degrees(xy[:, 0])\ny = np.degrees(xy[:, 1])\n\ntriangles = np.asarray([\n    [67, 66,  1], [65,  2, 66], [ 1, 66,  2], [64,  2, 65], [63,  3, 64],\n    [60, 59, 57], [ 2, 64,  3], [ 3, 63,  4], [ 0, 67,  1], [62,  4, 63],\n    [57, 59, 56], [59, 58, 56], [61, 60, 69], [57, 69, 60], [ 4, 62, 68],\n    [ 6,  5,  9], [61, 68, 62], [69, 68, 61], [ 9,  5, 70], [ 6,  8,  7],\n    [ 4, 70,  5], [ 8,  6,  9], [56, 69, 57], [69, 56, 52], [70, 10,  9],\n    [54, 53, 55], [56, 55, 53], [68, 70,  4], [52, 56, 53], [11, 10, 12],\n    [69, 71, 68], [68, 13, 70], [10, 70, 13], [51, 50, 52], [13, 68, 71],\n    [52, 71, 69], [12, 10, 13], [71, 52, 50], [71, 14, 13], [50, 49, 71],\n    [49, 48, 71], [14, 16, 15], [14, 71, 48], [17, 19, 18], [17, 20, 19],\n    [48, 16, 14], [48, 47, 16], [47, 46, 16], [16, 46, 45], [23, 22, 24],\n    [21, 24, 22], [17, 16, 45], [20, 17, 45], [21, 25, 24], [27, 26, 28],\n    [20, 72, 21], [25, 21, 72], [45, 72, 20], [25, 28, 26], [44, 73, 45],\n    [72, 45, 73], [28, 25, 29], [29, 25, 31], [43, 73, 44], [73, 43, 40],\n    [72, 73, 39], [72, 31, 25], [42, 40, 43], [31, 30, 29], [39, 73, 40],\n    [42, 41, 40], [72, 33, 31], [32, 31, 33], [39, 38, 72], [33, 72, 38],\n    [33, 38, 34], [37, 35, 38], [34, 38, 35], [35, 37, 36]])\n\n# %%\n# Rather than create a Triangulation object, can simply pass x, y and triangles\n# arrays to triplot directly.  It would be better to use a Triangulation object\n# if the same triangulation was to be used more than once to save duplicated\n# calculations.\n\nfig2, ax2 = plt.subplots()\nax2.set_aspect('equal')\nax2.triplot(x, y, triangles, 'go-', lw=1.0)\nax2.set_title('triplot of user-specified triangulation')\nax2.set_xlabel('Longitude (degrees)')\nax2.set_ylabel('Latitude (degrees)')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.triplot` / `matplotlib.pyplot.triplot`\n#    - `matplotlib.tri`\n#    - `matplotlib.tri.Triangulation`"
      }
    ],
    "03subplots_axes_and_figures": [
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_090_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============\nAligning Labels\n===============\n\nAligning xlabel and ylabel using `.Figure.align_xlabels` and\n`.Figure.align_ylabels`\n\n`.Figure.align_labels` wraps these two functions.\n\nNote that the xlabel \"XLabel1 1\" would normally be much closer to the\nx-axis, and \"YLabel1 0\" would be much closer to the y-axis of their\nrespective axes.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.gridspec as gridspec\n\nfig = plt.figure(tight_layout=True)\ngs = gridspec.GridSpec(2, 2)\n\nax = fig.add_subplot(gs[0, :])\nax.plot(np.arange(0, 1e6, 1000))\nax.set_ylabel('YLabel0')\nax.set_xlabel('XLabel0')\n\nfor i in range(2):\n    ax = fig.add_subplot(gs[1, i])\n    ax.plot(np.arange(1., 0., -0.1) * 2000., np.arange(1., 0., -0.1))\n    ax.set_ylabel('YLabel1 %d' % i)\n    ax.set_xlabel('XLabel1 %d' % i)\n    if i == 0:\n        ax.tick_params(axis='x', rotation=55)\nfig.align_labels()  # same as fig.align_xlabels(); fig.align_ylabels()\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_091_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============================================\nProgrammatically controlling subplot adjustment\n===============================================\n\n.. note::\n\n    This example is primarily intended to show some advanced concepts in\n    Matplotlib.\n\n    If you are only looking for having enough space for your labels, it is\n    almost always simpler and good enough to either set the subplot parameters\n    manually using `.Figure.subplots_adjust`, or use one of the automatic\n    layout mechanisms\n    (:ref:`constrainedlayout_guide` or\n    :ref:`tight_layout_guide`).\n\nThis example describes a user-defined way to read out Artist sizes and\nset the subplot parameters accordingly. Its main purpose is to illustrate\nsome advanced concepts like reading out text positions, working with\nbounding boxes and transforms and using\n:ref:`events <event-handling>`. But it can also serve as a starting\npoint if you want to automate the layouting and need more flexibility than\ntight layout and constrained layout.\n\nBelow, we collect the bounding boxes of all y-labels and move the left border\nof the subplot to the right so that it leaves enough room for the union of all\nthe bounding boxes.\n\nThere's one catch with calculating text bounding boxes:\nQuerying the text bounding boxes (`.Text.get_window_extent`) needs a\nrenderer (`.RendererBase` instance), to calculate the text size. This renderer\nis only available after the figure has been drawn (`.Figure.draw`).\n\nA solution to this is putting the adjustment logic in a draw callback.\nThis function is executed after the figure has been drawn. It can now check\nif the subplot leaves enough room for the text. If not, the subplot parameters\nare updated and second draw is triggered.\n\n.. redirect-from:: /gallery/pyplots/auto_subplots_adjust\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.transforms as mtransforms\n\nfig, ax = plt.subplots()\nax.plot(range(10))\nax.set_yticks([2, 5, 7], labels=['really, really, really', 'long', 'labels'])\n\n\ndef on_draw(event):\n    bboxes = []\n    for label in ax.get_yticklabels():\n        # Bounding box in pixels\n        bbox_px = label.get_window_extent()\n        # Transform to relative figure coordinates. This is the inverse of\n        # transFigure.\n        bbox_fig = bbox_px.transformed(fig.transFigure.inverted())\n        bboxes.append(bbox_fig)\n    # the bbox that bounds all the bboxes, again in relative figure coords\n    bbox = mtransforms.Bbox.union(bboxes)\n    if fig.subplotpars.left < bbox.width:\n        # Move the subplot left edge more to the right\n        fig.subplots_adjust(left=1.1*bbox.width)  # pad a little\n        fig.canvas.draw()\n\n\nfig.canvas.mpl_connect('draw_event', on_draw)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.artist.Artist.get_window_extent`\n#    - `matplotlib.transforms.Bbox`\n#    - `matplotlib.transforms.BboxBase.transformed`\n#    - `matplotlib.transforms.BboxBase.union`\n#    - `matplotlib.transforms.Transform.inverted`\n#    - `matplotlib.figure.Figure.subplots_adjust`\n#    - `matplotlib.figure.SubplotParams`\n#    - `matplotlib.backend_bases.FigureCanvasBase.mpl_connect`"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_092_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============\nAxes box aspect\n===============\n\nThis demo shows how to set the aspect of an Axes box directly via\n`~.Axes.set_box_aspect`. The box aspect is the ratio between axes height\nand axes width in physical units, independent of the data limits.\nThis is useful to e.g. produce a square plot, independent of the data it\ncontains, or to have a usual plot with the same axes dimensions next to\nan image plot with fixed (data-)aspect.\n\nThe following lists a few use cases for `~.Axes.set_box_aspect`.\n\"\"\"\n\n# %%\n# A square axes, independent of data\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#\n# Produce a square axes, no matter what the data limits are.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig1, ax = plt.subplots()\n\nax.set_xlim(300, 400)\nax.set_box_aspect(1)\n\nplt.show()\n\n# %%\n# Shared square axes\n# ~~~~~~~~~~~~~~~~~~\n#\n# Produce shared subplots that are squared in size.\n#\nfig2, (ax, ax2) = plt.subplots(ncols=2, sharey=True)\n\nax.plot([1, 5], [0, 10])\nax2.plot([100, 500], [10, 15])\n\nax.set_box_aspect(1)\nax2.set_box_aspect(1)\n\nplt.show()\n\n# %%\n# Square twin axes\n# ~~~~~~~~~~~~~~~~\n#\n# Produce a square axes, with a twin axes. The twinned axes takes over the\n# box aspect of the parent.\n#\n\nfig3, ax = plt.subplots()\n\nax2 = ax.twinx()\n\nax.plot([0, 10])\nax2.plot([12, 10])\n\nax.set_box_aspect(1)\n\nplt.show()\n\n\n# %%\n# Normal plot next to image\n# ~~~~~~~~~~~~~~~~~~~~~~~~~\n#\n# When creating an image plot with fixed data aspect and the default\n# ``adjustable=\"box\"`` next to a normal plot, the axes would be unequal in\n# height. `~.Axes.set_box_aspect` provides an easy solution to that by allowing\n# to have the normal plot's axes use the images dimensions as box aspect.\n#\n# This example also shows that *constrained layout* interplays nicely with\n# a fixed box aspect.\n\nfig4, (ax, ax2) = plt.subplots(ncols=2, layout=\"constrained\")\n\nnp.random.seed(19680801)  # Fixing random state for reproducibility\nim = np.random.rand(16, 27)\nax.imshow(im)\n\nax2.plot([23, 45])\nax2.set_box_aspect(im.shape[0]/im.shape[1])\n\nplt.show()\n\n# %%\n# Square joint/marginal plot\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~\n#\n# It may be desirable to show marginal distributions next to a plot of joint\n# data. The following creates a square plot with the box aspect of the\n# marginal axes being equal to the width- and height-ratios of the gridspec.\n# This ensures that all axes align perfectly, independent on the size of the\n# figure.\n\nfig5, axs = plt.subplots(2, 2, sharex=\"col\", sharey=\"row\",\n                         gridspec_kw=dict(height_ratios=[1, 3],\n                                          width_ratios=[3, 1]))\naxs[0, 1].set_visible(False)\naxs[0, 0].set_box_aspect(1/3)\naxs[1, 0].set_box_aspect(1)\naxs[1, 1].set_box_aspect(3/1)\n\nnp.random.seed(19680801)  # Fixing random state for reproducibility\nx, y = np.random.randn(2, 400) * [[.5], [180]]\naxs[1, 0].scatter(x, y)\naxs[0, 0].hist(x)\naxs[1, 1].hist(y, orientation=\"horizontal\")\n\nplt.show()\n\n# %%\n# Square joint/marginal plot\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~\n#\n# When setting the box aspect, one may still set the data aspect as well.\n# Here we create an Axes with a box twice as long as tall and use an \"equal\"\n# data aspect for its contents, i.e. the circle actually stays circular.\n\nfig6, ax = plt.subplots()\n\nax.add_patch(plt.Circle((5, 3), 1))\nax.set_aspect(\"equal\", adjustable=\"datalim\")\nax.set_box_aspect(0.5)\nax.autoscale()\n\nplt.show()\n\n# %%\n# Box aspect for many subplots\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#\n# It is possible to pass the box aspect to an Axes at initialization. The\n# following creates a 2 by 3 subplot grid with all square Axes.\n\nfig7, axs = plt.subplots(2, 3, subplot_kw=dict(box_aspect=1),\n                         sharex=True, sharey=True, layout=\"constrained\")\n\nfor i, ax in enumerate(axs.flat):\n    ax.scatter(i % 3, -((i // 3) - 0.5)*200, c=[plt.cm.hsv(i / 6)], s=300)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.set_box_aspect`"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_093_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========\nAxes Demo\n=========\n\nExample use of ``fig.add_axes`` to create inset axes within the main plot axes.\n\nPlease see also the :ref:`axes_grid_examples` section, and the following three\nexamples:\n\n- :doc:`/gallery/subplots_axes_and_figures/zoom_inset_axes`\n- :doc:`/gallery/axes_grid1/inset_locator_demo`\n- :doc:`/gallery/axes_grid1/inset_locator_demo2`\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)  # Fixing random state for reproducibility.\n\n# create some data to use for the plot\ndt = 0.001\nt = np.arange(0.0, 10.0, dt)\nr = np.exp(-t[:1000] / 0.05)  # impulse response\nx = np.random.randn(len(t))\ns = np.convolve(x, r)[:len(x)] * dt  # colored noise\n\nfig, main_ax = plt.subplots()\nmain_ax.plot(t, s)\nmain_ax.set_xlim(0, 1)\nmain_ax.set_ylim(1.1 * np.min(s), 2 * np.max(s))\nmain_ax.set_xlabel('time (s)')\nmain_ax.set_ylabel('current (nA)')\nmain_ax.set_title('Gaussian colored noise')\n\n# this is an inset axes over the main axes\nright_inset_ax = fig.add_axes([.65, .6, .2, .2], facecolor='k')\nright_inset_ax.hist(s, 400, density=True)\nright_inset_ax.set(title='Probability', xticks=[], yticks=[])\n\n# this is another inset axes over the main axes\nleft_inset_ax = fig.add_axes([.2, .6, .2, .2], facecolor='k')\nleft_inset_ax.plot(t[:len(r)], r)\nleft_inset_ax.set(title='Impulse response', xlim=(0, .2), xticks=[], yticks=[])\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_094_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n======================================================\nControlling view limits using margins and sticky_edges\n======================================================\n\nThe first figure in this example shows how to zoom in and out of a\nplot using `~.Axes.margins` instead of `~.Axes.set_xlim` and\n`~.Axes.set_ylim`. The second figure demonstrates the concept of\nedge \"stickiness\" introduced by certain methods and artists and how\nto effectively work around that.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Polygon\n\n\ndef f(t):\n    return np.exp(-t) * np.cos(2*np.pi*t)\n\n\nt1 = np.arange(0.0, 3.0, 0.01)\n\nax1 = plt.subplot(212)\nax1.margins(0.05)           # Default margin is 0.05, value 0 means fit\nax1.plot(t1, f(t1))\n\nax2 = plt.subplot(221)\nax2.margins(2, 2)           # Values >0.0 zoom out\nax2.plot(t1, f(t1))\nax2.set_title('Zoomed out')\n\nax3 = plt.subplot(222)\nax3.margins(x=0, y=-0.25)   # Values in (-0.5, 0.0) zooms in to center\nax3.plot(t1, f(t1))\nax3.set_title('Zoomed in')\n\nplt.show()\n\n\n# %%\n#\n# On the \"stickiness\" of certain plotting methods\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# Some plotting functions make the axis limits \"sticky\" or immune to the will\n# of the `~.Axes.margins` methods. For instance, `~.Axes.imshow` and\n# `~.Axes.pcolor` expect the user to want the limits to be tight around the\n# pixels shown in the plot. If this behavior is not desired, you need to set\n# `~.Axes.use_sticky_edges` to `False`. Consider the following example:\n\ny, x = np.mgrid[:5, 1:6]\npoly_coords = [\n    (0.25, 2.75), (3.25, 2.75),\n    (2.25, 0.75), (0.25, 0.75)\n]\nfig, (ax1, ax2) = plt.subplots(ncols=2)\n\n# Here we set the stickiness of the axes object...\n# ax1 we'll leave as the default, which uses sticky edges\n# and we'll turn off stickiness for ax2\nax2.use_sticky_edges = False\n\nfor ax, status in zip((ax1, ax2), ('Is', 'Is Not')):\n    cells = ax.pcolor(x, y, x+y, cmap='inferno', shading='auto')  # sticky\n    ax.add_patch(\n        Polygon(poly_coords, color='forestgreen', alpha=0.5)\n    )  # not sticky\n    ax.margins(x=0.1, y=0.05)\n    ax.set_aspect('equal')\n    ax.set_title(f'{status} Sticky')\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.margins` / `matplotlib.pyplot.margins`\n#    - `matplotlib.axes.Axes.use_sticky_edges`\n#    - `matplotlib.axes.Axes.pcolor` / `matplotlib.pyplot.pcolor`\n#    - `matplotlib.patches.Polygon`"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_095_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========\nAxes Props\n==========\n\nYou can control the axis tick and grid properties\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\ns = np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\nax.grid(True, linestyle='-.')\nax.tick_params(labelcolor='r', labelsize='medium', width=3)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_096_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nAxes Zoom Effect\n================\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.transforms import (Bbox, TransformedBbox,\n                                   blended_transform_factory)\nfrom mpl_toolkits.axes_grid1.inset_locator import (BboxConnector,\n                                                   BboxConnectorPatch,\n                                                   BboxPatch)\n\n\ndef connect_bbox(bbox1, bbox2,\n                 loc1a, loc2a, loc1b, loc2b,\n                 prop_lines, prop_patches=None):\n    if prop_patches is None:\n        prop_patches = {\n            **prop_lines,\n            \"alpha\": prop_lines.get(\"alpha\", 1) * 0.2,\n            \"clip_on\": False,\n        }\n\n    c1 = BboxConnector(\n        bbox1, bbox2, loc1=loc1a, loc2=loc2a, clip_on=False, **prop_lines)\n    c2 = BboxConnector(\n        bbox1, bbox2, loc1=loc1b, loc2=loc2b, clip_on=False, **prop_lines)\n\n    bbox_patch1 = BboxPatch(bbox1, **prop_patches)\n    bbox_patch2 = BboxPatch(bbox2, **prop_patches)\n\n    p = BboxConnectorPatch(bbox1, bbox2,\n                           loc1a=loc1a, loc2a=loc2a, loc1b=loc1b, loc2b=loc2b,\n                           clip_on=False,\n                           **prop_patches)\n\n    return c1, c2, bbox_patch1, bbox_patch2, p\n\n\ndef zoom_effect01(ax1, ax2, xmin, xmax, **kwargs):\n    \"\"\"\n    Connect *ax1* and *ax2*. The *xmin*-to-*xmax* range in both axes will\n    be marked.\n\n    Parameters\n    ----------\n    ax1\n        The main axes.\n    ax2\n        The zoomed axes.\n    xmin, xmax\n        The limits of the colored area in both plot axes.\n    **kwargs\n        Arguments passed to the patch constructor.\n    \"\"\"\n\n    bbox = Bbox.from_extents(xmin, 0, xmax, 1)\n\n    mybbox1 = TransformedBbox(bbox, ax1.get_xaxis_transform())\n    mybbox2 = TransformedBbox(bbox, ax2.get_xaxis_transform())\n\n    prop_patches = {**kwargs, \"ec\": \"none\", \"alpha\": 0.2}\n\n    c1, c2, bbox_patch1, bbox_patch2, p = connect_bbox(\n        mybbox1, mybbox2,\n        loc1a=3, loc2a=2, loc1b=4, loc2b=1,\n        prop_lines=kwargs, prop_patches=prop_patches)\n\n    ax1.add_patch(bbox_patch1)\n    ax2.add_patch(bbox_patch2)\n    ax2.add_patch(c1)\n    ax2.add_patch(c2)\n    ax2.add_patch(p)\n\n    return c1, c2, bbox_patch1, bbox_patch2, p\n\n\ndef zoom_effect02(ax1, ax2, **kwargs):\n    \"\"\"\n    ax1 : the main axes\n    ax1 : the zoomed axes\n\n    Similar to zoom_effect01.  The xmin & xmax will be taken from the\n    ax1.viewLim.\n    \"\"\"\n\n    tt = ax1.transScale + (ax1.transLimits + ax2.transAxes)\n    trans = blended_transform_factory(ax2.transData, tt)\n\n    mybbox1 = ax1.bbox\n    mybbox2 = TransformedBbox(ax1.viewLim, trans)\n\n    prop_patches = {**kwargs, \"ec\": \"none\", \"alpha\": 0.2}\n\n    c1, c2, bbox_patch1, bbox_patch2, p = connect_bbox(\n        mybbox1, mybbox2,\n        loc1a=3, loc2a=2, loc1b=4, loc2b=1,\n        prop_lines=kwargs, prop_patches=prop_patches)\n\n    ax1.add_patch(bbox_patch1)\n    ax2.add_patch(bbox_patch2)\n    ax2.add_patch(c1)\n    ax2.add_patch(c2)\n    ax2.add_patch(p)\n\n    return c1, c2, bbox_patch1, bbox_patch2, p\n\n\naxs = plt.figure().subplot_mosaic([\n    [\"zoom1\", \"zoom2\"],\n    [\"main\", \"main\"],\n])\n\naxs[\"main\"].set(xlim=(0, 5))\nzoom_effect01(axs[\"zoom1\"], axs[\"main\"], 0.2, 0.8)\naxs[\"zoom2\"].set(xlim=(2, 3))\nzoom_effect02(axs[\"zoom2\"], axs[\"main\"])\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_097_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============\naxhspan Demo\n============\n\nCreate lines or rectangles that span the axes in either the horizontal or\nvertical direction, and lines than span the axes with an arbitrary orientation.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(-1, 2, .01)\ns = np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots()\n\nax.plot(t, s)\n# Thick red horizontal line at y=0 that spans the xrange.\nax.axhline(linewidth=8, color='#d62728')\n# Horizontal line at y=1 that spans the xrange.\nax.axhline(y=1)\n# Vertical line at x=1 that spans the yrange.\nax.axvline(x=1)\n# Thick blue vertical line at x=0 that spans the upper quadrant of the yrange.\nax.axvline(x=0, ymin=0.75, linewidth=8, color='#1f77b4')\n# Default hline at y=.5 that spans the middle half of the axes.\nax.axhline(y=.5, xmin=0.25, xmax=0.75)\n# Infinite black line going through (0, 0) to (1, 1).\nax.axline((0, 0), (1, 1), color='k')\n# 50%-gray rectangle spanning the axes' width from y=0.25 to y=0.75.\nax.axhspan(0.25, 0.75, facecolor='0.5')\n# Green rectangle spanning the axes' height from x=1.25 to x=1.55.\nax.axvspan(1.25, 1.55, facecolor='#2ca02c')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_098_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======================\nEqual axis aspect ratio\n=======================\n\nHow to set and adjust plots with equal axis aspect ratios.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Plot circle of radius 3.\n\nan = np.linspace(0, 2 * np.pi, 100)\nfig, axs = plt.subplots(2, 2)\n\naxs[0, 0].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[0, 0].set_title('not equal, looks like ellipse', fontsize=10)\n\naxs[0, 1].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[0, 1].axis('equal')\naxs[0, 1].set_title('equal, looks like circle', fontsize=10)\n\naxs[1, 0].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[1, 0].axis('equal')\naxs[1, 0].set(xlim=(-3, 3), ylim=(-3, 3))\naxs[1, 0].set_title('still a circle, even after changing limits', fontsize=10)\n\naxs[1, 1].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[1, 1].set_aspect('equal', 'box')\naxs[1, 1].set_title('still a circle, auto-adjusted data limits', fontsize=10)\n\nfig.tight_layout()\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_099_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===================\nAxis Label Position\n===================\n\nChoose axis label position when calling `~.Axes.set_xlabel` and\n`~.Axes.set_ylabel` as well as for colorbar.\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nsc = ax.scatter([1, 2], [1, 2], c=[1, 2])\nax.set_ylabel('YLabel', loc='top')\nax.set_xlabel('XLabel', loc='left')\ncbar = fig.colorbar(sc)\ncbar.set_label(\"ZLabel\", loc='top')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_100_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========\nBroken Axis\n===========\n\nBroken axis example, where the y-axis will have a portion cut out.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\npts = np.random.rand(30)*.2\n# Now let's make two outlier points which are far away from everything.\npts[[3, 14]] += .8\n\n# If we were to simply plot pts, we'd lose most of the interesting\n# details due to the outliers. So let's 'break' or 'cut-out' the y-axis\n# into two portions - use the top (ax1) for the outliers, and the bottom\n# (ax2) for the details of the majority of our data\nfig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\nfig.subplots_adjust(hspace=0.05)  # adjust space between axes\n\n# plot the same data on both axes\nax1.plot(pts)\nax2.plot(pts)\n\n# zoom-in / limit the view to different portions of the data\nax1.set_ylim(.78, 1.)  # outliers only\nax2.set_ylim(0, .22)  # most of the data\n\n# hide the spines between ax and ax2\nax1.spines.bottom.set_visible(False)\nax2.spines.top.set_visible(False)\nax1.xaxis.tick_top()\nax1.tick_params(labeltop=False)  # don't put tick labels at the top\nax2.xaxis.tick_bottom()\n\n# Now, let's turn towards the cut-out slanted lines.\n# We create line objects in axes coordinates, in which (0,0), (0,1),\n# (1,0), and (1,1) are the four corners of the axes.\n# The slanted lines themselves are markers at those locations, such that the\n# lines keep their angle and position, independent of the axes size or scale\n# Finally, we need to disable clipping.\n\nd = .5  # proportion of vertical to horizontal extent of the slanted line\nkwargs = dict(marker=[(-1, -d), (1, d)], markersize=12,\n              linestyle=\"none\", color='k', mec='k', mew=1, clip_on=False)\nax1.plot([0, 1], [0, 0], transform=ax1.transAxes, **kwargs)\nax2.plot([0, 1], [1, 1], transform=ax2.transAxes, **kwargs)\n\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_101_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========================\nCustom Figure subclasses\n========================\n\nYou can pass a `.Figure` subclass to `.pyplot.figure` if you want to change\nthe default behavior of the figure.\n\nThis example defines a `.Figure` subclass ``WatermarkFigure`` that accepts an\nadditional parameter ``watermark`` to display a custom watermark text. The\nfigure is created using the ``FigureClass`` parameter of `.pyplot.figure`.\nThe additional ``watermark`` parameter is passed on to the subclass\nconstructor.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.figure import Figure\n\n\nclass WatermarkFigure(Figure):\n    \"\"\"A figure with a text watermark.\"\"\"\n\n    def __init__(self, *args, watermark=None, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        if watermark is not None:\n            bbox = dict(boxstyle='square', lw=3, ec='gray',\n                        fc=(0.9, 0.9, .9, .5), alpha=0.5)\n            self.text(0.5, 0.5, watermark,\n                      ha='center', va='center', rotation=30,\n                      fontsize=40, color='gray', alpha=0.5, bbox=bbox)\n\n\nx = np.linspace(-3, 3, 201)\ny = np.tanh(x) + 0.1 * np.cos(5 * x)\n\nplt.figure(FigureClass=WatermarkFigure, watermark='draft')\nplt.plot(x, y)\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.figure`\n#    - `matplotlib.figure.Figure`\n#    - `matplotlib.figure.Figure.text`"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_102_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=====================================\nResizing axes with constrained layout\n=====================================\n\n*Constrained layout* attempts to resize subplots in\na figure so that there are no overlaps between axes objects and labels\non the axes.\n\nSee :ref:`constrainedlayout_guide` for more details and\n:ref:`tight_layout_guide` for an alternative.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n\ndef example_plot(ax):\n    ax.plot([1, 2])\n    ax.set_xlabel('x-label', fontsize=12)\n    ax.set_ylabel('y-label', fontsize=12)\n    ax.set_title('Title', fontsize=14)\n\n\n# %%\n# If we don't use *constrained layout*, then labels overlap the axes\n\nfig, axs = plt.subplots(nrows=2, ncols=2, layout=None)\n\nfor ax in axs.flat:\n    example_plot(ax)\n\n# %%\n# adding ``layout='constrained'`` automatically adjusts.\n\nfig, axs = plt.subplots(nrows=2, ncols=2, layout='constrained')\n\nfor ax in axs.flat:\n    example_plot(ax)\n\n# %%\n# Below is a more complicated example using nested gridspecs.\n\nfig = plt.figure(layout='constrained')\n\nimport matplotlib.gridspec as gridspec\n\ngs0 = gridspec.GridSpec(1, 2, figure=fig)\n\ngs1 = gridspec.GridSpecFromSubplotSpec(3, 1, subplot_spec=gs0[0])\nfor n in range(3):\n    ax = fig.add_subplot(gs1[n])\n    example_plot(ax)\n\n\ngs2 = gridspec.GridSpecFromSubplotSpec(2, 1, subplot_spec=gs0[1])\nfor n in range(2):\n    ax = fig.add_subplot(gs2[n])\n    example_plot(ax)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.gridspec.GridSpec`\n#    - `matplotlib.gridspec.GridSpecFromSubplotSpec`"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_103_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============================\nResizing axes with tight layout\n===============================\n\n`~.Figure.tight_layout` attempts to resize subplots in a figure so that there\nare no overlaps between axes objects and labels on the axes.\n\nSee :ref:`tight_layout_guide` for more details and\n:ref:`constrainedlayout_guide` for an alternative.\n\n\"\"\"\n\nimport itertools\nimport warnings\n\nimport matplotlib.pyplot as plt\n\nfontsizes = itertools.cycle([8, 16, 24, 32])\n\n\ndef example_plot(ax):\n    ax.plot([1, 2])\n    ax.set_xlabel('x-label', fontsize=next(fontsizes))\n    ax.set_ylabel('y-label', fontsize=next(fontsizes))\n    ax.set_title('Title', fontsize=next(fontsizes))\n\n\n# %%\n\nfig, ax = plt.subplots()\nexample_plot(ax)\nfig.tight_layout()\n\n# %%\n\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(nrows=2, ncols=2)\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nexample_plot(ax4)\nfig.tight_layout()\n\n# %%\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1)\nexample_plot(ax1)\nexample_plot(ax2)\nfig.tight_layout()\n\n# %%\n\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2)\nexample_plot(ax1)\nexample_plot(ax2)\nfig.tight_layout()\n\n# %%\n\nfig, axs = plt.subplots(nrows=3, ncols=3)\nfor ax in axs.flat:\n    example_plot(ax)\nfig.tight_layout()\n\n# %%\n\nplt.figure()\nax1 = plt.subplot(221)\nax2 = plt.subplot(223)\nax3 = plt.subplot(122)\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nplt.tight_layout()\n\n# %%\n\nplt.figure()\nax1 = plt.subplot2grid((3, 3), (0, 0))\nax2 = plt.subplot2grid((3, 3), (0, 1), colspan=2)\nax3 = plt.subplot2grid((3, 3), (1, 0), colspan=2, rowspan=2)\nax4 = plt.subplot2grid((3, 3), (1, 2), rowspan=2)\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nexample_plot(ax4)\nplt.tight_layout()\n\n# %%\n\nfig = plt.figure()\n\ngs1 = fig.add_gridspec(3, 1)\nax1 = fig.add_subplot(gs1[0])\nax2 = fig.add_subplot(gs1[1])\nax3 = fig.add_subplot(gs1[2])\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\ngs1.tight_layout(fig, rect=[None, None, 0.45, None])\n\ngs2 = fig.add_gridspec(2, 1)\nax4 = fig.add_subplot(gs2[0])\nax5 = fig.add_subplot(gs2[1])\nexample_plot(ax4)\nexample_plot(ax5)\nwith warnings.catch_warnings():\n    # gs2.tight_layout cannot handle the subplots from the first gridspec\n    # (gs1), so it will raise a warning. We are going to match the gridspecs\n    # manually so we can filter the warning away.\n    warnings.simplefilter(\"ignore\", UserWarning)\n    gs2.tight_layout(fig, rect=[0.45, None, None, None])\n\n# now match the top and bottom of two gridspecs.\ntop = min(gs1.top, gs2.top)\nbottom = max(gs1.bottom, gs2.bottom)\n\ngs1.update(top=top, bottom=bottom)\ngs2.update(top=top, bottom=bottom)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.figure.Figure.tight_layout` /\n#      `matplotlib.pyplot.tight_layout`\n#    - `matplotlib.figure.Figure.add_gridspec`\n#    - `matplotlib.figure.Figure.add_subplot`\n#    - `matplotlib.pyplot.subplot2grid`"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_104_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================================\nDifferent scales on the same axes\n=================================\n\nDemo of how to display two scales on the left and right y-axis.\n\nThis example uses the Fahrenheit and Celsius scales.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef fahrenheit2celsius(temp):\n    \"\"\"\n    Returns temperature in Celsius given Fahrenheit temperature.\n    \"\"\"\n    return (5. / 9.) * (temp - 32)\n\n\ndef make_plot():\n\n    # Define a closure function to register as a callback\n    def convert_ax_c_to_celsius(ax_f):\n        \"\"\"\n        Update second axis according to first axis.\n        \"\"\"\n        y1, y2 = ax_f.get_ylim()\n        ax_c.set_ylim(fahrenheit2celsius(y1), fahrenheit2celsius(y2))\n        ax_c.figure.canvas.draw()\n\n    fig, ax_f = plt.subplots()\n    ax_c = ax_f.twinx()\n\n    # automatically update ylim of ax2 when ylim of ax1 changes.\n    ax_f.callbacks.connect(\"ylim_changed\", convert_ax_c_to_celsius)\n    ax_f.plot(np.linspace(-40, 120, 100))\n    ax_f.set_xlim(0, 100)\n\n    ax_f.set_title('Two scales: Fahrenheit and Celsius')\n    ax_f.set_ylabel('Fahrenheit')\n    ax_c.set_ylabel('Celsius')\n\n    plt.show()\n\nmake_plot()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_105_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============================\nFigure size in different units\n==============================\n\nThe native figure size unit in Matplotlib is inches, deriving from print\nindustry standards. However, users may need to specify their figures in other\nunits like centimeters or pixels. This example illustrates how to do this\nefficiently.\n\"\"\"\n\n# sphinx_gallery_thumbnail_number = 2\n\nimport matplotlib.pyplot as plt\n\ntext_kwargs = dict(ha='center', va='center', fontsize=28, color='C1')\n\n# %%\n# Figure size in inches (default)\n# -------------------------------\n#\nplt.subplots(figsize=(6, 2))\nplt.text(0.5, 0.5, '6 inches x 2 inches', **text_kwargs)\nplt.show()\n\n\n# %%\n# Figure size in centimeter\n# -------------------------\n# Multiplying centimeter-based numbers with a conversion factor from cm to\n# inches, gives the right numbers. Naming the conversion factor ``cm`` makes\n# the conversion almost look like appending a unit to the number, which is\n# nicely readable.\n#\ncm = 1/2.54  # centimeters in inches\nplt.subplots(figsize=(15*cm, 5*cm))\nplt.text(0.5, 0.5, '15cm x 5cm', **text_kwargs)\nplt.show()\n\n\n# %%\n# Figure size in pixel\n# --------------------\n# Similarly, one can use a conversion from pixels.\n#\n# Note that you could break this if you use `~.pyplot.savefig` with a\n# different explicit dpi value.\n#\npx = 1/plt.rcParams['figure.dpi']  # pixel in inches\nplt.subplots(figsize=(600*px, 200*px))\nplt.text(0.5, 0.5, '600px x 200px', **text_kwargs)\nplt.show()\n\n# %%\n# Quick interactive work is usually rendered to the screen, making pixels a\n# good size of unit. But defining the conversion factor may feel a little\n# tedious for quick iterations.\n#\n# Because of the default ``rcParams['figure.dpi'] = 100``, one can mentally\n# divide the needed pixel value by 100 [#]_:\n#\nplt.subplots(figsize=(6, 2))\nplt.text(0.5, 0.5, '600px x 200px', **text_kwargs)\nplt.show()\n\n# %%\n# .. [#] Unfortunately, this does not work well for the ``matplotlib inline``\n#        backend in Jupyter because that backend uses a different default of\n#        ``rcParams['figure.dpi'] = 72``. Additionally, it saves the figure\n#        with ``bbox_inches='tight'``, which crops the figure and makes the\n#        actual size unpredictable.\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.figure`\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.pyplot.subplot_mosaic`"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_106_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============================================\nFigure labels: suptitle, supxlabel, supylabel\n=============================================\n\nEach axes can have a title (or actually three - one each with *loc* \"left\",\n\"center\", and \"right\"), but is sometimes desirable to give a whole figure\n(or `.SubFigure`) an overall title, using `.FigureBase.suptitle`.\n\nWe can also add figure-level x- and y-labels using `.FigureBase.supxlabel` and\n`.FigureBase.supylabel`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\n\nx = np.linspace(0.0, 5.0, 501)\n\nfig, (ax1, ax2) = plt.subplots(1, 2, layout='constrained', sharey=True)\nax1.plot(x, np.cos(6*x) * np.exp(-x))\nax1.set_title('damped')\nax1.set_xlabel('time (s)')\nax1.set_ylabel('amplitude')\n\nax2.plot(x, np.cos(6*x))\nax2.set_xlabel('time (s)')\nax2.set_title('undamped')\n\nfig.suptitle('Different types of oscillations', fontsize=16)\n\n# %%\n# A global x- or y-label can be set using the `.FigureBase.supxlabel` and\n# `.FigureBase.supylabel` methods.\n\n\nwith get_sample_data('Stocks.csv') as file:\n    stocks = np.genfromtxt(\n        file, delimiter=',', names=True, dtype=None,\n        converters={0: lambda x: np.datetime64(x, 'D')}, skip_header=1)\n\nfig, axs = plt.subplots(4, 2, figsize=(9, 5), layout='constrained',\n                        sharex=True, sharey=True)\nfor nn, ax in enumerate(axs.flat):\n    column_name = stocks.dtype.names[1+nn]\n    y = stocks[column_name]\n    line, = ax.plot(stocks['Date'], y / np.nanmax(y), lw=2.5)\n    ax.set_title(column_name, fontsize='small', loc='left')\nfig.supxlabel('Year')\nfig.supylabel('Stock price relative to max')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_107_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========================\nCreating adjacent subplots\n==========================\n\nTo create plots that share a common axis (visually) you can set the hspace\nbetween the subplots to zero. Passing sharex=True when creating the subplots\nwill automatically turn off all x ticks and labels except those on the bottom\naxis.\n\nIn this example the plots share a common x-axis, but you can follow the same\nlogic to supply a common y-axis.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\n\ns1 = np.sin(2 * np.pi * t)\ns2 = np.exp(-t)\ns3 = s1 * s2\n\nfig, axs = plt.subplots(3, 1, sharex=True)\n# Remove vertical space between axes\nfig.subplots_adjust(hspace=0)\n\n# Plot each graph, and manually set the y tick values\naxs[0].plot(t, s1)\naxs[0].set_yticks(np.arange(-0.9, 1.0, 0.4))\naxs[0].set_ylim(-1, 1)\n\naxs[1].plot(t, s2)\naxs[1].set_yticks(np.arange(0.1, 1.0, 0.2))\naxs[1].set_ylim(0, 1)\n\naxs[2].plot(t, s3)\naxs[2].set_yticks(np.arange(-0.9, 1.0, 0.4))\naxs[2].set_ylim(-1, 1)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_108_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n======================\nGeographic Projections\n======================\n\nThis shows 4 possible geographic projections.  Cartopy_ supports more\nprojections.\n\n.. _Cartopy: https://scitools.org.uk/cartopy/\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n# %%\n\nplt.figure()\nplt.subplot(projection=\"aitoff\")\nplt.title(\"Aitoff\")\nplt.grid(True)\n\n# %%\n\nplt.figure()\nplt.subplot(projection=\"hammer\")\nplt.title(\"Hammer\")\nplt.grid(True)\n\n# %%\n\nplt.figure()\nplt.subplot(projection=\"lambert\")\nplt.title(\"Lambert\")\nplt.grid(True)\n\n# %%\n\nplt.figure()\nplt.subplot(projection=\"mollweide\")\nplt.title(\"Mollweide\")\nplt.grid(True)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_109_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================================================\nCombining two subplots using subplots and GridSpec\n==================================================\n\nSometimes we want to combine two subplots in an axes layout created with\n`~.Figure.subplots`.  We can get the `~.gridspec.GridSpec` from the axes\nand then remove the covered axes and fill the gap with a new bigger axes.\nHere we create a layout with the bottom two axes in the last column combined.\n\nTo start with this layout (rather than removing the overlapping axes) use\n`~.pyplot.subplot_mosaic`.\n\nSee also :ref:`arranging_axes`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig, axs = plt.subplots(ncols=3, nrows=3)\ngs = axs[1, 2].get_gridspec()\n# remove the underlying axes\nfor ax in axs[1:, -1]:\n    ax.remove()\naxbig = fig.add_subplot(gs[1:, -1])\naxbig.annotate('Big Axes \\nGridSpec[1:, -1]', (0.1, 0.5),\n               xycoords='axes fraction', va='center')\n\nfig.tight_layout()\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_110_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======================================================\nUsing Gridspec to make multi-column/row subplot layouts\n=======================================================\n\n`.GridSpec` is a flexible way to layout\nsubplot grids.  Here is an example with a 3x3 grid, and\naxes spanning all three columns, two columns, and two rows.\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.gridspec import GridSpec\n\n\ndef format_axes(fig):\n    for i, ax in enumerate(fig.axes):\n        ax.text(0.5, 0.5, \"ax%d\" % (i+1), va=\"center\", ha=\"center\")\n        ax.tick_params(labelbottom=False, labelleft=False)\n\nfig = plt.figure(layout=\"constrained\")\n\ngs = GridSpec(3, 3, figure=fig)\nax1 = fig.add_subplot(gs[0, :])\n# identical to ax1 = plt.subplot(gs.new_subplotspec((0, 0), colspan=3))\nax2 = fig.add_subplot(gs[1, :-1])\nax3 = fig.add_subplot(gs[1:, -1])\nax4 = fig.add_subplot(gs[-1, 0])\nax5 = fig.add_subplot(gs[-1, -2])\n\nfig.suptitle(\"GridSpec\")\nformat_axes(fig)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_111_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nNested Gridspecs\n================\n\nGridSpecs can be nested, so that a subplot from a parent GridSpec can\nset the position for a nested grid of subplots.\n\nNote that the same functionality can be achieved more directly with\n`~.FigureBase.subfigures`; see\n:doc:`/gallery/subplots_axes_and_figures/subfigures`.\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nimport matplotlib.gridspec as gridspec\n\n\ndef format_axes(fig):\n    for i, ax in enumerate(fig.axes):\n        ax.text(0.5, 0.5, \"ax%d\" % (i+1), va=\"center\", ha=\"center\")\n        ax.tick_params(labelbottom=False, labelleft=False)\n\n\n# gridspec inside gridspec\nfig = plt.figure()\n\ngs0 = gridspec.GridSpec(1, 2, figure=fig)\n\ngs00 = gridspec.GridSpecFromSubplotSpec(3, 3, subplot_spec=gs0[0])\n\nax1 = fig.add_subplot(gs00[:-1, :])\nax2 = fig.add_subplot(gs00[-1, :-1])\nax3 = fig.add_subplot(gs00[-1, -1])\n\n# the following syntax does the same as the GridSpecFromSubplotSpec call above:\ngs01 = gs0[1].subgridspec(3, 3)\n\nax4 = fig.add_subplot(gs01[:, :-1])\nax5 = fig.add_subplot(gs01[:-1, -1])\nax6 = fig.add_subplot(gs01[-1, -1])\n\nplt.suptitle(\"GridSpec Inside GridSpec\")\nformat_axes(fig)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_112_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========\nInvert Axes\n===========\n\nYou can use decreasing axes by flipping the normal order of the axis\nlimits\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.01, 5.0, 0.01)\ns = np.exp(-t)\n\nfig, ax = plt.subplots()\n\nax.plot(t, s)\nax.set_xlim(5, 0)  # decreasing time\nax.set_xlabel('decreasing time (s)')\nax.set_ylabel('voltage (mV)')\nax.set_title('Should be growing...')\nax.grid(True)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_113_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===================================\nManaging multiple figures in pyplot\n===================================\n\n`matplotlib.pyplot` uses the concept of a *current figure* and *current axes*.\nFigures are identified via a figure number that is passed to `~.pyplot.figure`.\nThe figure with the given number is set as *current figure*. Additionally, if\nno figure with the number exists, a new one is created.\n\n.. note::\n\n    We discourage working with multiple figures through the implicit pyplot\n    interface because managing the *current figure* is cumbersome and\n    error-prone. Instead, we recommend using the explicit approach and call\n    methods on Figure and Axes instances. See :ref:`api_interfaces` for an\n    explanation of the trade-offs between the implicit and explicit interfaces.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\ns1 = np.sin(2*np.pi*t)\ns2 = np.sin(4*np.pi*t)\n\n# %%\n# Create figure 1\n\nplt.figure(1)\nplt.subplot(211)\nplt.plot(t, s1)\nplt.subplot(212)\nplt.plot(t, 2*s1)\n\n# %%\n# Create figure 2\n\nplt.figure(2)\nplt.plot(t, s2)\n\n# %%\n# Now switch back to figure 1 and make some changes\n\nplt.figure(1)\nplt.subplot(211)\nplt.plot(t, s2, 's')\nax = plt.gca()\nax.set_xticklabels([])\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_114_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============\nSecondary Axis\n==============\n\nSometimes we want a secondary axis on a plot, for instance to convert\nradians to degrees on the same plot.  We can do this by making a child\naxes with only one axis visible via `.axes.Axes.secondary_xaxis` and\n`.axes.Axes.secondary_yaxis`.  This secondary axis can have a different scale\nthan the main axis by providing both a forward and an inverse conversion\nfunction in a tuple to the *functions* keyword argument:\n\"\"\"\n\nimport datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.dates as mdates\nfrom matplotlib.ticker import AutoMinorLocator\n\nfig, ax = plt.subplots(layout='constrained')\nx = np.arange(0, 360, 1)\ny = np.sin(2 * x * np.pi / 180)\nax.plot(x, y)\nax.set_xlabel('angle [degrees]')\nax.set_ylabel('signal')\nax.set_title('Sine wave')\n\n\ndef deg2rad(x):\n    return x * np.pi / 180\n\n\ndef rad2deg(x):\n    return x * 180 / np.pi\n\n\nsecax = ax.secondary_xaxis('top', functions=(deg2rad, rad2deg))\nsecax.set_xlabel('angle [rad]')\nplt.show()\n\n# %%\n# Here is the case of converting from wavenumber to wavelength in a\n# log-log scale.\n#\n# .. note::\n#\n#   In this case, the xscale of the parent is logarithmic, so the child is\n#   made logarithmic as well.\n\nfig, ax = plt.subplots(layout='constrained')\nx = np.arange(0.02, 1, 0.02)\nnp.random.seed(19680801)\ny = np.random.randn(len(x)) ** 2\nax.loglog(x, y)\nax.set_xlabel('f [Hz]')\nax.set_ylabel('PSD')\nax.set_title('Random spectrum')\n\n\ndef one_over(x):\n    \"\"\"Vectorized 1/x, treating x==0 manually\"\"\"\n    x = np.array(x, float)\n    near_zero = np.isclose(x, 0)\n    x[near_zero] = np.inf\n    x[~near_zero] = 1 / x[~near_zero]\n    return x\n\n\n# the function \"1/x\" is its own inverse\ninverse = one_over\n\n\nsecax = ax.secondary_xaxis('top', functions=(one_over, inverse))\nsecax.set_xlabel('period [s]')\nplt.show()\n\n# %%\n# Sometime we want to relate the axes in a transform that is ad-hoc from\n# the data, and is derived empirically.  In that case we can set the\n# forward and inverse transforms functions to be linear interpolations from the\n# one data set to the other.\n#\n# .. note::\n#\n#   In order to properly handle the data margins, the mapping functions\n#   (``forward`` and ``inverse`` in this example) need to be defined beyond the\n#   nominal plot limits.\n#\n#   In the specific case of the numpy linear interpolation, `numpy.interp`,\n#   this condition can be arbitrarily enforced by providing optional keyword\n#   arguments *left*, *right* such that values outside the data range are\n#   mapped well outside the plot limits.\n\nfig, ax = plt.subplots(layout='constrained')\nxdata = np.arange(1, 11, 0.4)\nydata = np.random.randn(len(xdata))\nax.plot(xdata, ydata, label='Plotted data')\n\nxold = np.arange(0, 11, 0.2)\n# fake data set relating x coordinate to another data-derived coordinate.\n# xnew must be monotonic, so we sort...\nxnew = np.sort(10 * np.exp(-xold / 4) + np.random.randn(len(xold)) / 3)\n\nax.plot(xold[3:], xnew[3:], label='Transform data')\nax.set_xlabel('X [m]')\nax.legend()\n\n\ndef forward(x):\n    return np.interp(x, xold, xnew)\n\n\ndef inverse(x):\n    return np.interp(x, xnew, xold)\n\n\nsecax = ax.secondary_xaxis('top', functions=(forward, inverse))\nsecax.xaxis.set_minor_locator(AutoMinorLocator())\nsecax.set_xlabel('$X_{other}$')\n\nplt.show()\n\n# %%\n# A final example translates np.datetime64 to yearday on the x axis and\n# from Celsius to Fahrenheit on the y axis.  Note the addition of a\n# third y axis, and that it can be placed using a float for the\n# location argument\n\ndates = [datetime.datetime(2018, 1, 1) + datetime.timedelta(hours=k * 6)\n         for k in range(240)]\ntemperature = np.random.randn(len(dates)) * 4 + 6.7\nfig, ax = plt.subplots(layout='constrained')\n\nax.plot(dates, temperature)\nax.set_ylabel(r'$T\\ [^oC]$')\nplt.xticks(rotation=70)\n\n\ndef date2yday(x):\n    \"\"\"Convert matplotlib datenum to days since 2018-01-01.\"\"\"\n    y = x - mdates.date2num(datetime.datetime(2018, 1, 1))\n    return y\n\n\ndef yday2date(x):\n    \"\"\"Return a matplotlib datenum for *x* days after 2018-01-01.\"\"\"\n    y = x + mdates.date2num(datetime.datetime(2018, 1, 1))\n    return y\n\n\nsecax_x = ax.secondary_xaxis('top', functions=(date2yday, yday2date))\nsecax_x.set_xlabel('yday [2018]')\n\n\ndef celsius_to_fahrenheit(x):\n    return x * 1.8 + 32\n\n\ndef fahrenheit_to_celsius(x):\n    return (x - 32) / 1.8\n\n\nsecax_y = ax.secondary_yaxis(\n    'right', functions=(celsius_to_fahrenheit, fahrenheit_to_celsius))\nsecax_y.set_ylabel(r'$T\\ [^oF]$')\n\n\ndef celsius_to_anomaly(x):\n    return (x - np.mean(temperature))\n\n\ndef anomaly_to_celsius(x):\n    return (x + np.mean(temperature))\n\n\n# use of a float for the position:\nsecax_y2 = ax.secondary_yaxis(\n    1.2, functions=(celsius_to_anomaly, anomaly_to_celsius))\nsecax_y2.set_ylabel(r'$T - \\overline{T}\\ [^oC]$')\n\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.secondary_xaxis`\n#    - `matplotlib.axes.Axes.secondary_yaxis`"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_115_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\nSharing axis limits and views\n=============================\n\nIt's common to make two or more plots which share an axis, e.g., two subplots\nwith time as a common axis.  When you pan and zoom around on one, you want the\nother to move around with you.  To facilitate this, matplotlib Axes support a\n``sharex`` and ``sharey`` attribute.  When you create a `~.pyplot.subplot` or\n`~.pyplot.axes`, you can pass in a keyword indicating what axes you want to\nshare with.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0, 10, 0.01)\n\nax1 = plt.subplot(211)\nax1.plot(t, np.sin(2*np.pi*t))\n\nax2 = plt.subplot(212, sharex=ax1)\nax2.plot(t, np.sin(4*np.pi*t))\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_116_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========\nShared axis\n===========\n\nYou can share the x- or y-axis limits for one axis with another by\npassing an `~.axes.Axes` instance as a *sharex* or *sharey* keyword argument.\n\nChanging the axis limits on one axes will be reflected automatically\nin the other, and vice-versa, so when you navigate with the toolbar\nthe Axes will follow each other on their shared axis.  Ditto for\nchanges in the axis scaling (e.g., log vs. linear).  However, it is\npossible to have differences in tick labeling, e.g., you can selectively\nturn off the tick labels on one Axes.\n\nThe example below shows how to customize the tick labels on the\nvarious axes.  Shared axes share the tick locator, tick formatter,\nview limits, and transformation (e.g., log, linear).  But the ticklabels\nthemselves do not share properties.  This is a feature and not a bug,\nbecause you may want to make the tick labels smaller on the upper\naxes, e.g., in the example below.\n\nIf you want to turn off the ticklabels for a given Axes (e.g., on\nsubplot(211) or subplot(212)), you cannot do the standard trick::\n\n   setp(ax2, xticklabels=[])\n\nbecause this changes the tick Formatter, which is shared among all\nAxes.  But you can alter the visibility of the labels, which is a\nproperty::\n\n  setp(ax2.get_xticklabels(), visible=False)\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.01, 5.0, 0.01)\ns1 = np.sin(2 * np.pi * t)\ns2 = np.exp(-t)\ns3 = np.sin(4 * np.pi * t)\n\nax1 = plt.subplot(311)\nplt.plot(t, s1)\nplt.tick_params('x', labelsize=6)\n\n# share x only\nax2 = plt.subplot(312, sharex=ax1)\nplt.plot(t, s2)\n# make these tick labels invisible\nplt.tick_params('x', labelbottom=False)\n\n# share x and y\nax3 = plt.subplot(313, sharex=ax1, sharey=ax1)\nplt.plot(t, s3)\nplt.xlim(0.01, 5.0)\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_117_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================\nFigure subfigures\n=================\n\nSometimes it is desirable to have a figure with two different layouts in it.\nThis can be achieved with\n:doc:`nested gridspecs</gallery/subplots_axes_and_figures/gridspec_nested>`,\nbut having a virtual figure with its own artists is helpful, so\nMatplotlib also has \"subfigures\", accessed by calling\n`matplotlib.figure.Figure.add_subfigure` in a way that is analogous to\n`matplotlib.figure.Figure.add_subplot`, or\n`matplotlib.figure.Figure.subfigures` to make an array of subfigures.  Note\nthat subfigures can also have their own child subfigures.\n\n.. note::\n    ``subfigure`` is new in v3.4, and the API is still provisional.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef example_plot(ax, fontsize=12, hide_labels=False):\n    pc = ax.pcolormesh(np.random.randn(30, 30), vmin=-2.5, vmax=2.5)\n    if not hide_labels:\n        ax.set_xlabel('x-label', fontsize=fontsize)\n        ax.set_ylabel('y-label', fontsize=fontsize)\n        ax.set_title('Title', fontsize=fontsize)\n    return pc\n\nnp.random.seed(19680808)\n# gridspec inside gridspec\nfig = plt.figure(layout='constrained', figsize=(10, 4))\nsubfigs = fig.subfigures(1, 2, wspace=0.07)\n\naxsLeft = subfigs[0].subplots(1, 2, sharey=True)\nsubfigs[0].set_facecolor('0.75')\nfor ax in axsLeft:\n    pc = example_plot(ax)\nsubfigs[0].suptitle('Left plots', fontsize='x-large')\nsubfigs[0].colorbar(pc, shrink=0.6, ax=axsLeft, location='bottom')\n\naxsRight = subfigs[1].subplots(3, 1, sharex=True)\nfor nn, ax in enumerate(axsRight):\n    pc = example_plot(ax, hide_labels=True)\n    if nn == 2:\n        ax.set_xlabel('xlabel')\n    if nn == 1:\n        ax.set_ylabel('ylabel')\n\nsubfigs[1].set_facecolor('0.85')\nsubfigs[1].colorbar(pc, shrink=0.6, ax=axsRight)\nsubfigs[1].suptitle('Right plots', fontsize='x-large')\n\nfig.suptitle('Figure suptitle', fontsize='xx-large')\n\nplt.show()\n\n# %%\n# It is possible to mix subplots and subfigures using\n# `matplotlib.figure.Figure.add_subfigure`.  This requires getting\n# the gridspec that the subplots are laid out on.\n\nfig, axs = plt.subplots(2, 3, layout='constrained', figsize=(10, 4))\ngridspec = axs[0, 0].get_subplotspec().get_gridspec()\n\n# clear the left column for the subfigure:\nfor a in axs[:, 0]:\n    a.remove()\n\n# plot data in remaining axes:\nfor a in axs[:, 1:].flat:\n    a.plot(np.arange(10))\n\n# make the subfigure in the empty gridspec slots:\nsubfig = fig.add_subfigure(gridspec[:, 0])\n\naxsLeft = subfig.subplots(1, 2, sharey=True)\nsubfig.set_facecolor('0.75')\nfor ax in axsLeft:\n    pc = example_plot(ax)\nsubfig.suptitle('Left plots', fontsize='x-large')\nsubfig.colorbar(pc, shrink=0.6, ax=axsLeft, location='bottom')\n\nfig.suptitle('Figure suptitle', fontsize='xx-large')\nplt.show()\n\n# %%\n# Subfigures can have different widths and heights.  This is exactly the\n# same example as the first example, but *width_ratios* has been changed:\n\nfig = plt.figure(layout='constrained', figsize=(10, 4))\nsubfigs = fig.subfigures(1, 2, wspace=0.07, width_ratios=[2, 1])\n\naxsLeft = subfigs[0].subplots(1, 2, sharey=True)\nsubfigs[0].set_facecolor('0.75')\nfor ax in axsLeft:\n    pc = example_plot(ax)\nsubfigs[0].suptitle('Left plots', fontsize='x-large')\nsubfigs[0].colorbar(pc, shrink=0.6, ax=axsLeft, location='bottom')\n\naxsRight = subfigs[1].subplots(3, 1, sharex=True)\nfor nn, ax in enumerate(axsRight):\n    pc = example_plot(ax, hide_labels=True)\n    if nn == 2:\n        ax.set_xlabel('xlabel')\n    if nn == 1:\n        ax.set_ylabel('ylabel')\n\nsubfigs[1].set_facecolor('0.85')\nsubfigs[1].colorbar(pc, shrink=0.6, ax=axsRight)\nsubfigs[1].suptitle('Right plots', fontsize='x-large')\n\nfig.suptitle('Figure suptitle', fontsize='xx-large')\n\nplt.show()\n\n# %%\n# Subfigures can be also be nested:\n\nfig = plt.figure(layout='constrained', figsize=(10, 8))\n\nfig.suptitle('fig')\n\nsubfigs = fig.subfigures(1, 2, wspace=0.07)\n\nsubfigs[0].set_facecolor('coral')\nsubfigs[0].suptitle('subfigs[0]')\n\nsubfigs[1].set_facecolor('coral')\nsubfigs[1].suptitle('subfigs[1]')\n\nsubfigsnest = subfigs[0].subfigures(2, 1, height_ratios=[1, 1.4])\nsubfigsnest[0].suptitle('subfigsnest[0]')\nsubfigsnest[0].set_facecolor('r')\naxsnest0 = subfigsnest[0].subplots(1, 2, sharey=True)\nfor nn, ax in enumerate(axsnest0):\n    pc = example_plot(ax, hide_labels=True)\nsubfigsnest[0].colorbar(pc, ax=axsnest0)\n\nsubfigsnest[1].suptitle('subfigsnest[1]')\nsubfigsnest[1].set_facecolor('g')\naxsnest1 = subfigsnest[1].subplots(3, 1, sharex=True)\n\naxsRight = subfigs[1].subplots(2, 2)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_118_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================\nMultiple subplots\n=================\n\nSimple demo with multiple subplots.\n\nFor more options, see :doc:`/gallery/subplots_axes_and_figures/subplots_demo`.\n\n.. redirect-from:: /gallery/subplots_axes_and_figures/subplot_demo\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Create some fake data.\nx1 = np.linspace(0.0, 5.0)\ny1 = np.cos(2 * np.pi * x1) * np.exp(-x1)\nx2 = np.linspace(0.0, 2.0)\ny2 = np.cos(2 * np.pi * x2)\n\n# %%\n# `~.pyplot.subplots()` is the recommended method to generate simple subplot\n# arrangements:\n\nfig, (ax1, ax2) = plt.subplots(2, 1)\nfig.suptitle('A tale of 2 subplots')\n\nax1.plot(x1, y1, 'o-')\nax1.set_ylabel('Damped oscillation')\n\nax2.plot(x2, y2, '.-')\nax2.set_xlabel('time (s)')\nax2.set_ylabel('Undamped')\n\nplt.show()\n\n# %%\n# Subplots can also be generated one at a time using `~.pyplot.subplot()`:\n\nplt.subplot(2, 1, 1)\nplt.plot(x1, y1, 'o-')\nplt.title('A tale of 2 subplots')\nplt.ylabel('Damped oscillation')\n\nplt.subplot(2, 1, 2)\nplt.plot(x2, y2, '.-')\nplt.xlabel('time (s)')\nplt.ylabel('Undamped')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_119_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============================\nSubplots spacings and margins\n=============================\n\nAdjusting the spacing of margins and subplots using `.pyplot.subplots_adjust`.\n\n.. note::\n   There is also a tool window to adjust the margins and spacings of displayed\n   figures interactively.  It can be opened via the toolbar or by calling\n   `.pyplot.subplot_tool`.\n\n.. redirect-from:: /gallery/subplots_axes_and_figures/subplot_toolbar\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nplt.subplot(211)\nplt.imshow(np.random.random((100, 100)))\nplt.subplot(212)\nplt.imshow(np.random.random((100, 100)))\n\nplt.subplots_adjust(bottom=0.1, right=0.8, top=0.9)\ncax = plt.axes([0.85, 0.1, 0.075, 0.8])\nplt.colorbar(cax=cax)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_120_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================================================\nCreating multiple subplots using ``plt.subplots``\n=================================================\n\n`.pyplot.subplots` creates a figure and a grid of subplots with a single call,\nwhile providing reasonable control over how the individual plots are created.\nFor more advanced use cases you can use `.GridSpec` for a more general subplot\nlayout or `.Figure.add_subplot` for adding subplots at arbitrary locations\nwithin the figure.\n\"\"\"\n\n# sphinx_gallery_thumbnail_number = 11\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Some example data to display\nx = np.linspace(0, 2 * np.pi, 400)\ny = np.sin(x ** 2)\n\n# %%\n# A figure with just one subplot\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# ``subplots()`` without arguments returns a `.Figure` and a single\n# `~.axes.Axes`.\n#\n# This is actually the simplest and recommended way of creating a single\n# Figure and Axes.\n\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_title('A single plot')\n\n# %%\n# Stacking subplots in one direction\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# The first two optional arguments of `.pyplot.subplots` define the number of\n# rows and columns of the subplot grid.\n#\n# When stacking in one direction only, the returned ``axs`` is a 1D numpy array\n# containing the list of created Axes.\n\nfig, axs = plt.subplots(2)\nfig.suptitle('Vertically stacked subplots')\naxs[0].plot(x, y)\naxs[1].plot(x, -y)\n\n# %%\n# If you are creating just a few Axes, it's handy to unpack them immediately to\n# dedicated variables for each Axes. That way, we can use ``ax1`` instead of\n# the more verbose ``axs[0]``.\n\nfig, (ax1, ax2) = plt.subplots(2)\nfig.suptitle('Vertically stacked subplots')\nax1.plot(x, y)\nax2.plot(x, -y)\n\n# %%\n# To obtain side-by-side subplots, pass parameters ``1, 2`` for one row and two\n# columns.\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nfig.suptitle('Horizontally stacked subplots')\nax1.plot(x, y)\nax2.plot(x, -y)\n\n# %%\n# Stacking subplots in two directions\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# When stacking in two directions, the returned ``axs`` is a 2D NumPy array.\n#\n# If you have to set parameters for each subplot it's handy to iterate over\n# all subplots in a 2D grid using ``for ax in axs.flat:``.\n\nfig, axs = plt.subplots(2, 2)\naxs[0, 0].plot(x, y)\naxs[0, 0].set_title('Axis [0, 0]')\naxs[0, 1].plot(x, y, 'tab:orange')\naxs[0, 1].set_title('Axis [0, 1]')\naxs[1, 0].plot(x, -y, 'tab:green')\naxs[1, 0].set_title('Axis [1, 0]')\naxs[1, 1].plot(x, -y, 'tab:red')\naxs[1, 1].set_title('Axis [1, 1]')\n\nfor ax in axs.flat:\n    ax.set(xlabel='x-label', ylabel='y-label')\n\n# Hide x labels and tick labels for top plots and y ticks for right plots.\nfor ax in axs.flat:\n    ax.label_outer()\n\n# %%\n# You can use tuple-unpacking also in 2D to assign all subplots to dedicated\n# variables:\n\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\nfig.suptitle('Sharing x per column, y per row')\nax1.plot(x, y)\nax2.plot(x, y**2, 'tab:orange')\nax3.plot(x, -y, 'tab:green')\nax4.plot(x, -y**2, 'tab:red')\n\nfor ax in fig.get_axes():\n    ax.label_outer()\n\n# %%\n# Sharing axes\n# \"\"\"\"\"\"\"\"\"\"\"\"\n#\n# By default, each Axes is scaled individually. Thus, if the ranges are\n# different the tick values of the subplots do not align.\n\nfig, (ax1, ax2) = plt.subplots(2)\nfig.suptitle('Axes values are scaled individually by default')\nax1.plot(x, y)\nax2.plot(x + 1, -y)\n\n# %%\n# You can use *sharex* or *sharey* to align the horizontal or vertical axis.\n\nfig, (ax1, ax2) = plt.subplots(2, sharex=True)\nfig.suptitle('Aligning x-axis using sharex')\nax1.plot(x, y)\nax2.plot(x + 1, -y)\n\n# %%\n# Setting *sharex* or *sharey* to ``True`` enables global sharing across the\n# whole grid, i.e. also the y-axes of vertically stacked subplots have the\n# same scale when using ``sharey=True``.\n\nfig, axs = plt.subplots(3, sharex=True, sharey=True)\nfig.suptitle('Sharing both axes')\naxs[0].plot(x, y ** 2)\naxs[1].plot(x, 0.3 * y, 'o')\naxs[2].plot(x, y, '+')\n\n# %%\n# For subplots that are sharing axes one set of tick labels is enough. Tick\n# labels of inner Axes are automatically removed by *sharex* and *sharey*.\n# Still there remains an unused empty space between the subplots.\n#\n# To precisely control the positioning of the subplots, one can explicitly\n# create a `.GridSpec` with `.Figure.add_gridspec`, and then call its\n# `~.GridSpecBase.subplots` method.  For example, we can reduce the height\n# between vertical subplots using ``add_gridspec(hspace=0)``.\n#\n# `.label_outer` is a handy method to remove labels and ticks from subplots\n# that are not at the edge of the grid.\n\nfig = plt.figure()\ngs = fig.add_gridspec(3, hspace=0)\naxs = gs.subplots(sharex=True, sharey=True)\nfig.suptitle('Sharing both axes')\naxs[0].plot(x, y ** 2)\naxs[1].plot(x, 0.3 * y, 'o')\naxs[2].plot(x, y, '+')\n\n# Hide x labels and tick labels for all but bottom plot.\nfor ax in axs:\n    ax.label_outer()\n\n# %%\n# Apart from ``True`` and ``False``, both *sharex* and *sharey* accept the\n# values 'row' and 'col' to share the values only per row or column.\n\nfig = plt.figure()\ngs = fig.add_gridspec(2, 2, hspace=0, wspace=0)\n(ax1, ax2), (ax3, ax4) = gs.subplots(sharex='col', sharey='row')\nfig.suptitle('Sharing x per column, y per row')\nax1.plot(x, y)\nax2.plot(x, y**2, 'tab:orange')\nax3.plot(x + 1, -y, 'tab:green')\nax4.plot(x + 2, -y**2, 'tab:red')\n\nfor ax in fig.get_axes():\n    ax.label_outer()\n\n# %%\n# If you want a more complex sharing structure, you can first create the\n# grid of axes with no sharing, and then call `.axes.Axes.sharex` or\n# `.axes.Axes.sharey` to add sharing info a posteriori.\n\nfig, axs = plt.subplots(2, 2)\naxs[0, 0].plot(x, y)\naxs[0, 0].set_title(\"main\")\naxs[1, 0].plot(x, y**2)\naxs[1, 0].set_title(\"shares x with main\")\naxs[1, 0].sharex(axs[0, 0])\naxs[0, 1].plot(x + 1, y + 1)\naxs[0, 1].set_title(\"unrelated\")\naxs[1, 1].plot(x + 2, y + 2)\naxs[1, 1].set_title(\"also unrelated\")\nfig.tight_layout()\n\n# %%\n# Polar axes\n# \"\"\"\"\"\"\"\"\"\"\n#\n# The parameter *subplot_kw* of `.pyplot.subplots` controls the subplot\n# properties (see also `.Figure.add_subplot`). In particular, this can be used\n# to create a grid of polar Axes.\n\nfig, (ax1, ax2) = plt.subplots(1, 2, subplot_kw=dict(projection='polar'))\nax1.plot(x, y)\nax2.plot(x, y ** 2)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/03subplots_axes_and_figures_121_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========================\nPlots with different scales\n===========================\n\nTwo plots on the same axes with different left and right scales.\n\nThe trick is to use *two different axes* that share the same *x* axis.\nYou can use separate `matplotlib.ticker` formatters and locators as\ndesired since the two axes are independent.\n\nSuch axes are generated by calling the `.Axes.twinx` method. Likewise,\n`.Axes.twiny` is available to generate axes that share a *y* axis but\nhave different top and bottom scales.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Create some mock data\nt = np.arange(0.01, 10.0, 0.01)\ndata1 = np.exp(t)\ndata2 = np.sin(2 * np.pi * t)\n\nfig, ax1 = plt.subplots()\n\ncolor = 'tab:red'\nax1.set_xlabel('time (s)')\nax1.set_ylabel('exp', color=color)\nax1.plot(t, data1, color=color)\nax1.tick_params(axis='y', labelcolor=color)\n\nax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n\ncolor = 'tab:blue'\nax2.set_ylabel('sin', color=color)  # we already handled the x-label with ax1\nax2.plot(t, data2, color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfig.tight_layout()  # otherwise the right y-label is slightly clipped\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.twinx` / `matplotlib.pyplot.twinx`\n#    - `matplotlib.axes.Axes.twiny` / `matplotlib.pyplot.twiny`\n#    - `matplotlib.axes.Axes.tick_params` / `matplotlib.pyplot.tick_params`"
      }
    ],
    "04statistics": [
      {
        "image_path": "gallery_assets/04statistics_122_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===================================\nPercentiles as horizontal bar chart\n===================================\n\nBar charts are useful for visualizing counts, or summary statistics\nwith error bars. Also see the :doc:`/gallery/lines_bars_and_markers/barchart`\nor the :doc:`/gallery/lines_bars_and_markers/barh` example for simpler versions\nof those features.\n\nThis example comes from an application in which grade school gym\nteachers wanted to be able to show parents how their child did across\na handful of fitness tests, and importantly, relative to how other\nchildren did. To extract the plotting code for demo purposes, we'll\njust make up some data for little Johnny Doe.\n\"\"\"\n\nfrom collections import namedtuple\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nStudent = namedtuple('Student', ['name', 'grade', 'gender'])\nScore = namedtuple('Score', ['value', 'unit', 'percentile'])\n\n\ndef to_ordinal(num):\n    \"\"\"Convert an integer to an ordinal string, e.g. 2 -> '2nd'.\"\"\"\n    suffixes = {str(i): v\n                for i, v in enumerate(['th', 'st', 'nd', 'rd', 'th',\n                                       'th', 'th', 'th', 'th', 'th'])}\n    v = str(num)\n    # special case early teens\n    if v in {'11', '12', '13'}:\n        return v + 'th'\n    return v + suffixes[v[-1]]\n\n\ndef format_score(score):\n    \"\"\"\n    Create score labels for the right y-axis as the test name followed by the\n    measurement unit (if any), split over two lines.\n    \"\"\"\n    return f'{score.value}\\n{score.unit}' if score.unit else str(score.value)\n\n\ndef plot_student_results(student, scores_by_test, cohort_size):\n    fig, ax1 = plt.subplots(figsize=(9, 7), layout='constrained')\n    fig.canvas.manager.set_window_title('Eldorado K-8 Fitness Chart')\n\n    ax1.set_title(student.name)\n    ax1.set_xlabel(\n        'Percentile Ranking Across {grade} Grade {gender}s\\n'\n        'Cohort Size: {cohort_size}'.format(\n            grade=to_ordinal(student.grade),\n            gender=student.gender.title(),\n            cohort_size=cohort_size))\n\n    test_names = list(scores_by_test.keys())\n    percentiles = [score.percentile for score in scores_by_test.values()]\n\n    rects = ax1.barh(test_names, percentiles, align='center', height=0.5)\n    # Partition the percentile values to be able to draw large numbers in\n    # white within the bar, and small numbers in black outside the bar.\n    large_percentiles = [to_ordinal(p) if p > 40 else '' for p in percentiles]\n    small_percentiles = [to_ordinal(p) if p <= 40 else '' for p in percentiles]\n    ax1.bar_label(rects, small_percentiles,\n                  padding=5, color='black', fontweight='bold')\n    ax1.bar_label(rects, large_percentiles,\n                  padding=-32, color='white', fontweight='bold')\n\n    ax1.set_xlim([0, 100])\n    ax1.set_xticks([0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100])\n    ax1.xaxis.grid(True, linestyle='--', which='major',\n                   color='grey', alpha=.25)\n    ax1.axvline(50, color='grey', alpha=0.25)  # median position\n\n    # Set the right-hand Y-axis ticks and labels\n    ax2 = ax1.twinx()\n    # Set equal limits on both yaxis so that the ticks line up\n    ax2.set_ylim(ax1.get_ylim())\n    # Set the tick locations and labels\n    ax2.set_yticks(\n        np.arange(len(scores_by_test)),\n        labels=[format_score(score) for score in scores_by_test.values()])\n\n    ax2.set_ylabel('Test Scores')\n\n\nstudent = Student(name='Johnny Doe', grade=2, gender='Boy')\nscores_by_test = {\n    'Pacer Test': Score(7, 'laps', percentile=37),\n    'Flexed Arm\\n Hang': Score(48, 'sec', percentile=95),\n    'Mile Run': Score('12:52', 'min:sec', percentile=73),\n    'Agility': Score(17, 'sec', percentile=60),\n    'Push Ups': Score(14, '', percentile=16),\n}\n\nplot_student_results(student, scores_by_test, cohort_size=62)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`\n#    - `matplotlib.axes.Axes.bar_label` / `matplotlib.pyplot.bar_label`\n#    - `matplotlib.axes.Axes.twinx` / `matplotlib.pyplot.twinx`"
      },
      {
        "image_path": "gallery_assets/04statistics_123_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================================\nArtist customization in box plots\n=================================\n\nThis example demonstrates how to use the various keyword arguments to fully\ncustomize box plots. The first figure demonstrates how to remove and add\nindividual components (note that the mean is the only value not shown by\ndefault). The second figure demonstrates how the styles of the artists can be\ncustomized. It also demonstrates how to set the limit of the whiskers to\nspecific percentiles (lower right axes)\n\nA good general reference on boxplots and their history can be found here:\nhttps://vita.had.co.nz/papers/boxplots.pdf\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# fake data\nnp.random.seed(19680801)\ndata = np.random.lognormal(size=(37, 4), mean=1.5, sigma=1.75)\nlabels = list('ABCD')\nfs = 10  # fontsize\n\n# %%\n# Demonstrate how to toggle the display of different elements:\n\nfig, axs = plt.subplots(nrows=2, ncols=3, figsize=(6, 6), sharey=True)\naxs[0, 0].boxplot(data, labels=labels)\naxs[0, 0].set_title('Default', fontsize=fs)\n\naxs[0, 1].boxplot(data, labels=labels, showmeans=True)\naxs[0, 1].set_title('showmeans=True', fontsize=fs)\n\naxs[0, 2].boxplot(data, labels=labels, showmeans=True, meanline=True)\naxs[0, 2].set_title('showmeans=True,\\nmeanline=True', fontsize=fs)\n\naxs[1, 0].boxplot(data, labels=labels, showbox=False, showcaps=False)\ntufte_title = 'Tufte Style \\n(showbox=False,\\nshowcaps=False)'\naxs[1, 0].set_title(tufte_title, fontsize=fs)\n\naxs[1, 1].boxplot(data, labels=labels, notch=True, bootstrap=10000)\naxs[1, 1].set_title('notch=True,\\nbootstrap=10000', fontsize=fs)\n\naxs[1, 2].boxplot(data, labels=labels, showfliers=False)\naxs[1, 2].set_title('showfliers=False', fontsize=fs)\n\nfor ax in axs.flat:\n    ax.set_yscale('log')\n    ax.set_yticklabels([])\n\nfig.subplots_adjust(hspace=0.4)\nplt.show()\n\n\n# %%\n# Demonstrate how to customize the display different elements:\n\nboxprops = dict(linestyle='--', linewidth=3, color='darkgoldenrod')\nflierprops = dict(marker='o', markerfacecolor='green', markersize=12,\n                  markeredgecolor='none')\nmedianprops = dict(linestyle='-.', linewidth=2.5, color='firebrick')\nmeanpointprops = dict(marker='D', markeredgecolor='black',\n                      markerfacecolor='firebrick')\nmeanlineprops = dict(linestyle='--', linewidth=2.5, color='purple')\n\nfig, axs = plt.subplots(nrows=2, ncols=3, figsize=(6, 6), sharey=True)\naxs[0, 0].boxplot(data, boxprops=boxprops)\naxs[0, 0].set_title('Custom boxprops', fontsize=fs)\n\naxs[0, 1].boxplot(data, flierprops=flierprops, medianprops=medianprops)\naxs[0, 1].set_title('Custom medianprops\\nand flierprops', fontsize=fs)\n\naxs[0, 2].boxplot(data, whis=(0, 100))\naxs[0, 2].set_title('whis=(0, 100)', fontsize=fs)\n\naxs[1, 0].boxplot(data, meanprops=meanpointprops, meanline=False,\n                  showmeans=True)\naxs[1, 0].set_title('Custom mean\\nas point', fontsize=fs)\n\naxs[1, 1].boxplot(data, meanprops=meanlineprops, meanline=True,\n                  showmeans=True)\naxs[1, 1].set_title('Custom mean\\nas line', fontsize=fs)\n\naxs[1, 2].boxplot(data, whis=[15, 85])\naxs[1, 2].set_title('whis=[15, 85]\\n#percentiles', fontsize=fs)\n\nfor ax in axs.flat:\n    ax.set_yscale('log')\n    ax.set_yticklabels([])\n\nfig.suptitle(\"I never said they'd be pretty\")\nfig.subplots_adjust(hspace=0.4)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.boxplot` / `matplotlib.pyplot.boxplot`"
      },
      {
        "image_path": "gallery_assets/04statistics_124_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================================\nBox plots with custom fill colors\n=================================\n\nThis plot illustrates how to create two types of box plots\n(rectangular and notched), and how to fill them with custom\ncolors by accessing the properties of the artists of the\nbox plots. Additionally, the ``labels`` parameter is used to\nprovide x-tick labels for each sample.\n\nA good general reference on boxplots and their history can be found\nhere: http://vita.had.co.nz/papers/boxplots.pdf\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Random test data\nnp.random.seed(19680801)\nall_data = [np.random.normal(0, std, size=100) for std in range(1, 4)]\nlabels = ['x1', 'x2', 'x3']\n\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(9, 4))\n\n# rectangular box plot\nbplot1 = ax1.boxplot(all_data,\n                     vert=True,  # vertical box alignment\n                     patch_artist=True,  # fill with color\n                     labels=labels)  # will be used to label x-ticks\nax1.set_title('Rectangular box plot')\n\n# notch shape box plot\nbplot2 = ax2.boxplot(all_data,\n                     notch=True,  # notch shape\n                     vert=True,  # vertical box alignment\n                     patch_artist=True,  # fill with color\n                     labels=labels)  # will be used to label x-ticks\nax2.set_title('Notched box plot')\n\n# fill with colors\ncolors = ['pink', 'lightblue', 'lightgreen']\nfor bplot in (bplot1, bplot2):\n    for patch, color in zip(bplot['boxes'], colors):\n        patch.set_facecolor(color)\n\n# adding horizontal grid lines\nfor ax in [ax1, ax2]:\n    ax.yaxis.grid(True)\n    ax.set_xlabel('Three separate samples')\n    ax.set_ylabel('Observed values')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.boxplot` / `matplotlib.pyplot.boxplot`"
      },
      {
        "image_path": "gallery_assets/04statistics_125_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========\nBoxplots\n========\n\nVisualizing boxplots with matplotlib.\n\nThe following examples show off how to visualize boxplots with\nMatplotlib. There are many options to control their appearance and\nthe statistics that they use to summarize the data.\n\n.. redirect-from:: /gallery/pyplots/boxplot_demo_pyplot\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Polygon\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# fake up some data\nspread = np.random.rand(50) * 100\ncenter = np.ones(25) * 50\nflier_high = np.random.rand(10) * 100 + 100\nflier_low = np.random.rand(10) * -100\ndata = np.concatenate((spread, center, flier_high, flier_low))\n\nfig, axs = plt.subplots(2, 3)\n\n# basic plot\naxs[0, 0].boxplot(data)\naxs[0, 0].set_title('basic plot')\n\n# notched plot\naxs[0, 1].boxplot(data, 1)\naxs[0, 1].set_title('notched plot')\n\n# change outlier point symbols\naxs[0, 2].boxplot(data, 0, 'gD')\naxs[0, 2].set_title('change outlier\\npoint symbols')\n\n# don't show outlier points\naxs[1, 0].boxplot(data, 0, '')\naxs[1, 0].set_title(\"don't show\\noutlier points\")\n\n# horizontal boxes\naxs[1, 1].boxplot(data, 0, 'rs', 0)\naxs[1, 1].set_title('horizontal boxes')\n\n# change whisker length\naxs[1, 2].boxplot(data, 0, 'rs', 0, 0.75)\naxs[1, 2].set_title('change whisker length')\n\nfig.subplots_adjust(left=0.08, right=0.98, bottom=0.05, top=0.9,\n                    hspace=0.4, wspace=0.3)\n\n# fake up some more data\nspread = np.random.rand(50) * 100\ncenter = np.ones(25) * 40\nflier_high = np.random.rand(10) * 100 + 100\nflier_low = np.random.rand(10) * -100\nd2 = np.concatenate((spread, center, flier_high, flier_low))\n# Making a 2-D array only works if all the columns are the\n# same length.  If they are not, then use a list instead.\n# This is actually more efficient because boxplot converts\n# a 2-D array into a list of vectors internally anyway.\ndata = [data, d2, d2[::2]]\n\n# Multiple box plots on one Axes\nfig, ax = plt.subplots()\nax.boxplot(data)\n\nplt.show()\n\n\n# %%\n# Below we'll generate data from five different probability distributions,\n# each with different characteristics. We want to play with how an IID\n# bootstrap resample of the data preserves the distributional\n# properties of the original sample, and a boxplot is one visual tool\n# to make this assessment\n\nrandom_dists = ['Normal(1, 1)', 'Lognormal(1, 1)', 'Exp(1)', 'Gumbel(6, 4)',\n                'Triangular(2, 9, 11)']\nN = 500\n\nnorm = np.random.normal(1, 1, N)\nlogn = np.random.lognormal(1, 1, N)\nexpo = np.random.exponential(1, N)\ngumb = np.random.gumbel(6, 4, N)\ntria = np.random.triangular(2, 9, 11, N)\n\n# Generate some random indices that we'll use to resample the original data\n# arrays. For code brevity, just use the same random indices for each array\nbootstrap_indices = np.random.randint(0, N, N)\ndata = [\n    norm, norm[bootstrap_indices],\n    logn, logn[bootstrap_indices],\n    expo, expo[bootstrap_indices],\n    gumb, gumb[bootstrap_indices],\n    tria, tria[bootstrap_indices],\n]\n\nfig, ax1 = plt.subplots(figsize=(10, 6))\nfig.canvas.manager.set_window_title('A Boxplot Example')\nfig.subplots_adjust(left=0.075, right=0.95, top=0.9, bottom=0.25)\n\nbp = ax1.boxplot(data, notch=False, sym='+', vert=True, whis=1.5)\nplt.setp(bp['boxes'], color='black')\nplt.setp(bp['whiskers'], color='black')\nplt.setp(bp['fliers'], color='red', marker='+')\n\n# Add a horizontal grid to the plot, but make it very light in color\n# so we can use it for reading data values but not be distracting\nax1.yaxis.grid(True, linestyle='-', which='major', color='lightgrey',\n               alpha=0.5)\n\nax1.set(\n    axisbelow=True,  # Hide the grid behind plot objects\n    title='Comparison of IID Bootstrap Resampling Across Five Distributions',\n    xlabel='Distribution',\n    ylabel='Value',\n)\n\n# Now fill the boxes with desired colors\nbox_colors = ['darkkhaki', 'royalblue']\nnum_boxes = len(data)\nmedians = np.empty(num_boxes)\nfor i in range(num_boxes):\n    box = bp['boxes'][i]\n    box_x = []\n    box_y = []\n    for j in range(5):\n        box_x.append(box.get_xdata()[j])\n        box_y.append(box.get_ydata()[j])\n    box_coords = np.column_stack([box_x, box_y])\n    # Alternate between Dark Khaki and Royal Blue\n    ax1.add_patch(Polygon(box_coords, facecolor=box_colors[i % 2]))\n    # Now draw the median lines back over what we just filled in\n    med = bp['medians'][i]\n    median_x = []\n    median_y = []\n    for j in range(2):\n        median_x.append(med.get_xdata()[j])\n        median_y.append(med.get_ydata()[j])\n        ax1.plot(median_x, median_y, 'k')\n    medians[i] = median_y[0]\n    # Finally, overplot the sample averages, with horizontal alignment\n    # in the center of each box\n    ax1.plot(np.average(med.get_xdata()), np.average(data[i]),\n             color='w', marker='*', markeredgecolor='k')\n\n# Set the axes ranges and axes labels\nax1.set_xlim(0.5, num_boxes + 0.5)\ntop = 40\nbottom = -5\nax1.set_ylim(bottom, top)\nax1.set_xticklabels(np.repeat(random_dists, 2),\n                    rotation=45, fontsize=8)\n\n# Due to the Y-axis scale being different across samples, it can be\n# hard to compare differences in medians across the samples. Add upper\n# X-axis tick labels with the sample medians to aid in comparison\n# (just use two decimal places of precision)\npos = np.arange(num_boxes) + 1\nupper_labels = [str(round(s, 2)) for s in medians]\nweights = ['bold', 'semibold']\nfor tick, label in zip(range(num_boxes), ax1.get_xticklabels()):\n    k = tick % 2\n    ax1.text(pos[tick], .95, upper_labels[tick],\n             transform=ax1.get_xaxis_transform(),\n             horizontalalignment='center', size='x-small',\n             weight=weights[k], color=box_colors[k])\n\n# Finally, add a basic legend\nfig.text(0.80, 0.08, f'{N} Random Numbers',\n         backgroundcolor=box_colors[0], color='black', weight='roman',\n         size='x-small')\nfig.text(0.80, 0.045, 'IID Bootstrap Resample',\n         backgroundcolor=box_colors[1],\n         color='white', weight='roman', size='x-small')\nfig.text(0.80, 0.015, '*', color='white', backgroundcolor='silver',\n         weight='roman', size='medium')\nfig.text(0.815, 0.013, ' Average Value', color='black', weight='roman',\n         size='x-small')\n\nplt.show()\n\n# %%\n# Here we write a custom function to bootstrap confidence intervals.\n# We can then use the boxplot along with this function to show these intervals.\n\n\ndef fake_bootstrapper(n):\n    \"\"\"\n    This is just a placeholder for the user's method of\n    bootstrapping the median and its confidence intervals.\n\n    Returns an arbitrary median and confidence interval packed into a tuple.\n    \"\"\"\n    if n == 1:\n        med = 0.1\n        ci = (-0.25, 0.25)\n    else:\n        med = 0.2\n        ci = (-0.35, 0.50)\n    return med, ci\n\ninc = 0.1\ne1 = np.random.normal(0, 1, size=500)\ne2 = np.random.normal(0, 1, size=500)\ne3 = np.random.normal(0, 1 + inc, size=500)\ne4 = np.random.normal(0, 1 + 2*inc, size=500)\n\ntreatments = [e1, e2, e3, e4]\nmed1, ci1 = fake_bootstrapper(1)\nmed2, ci2 = fake_bootstrapper(2)\nmedians = [None, None, med1, med2]\nconf_intervals = [None, None, ci1, ci2]\n\nfig, ax = plt.subplots()\npos = np.arange(len(treatments)) + 1\nbp = ax.boxplot(treatments, sym='k+', positions=pos,\n                notch=True, bootstrap=5000,\n                usermedians=medians,\n                conf_intervals=conf_intervals)\n\nax.set_xlabel('treatment')\nax.set_ylabel('response')\nplt.setp(bp['whiskers'], color='k', linestyle='-')\nplt.setp(bp['fliers'], markersize=3.0)\nplt.show()\n\n\n# %%\n# Here we customize the widths of the caps .\n\nx = np.linspace(-7, 7, 140)\nx = np.hstack([-25, x, 25])\nfig, ax = plt.subplots()\n\nax.boxplot([x, x], notch=True, capwidths=[0.01, 0.2])\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.boxplot` / `matplotlib.pyplot.boxplot`\n#    - `matplotlib.artist.Artist.set` / `matplotlib.pyplot.setp`"
      },
      {
        "image_path": "gallery_assets/04statistics_126_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===================================\nBox plot vs. violin plot comparison\n===================================\n\nNote that although violin plots are closely related to Tukey's (1977)\nbox plots, they add useful information such as the distribution of the\nsample data (density trace).\n\nBy default, box plots show data points outside 1.5 * the inter-quartile\nrange as outliers above or below the whiskers whereas violin plots show\nthe whole range of the data.\n\nA good general reference on boxplots and their history can be found\nhere: http://vita.had.co.nz/papers/boxplots.pdf\n\nViolin plots require matplotlib >= 1.4.\n\nFor more information on violin plots, the scikit-learn docs have a great\nsection: https://scikit-learn.org/stable/modules/density.html\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, axs = plt.subplots(nrows=1, ncols=2, figsize=(9, 4))\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# generate some random test data\nall_data = [np.random.normal(0, std, 100) for std in range(6, 10)]\n\n# plot violin plot\naxs[0].violinplot(all_data,\n                  showmeans=False,\n                  showmedians=True)\naxs[0].set_title('Violin plot')\n\n# plot box plot\naxs[1].boxplot(all_data)\naxs[1].set_title('Box plot')\n\n# adding horizontal grid lines\nfor ax in axs:\n    ax.yaxis.grid(True)\n    ax.set_xticks([y + 1 for y in range(len(all_data))],\n                  labels=['x1', 'x2', 'x3', 'x4'])\n    ax.set_xlabel('Four separate samples')\n    ax.set_ylabel('Observed values')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.boxplot` / `matplotlib.pyplot.boxplot`\n#    - `matplotlib.axes.Axes.violinplot` / `matplotlib.pyplot.violinplot`"
      },
      {
        "image_path": "gallery_assets/04statistics_127_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======================\nBoxplot drawer function\n=======================\n\nThis example demonstrates how to pass pre-computed box plot\nstatistics to the box plot drawer. The first figure demonstrates\nhow to remove and add individual components (note that the\nmean is the only value not shown by default). The second\nfigure demonstrates how the styles of the artists can\nbe customized.\n\nA good general reference on boxplots and their history can be found\nhere: http://vita.had.co.nz/papers/boxplots.pdf\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\n\n# fake data\nnp.random.seed(19680801)\ndata = np.random.lognormal(size=(37, 4), mean=1.5, sigma=1.75)\nlabels = list('ABCD')\n\n# compute the boxplot stats\nstats = cbook.boxplot_stats(data, labels=labels, bootstrap=10000)\n\n# %%\n# After we've computed the stats, we can go through and change anything.\n# Just to prove it, I'll set the median of each set to the median of all\n# the data, and double the means\n\nfor n in range(len(stats)):\n    stats[n]['med'] = np.median(data)\n    stats[n]['mean'] *= 2\n\nprint(list(stats[0]))\n\nfs = 10  # fontsize\n\n# %%\n# Demonstrate how to toggle the display of different elements:\n\nfig, axs = plt.subplots(nrows=2, ncols=3, figsize=(6, 6), sharey=True)\naxs[0, 0].bxp(stats)\naxs[0, 0].set_title('Default', fontsize=fs)\n\naxs[0, 1].bxp(stats, showmeans=True)\naxs[0, 1].set_title('showmeans=True', fontsize=fs)\n\naxs[0, 2].bxp(stats, showmeans=True, meanline=True)\naxs[0, 2].set_title('showmeans=True,\\nmeanline=True', fontsize=fs)\n\naxs[1, 0].bxp(stats, showbox=False, showcaps=False)\ntufte_title = 'Tufte Style\\n(showbox=False,\\nshowcaps=False)'\naxs[1, 0].set_title(tufte_title, fontsize=fs)\n\naxs[1, 1].bxp(stats, shownotches=True)\naxs[1, 1].set_title('notch=True', fontsize=fs)\n\naxs[1, 2].bxp(stats, showfliers=False)\naxs[1, 2].set_title('showfliers=False', fontsize=fs)\n\nfor ax in axs.flat:\n    ax.set_yscale('log')\n    ax.set_yticklabels([])\n\nfig.subplots_adjust(hspace=0.4)\nplt.show()\n\n# %%\n# Demonstrate how to customize the display different elements:\n\nboxprops = dict(linestyle='--', linewidth=3, color='darkgoldenrod')\nflierprops = dict(marker='o', markerfacecolor='green', markersize=12,\n                  linestyle='none')\nmedianprops = dict(linestyle='-.', linewidth=2.5, color='firebrick')\nmeanpointprops = dict(marker='D', markeredgecolor='black',\n                      markerfacecolor='firebrick')\nmeanlineprops = dict(linestyle='--', linewidth=2.5, color='purple')\n\nfig, axs = plt.subplots(nrows=2, ncols=2, figsize=(6, 6), sharey=True)\naxs[0, 0].bxp(stats, boxprops=boxprops)\naxs[0, 0].set_title('Custom boxprops', fontsize=fs)\n\naxs[0, 1].bxp(stats, flierprops=flierprops, medianprops=medianprops)\naxs[0, 1].set_title('Custom medianprops\\nand flierprops', fontsize=fs)\n\naxs[1, 0].bxp(stats, meanprops=meanpointprops, meanline=False,\n              showmeans=True)\naxs[1, 0].set_title('Custom mean\\nas point', fontsize=fs)\n\naxs[1, 1].bxp(stats, meanprops=meanlineprops, meanline=True,\n              showmeans=True)\naxs[1, 1].set_title('Custom mean\\nas line', fontsize=fs)\n\nfor ax in axs.flat:\n    ax.set_yscale('log')\n    ax.set_yticklabels([])\n\nfig.suptitle(\"I never said they'd be pretty\")\nfig.subplots_adjust(hspace=0.4)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.bxp`\n#    - `matplotlib.cbook.boxplot_stats`"
      },
      {
        "image_path": "gallery_assets/04statistics_128_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n======================================================\nPlot a confidence ellipse of a two-dimensional dataset\n======================================================\n\nThis example shows how to plot a confidence ellipse of a\ntwo-dimensional dataset, using its pearson correlation coefficient.\n\nThe approach that is used to obtain the correct geometry is\nexplained and proved here:\n\nhttps://carstenschelp.github.io/2018/09/14/Plot_Confidence_Ellipse_001.html\n\nThe method avoids the use of an iterative eigen decomposition algorithm\nand makes use of the fact that a normalized covariance matrix (composed of\npearson correlation coefficients and ones) is particularly easy to handle.\n\"\"\"\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Ellipse\nimport matplotlib.transforms as transforms\n\n# %%\n#\n# The plotting function itself\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# This function plots the confidence ellipse of the covariance of the given\n# array-like variables x and y. The ellipse is plotted into the given\n# axes-object ax.\n#\n# The radiuses of the ellipse can be controlled by n_std which is the number\n# of standard deviations. The default value is 3 which makes the ellipse\n# enclose 98.9% of the points if the data is normally distributed\n# like in these examples (3 standard deviations in 1-D contain 99.7%\n# of the data, which is 98.9% of the data in 2-D).\n\n\ndef confidence_ellipse(x, y, ax, n_std=3.0, facecolor='none', **kwargs):\n    \"\"\"\n    Create a plot of the covariance confidence ellipse of *x* and *y*.\n\n    Parameters\n    ----------\n    x, y : array-like, shape (n, )\n        Input data.\n\n    ax : matplotlib.axes.Axes\n        The axes object to draw the ellipse into.\n\n    n_std : float\n        The number of standard deviations to determine the ellipse's radiuses.\n\n    **kwargs\n        Forwarded to `~matplotlib.patches.Ellipse`\n\n    Returns\n    -------\n    matplotlib.patches.Ellipse\n    \"\"\"\n    if x.size != y.size:\n        raise ValueError(\"x and y must be the same size\")\n\n    cov = np.cov(x, y)\n    pearson = cov[0, 1]/np.sqrt(cov[0, 0] * cov[1, 1])\n    # Using a special case to obtain the eigenvalues of this\n    # two-dimensional dataset.\n    ell_radius_x = np.sqrt(1 + pearson)\n    ell_radius_y = np.sqrt(1 - pearson)\n    ellipse = Ellipse((0, 0), width=ell_radius_x * 2, height=ell_radius_y * 2,\n                      facecolor=facecolor, **kwargs)\n\n    # Calculating the standard deviation of x from\n    # the squareroot of the variance and multiplying\n    # with the given number of standard deviations.\n    scale_x = np.sqrt(cov[0, 0]) * n_std\n    mean_x = np.mean(x)\n\n    # calculating the standard deviation of y ...\n    scale_y = np.sqrt(cov[1, 1]) * n_std\n    mean_y = np.mean(y)\n\n    transf = transforms.Affine2D() \\\n        .rotate_deg(45) \\\n        .scale(scale_x, scale_y) \\\n        .translate(mean_x, mean_y)\n\n    ellipse.set_transform(transf + ax.transData)\n    return ax.add_patch(ellipse)\n\n\n# %%\n#\n# A helper function to create a correlated dataset\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# Creates a random two-dimensional dataset with the specified\n# two-dimensional mean (mu) and dimensions (scale).\n# The correlation can be controlled by the param 'dependency',\n# a 2x2 matrix.\n\ndef get_correlated_dataset(n, dependency, mu, scale):\n    latent = np.random.randn(n, 2)\n    dependent = latent.dot(dependency)\n    scaled = dependent * scale\n    scaled_with_offset = scaled + mu\n    # return x and y of the new, correlated dataset\n    return scaled_with_offset[:, 0], scaled_with_offset[:, 1]\n\n\n# %%\n#\n# Positive, negative and weak correlation\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# Note that the shape for the weak correlation (right) is an ellipse,\n# not a circle because x and y are differently scaled.\n# However, the fact that x and y are uncorrelated is shown by\n# the axes of the ellipse being aligned with the x- and y-axis\n# of the coordinate system.\n\nnp.random.seed(0)\n\nPARAMETERS = {\n    'Positive correlation': [[0.85, 0.35],\n                             [0.15, -0.65]],\n    'Negative correlation': [[0.9, -0.4],\n                             [0.1, -0.6]],\n    'Weak correlation': [[1, 0],\n                         [0, 1]],\n}\n\nmu = 2, 4\nscale = 3, 5\n\nfig, axs = plt.subplots(1, 3, figsize=(9, 3))\nfor ax, (title, dependency) in zip(axs, PARAMETERS.items()):\n    x, y = get_correlated_dataset(800, dependency, mu, scale)\n    ax.scatter(x, y, s=0.5)\n\n    ax.axvline(c='grey', lw=1)\n    ax.axhline(c='grey', lw=1)\n\n    confidence_ellipse(x, y, ax, edgecolor='red')\n\n    ax.scatter(mu[0], mu[1], c='red', s=3)\n    ax.set_title(title)\n\nplt.show()\n\n\n# %%\n#\n# Different number of standard deviations\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# A plot with n_std = 3 (blue), 2 (purple) and 1 (red)\n\nfig, ax_nstd = plt.subplots(figsize=(6, 6))\n\ndependency_nstd = [[0.8, 0.75],\n                   [-0.2, 0.35]]\nmu = 0, 0\nscale = 8, 5\n\nax_nstd.axvline(c='grey', lw=1)\nax_nstd.axhline(c='grey', lw=1)\n\nx, y = get_correlated_dataset(500, dependency_nstd, mu, scale)\nax_nstd.scatter(x, y, s=0.5)\n\nconfidence_ellipse(x, y, ax_nstd, n_std=1,\n                   label=r'$1\\sigma$', edgecolor='firebrick')\nconfidence_ellipse(x, y, ax_nstd, n_std=2,\n                   label=r'$2\\sigma$', edgecolor='fuchsia', linestyle='--')\nconfidence_ellipse(x, y, ax_nstd, n_std=3,\n                   label=r'$3\\sigma$', edgecolor='blue', linestyle=':')\n\nax_nstd.scatter(mu[0], mu[1], c='red', s=3)\nax_nstd.set_title('Different standard deviations')\nax_nstd.legend()\nplt.show()\n\n\n# %%\n#\n# Using the keyword arguments\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# Use the keyword arguments specified for `matplotlib.patches.Patch` in order\n# to have the ellipse rendered in different ways.\n\nfig, ax_kwargs = plt.subplots(figsize=(6, 6))\ndependency_kwargs = [[-0.8, 0.5],\n                     [-0.2, 0.5]]\nmu = 2, -3\nscale = 6, 5\n\nax_kwargs.axvline(c='grey', lw=1)\nax_kwargs.axhline(c='grey', lw=1)\n\nx, y = get_correlated_dataset(500, dependency_kwargs, mu, scale)\n# Plot the ellipse with zorder=0 in order to demonstrate\n# its transparency (caused by the use of alpha).\nconfidence_ellipse(x, y, ax_kwargs,\n                   alpha=0.5, facecolor='pink', edgecolor='purple', zorder=0)\n\nax_kwargs.scatter(x, y, s=0.5)\nax_kwargs.scatter(mu[0], mu[1], c='red', s=3)\nax_kwargs.set_title('Using keyword arguments')\n\nfig.subplots_adjust(hspace=0.25)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.transforms.Affine2D`\n#    - `matplotlib.patches.Ellipse`"
      },
      {
        "image_path": "gallery_assets/04statistics_129_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========================\nViolin plot customization\n=========================\n\nThis example demonstrates how to fully customize violin plots. The first plot\nshows the default style by providing only the data. The second plot first\nlimits what Matplotlib draws with additional keyword arguments. Then a\nsimplified representation of a box plot is drawn on top. Lastly, the styles of\nthe artists of the violins are modified.\n\nFor more information on violin plots, the scikit-learn docs have a great\nsection: https://scikit-learn.org/stable/modules/density.html\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef adjacent_values(vals, q1, q3):\n    upper_adjacent_value = q3 + (q3 - q1) * 1.5\n    upper_adjacent_value = np.clip(upper_adjacent_value, q3, vals[-1])\n\n    lower_adjacent_value = q1 - (q3 - q1) * 1.5\n    lower_adjacent_value = np.clip(lower_adjacent_value, vals[0], q1)\n    return lower_adjacent_value, upper_adjacent_value\n\n\ndef set_axis_style(ax, labels):\n    ax.set_xticks(np.arange(1, len(labels) + 1), labels=labels)\n    ax.set_xlim(0.25, len(labels) + 0.75)\n    ax.set_xlabel('Sample name')\n\n\n# create test data\nnp.random.seed(19680801)\ndata = [sorted(np.random.normal(0, std, 100)) for std in range(1, 5)]\n\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(9, 4), sharey=True)\n\nax1.set_title('Default violin plot')\nax1.set_ylabel('Observed values')\nax1.violinplot(data)\n\nax2.set_title('Customized violin plot')\nparts = ax2.violinplot(\n        data, showmeans=False, showmedians=False,\n        showextrema=False)\n\nfor pc in parts['bodies']:\n    pc.set_facecolor('#D43F3A')\n    pc.set_edgecolor('black')\n    pc.set_alpha(1)\n\nquartile1, medians, quartile3 = np.percentile(data, [25, 50, 75], axis=1)\nwhiskers = np.array([\n    adjacent_values(sorted_array, q1, q3)\n    for sorted_array, q1, q3 in zip(data, quartile1, quartile3)])\nwhiskers_min, whiskers_max = whiskers[:, 0], whiskers[:, 1]\n\ninds = np.arange(1, len(medians) + 1)\nax2.scatter(inds, medians, marker='o', color='white', s=30, zorder=3)\nax2.vlines(inds, quartile1, quartile3, color='k', linestyle='-', lw=5)\nax2.vlines(inds, whiskers_min, whiskers_max, color='k', linestyle='-', lw=1)\n\n# set style for the axes\nlabels = ['A', 'B', 'C', 'D']\nfor ax in [ax1, ax2]:\n    set_axis_style(ax, labels)\n\nplt.subplots_adjust(bottom=0.15, wspace=0.05)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.violinplot` / `matplotlib.pyplot.violinplot`\n#    - `matplotlib.axes.Axes.vlines` / `matplotlib.pyplot.vlines`"
      },
      {
        "image_path": "gallery_assets/04statistics_130_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================\nErrorbar function\n=================\n\nThis exhibits the most basic use of the error bar method.\nIn this case, constant values are provided for the error\nin both the x- and y-directions.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.arange(0.1, 4, 0.5)\ny = np.exp(-x)\n\nfig, ax = plt.subplots()\nax.errorbar(x, y, xerr=0.2, yerr=0.4)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.errorbar` / `matplotlib.pyplot.errorbar`"
      },
      {
        "image_path": "gallery_assets/04statistics_131_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======================================\nDifferent ways of specifying error bars\n=======================================\n\nErrors can be specified as a constant value (as shown in\n:doc:`/gallery/statistics/errorbar`). However, this example demonstrates\nhow they vary by specifying arrays of error values.\n\nIf the raw ``x`` and ``y`` data have length N, there are two options:\n\nArray of shape (N,):\n    Error varies for each point, but the error values are\n    symmetric (i.e. the lower and upper values are equal).\n\nArray of shape (2, N):\n    Error varies for each point, and the lower and upper limits\n    (in that order) are different (asymmetric case)\n\nIn addition, this example demonstrates how to use log\nscale with error bars.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.arange(0.1, 4, 0.5)\ny = np.exp(-x)\n\n# example error bar values that vary with x-position\nerror = 0.1 + 0.2 * x\n\nfig, (ax0, ax1) = plt.subplots(nrows=2, sharex=True)\nax0.errorbar(x, y, yerr=error, fmt='-o')\nax0.set_title('variable, symmetric error')\n\n# error bar values w/ different -/+ errors that\n# also vary with the x-position\nlower_error = 0.4 * error\nupper_error = error\nasymmetric_error = [lower_error, upper_error]\n\nax1.errorbar(x, y, xerr=asymmetric_error, fmt='o')\nax1.set_title('variable, asymmetric error')\nax1.set_yscale('log')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.errorbar` / `matplotlib.pyplot.errorbar`"
      },
      {
        "image_path": "gallery_assets/04statistics_132_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============================================\nIncluding upper and lower limits in error bars\n==============================================\n\nIn matplotlib, errors bars can have \"limits\". Applying limits to the\nerror bars essentially makes the error unidirectional. Because of that,\nupper and lower limits can be applied in both the y- and x-directions\nvia the ``uplims``, ``lolims``, ``xuplims``, and ``xlolims`` parameters,\nrespectively. These parameters can be scalar or boolean arrays.\n\nFor example, if ``xlolims`` is ``True``, the x-error bars will only\nextend from the data towards increasing values. If ``uplims`` is an\narray filled with ``False`` except for the 4th and 7th values, all of the\ny-error bars will be bidirectional, except the 4th and 7th bars, which\nwill extend from the data towards decreasing y-values.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0])\ny = np.exp(-x)\nxerr = 0.1\nyerr = 0.2\n\n# lower & upper limits of the error\nlolims = np.array([0, 0, 1, 0, 1, 0, 0, 0, 1, 0], dtype=bool)\nuplims = np.array([0, 1, 0, 0, 0, 1, 0, 0, 0, 1], dtype=bool)\nls = 'dotted'\n\nfig, ax = plt.subplots(figsize=(7, 4))\n\n# standard error bars\nax.errorbar(x, y, xerr=xerr, yerr=yerr, linestyle=ls)\n\n# including upper limits\nax.errorbar(x, y + 0.5, xerr=xerr, yerr=yerr, uplims=uplims,\n            linestyle=ls)\n\n# including lower limits\nax.errorbar(x, y + 1.0, xerr=xerr, yerr=yerr, lolims=lolims,\n            linestyle=ls)\n\n# including upper and lower limits\nax.errorbar(x, y + 1.5, xerr=xerr, yerr=yerr,\n            lolims=lolims, uplims=uplims,\n            marker='o', markersize=8,\n            linestyle=ls)\n\n# Plot a series with lower and upper limits in both x & y\n# constant x-error with varying y-error\nxerr = 0.2\nyerr = np.full_like(x, 0.2)\nyerr[[3, 6]] = 0.3\n\n# mock up some limits by modifying previous data\nxlolims = lolims\nxuplims = uplims\nlolims = np.zeros_like(x)\nuplims = np.zeros_like(x)\nlolims[[6]] = True  # only limited at this index\nuplims[[3]] = True  # only limited at this index\n\n# do the plotting\nax.errorbar(x, y + 2.1, xerr=xerr, yerr=yerr,\n            xlolims=xlolims, xuplims=xuplims,\n            uplims=uplims, lolims=lolims,\n            marker='o', markersize=8,\n            linestyle='none')\n\n# tidy up the figure\nax.set_xlim((0, 5.5))\nax.set_title('Errorbar upper and lower limits')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.errorbar` / `matplotlib.pyplot.errorbar`"
      },
      {
        "image_path": "gallery_assets/04statistics_133_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n====================================================\nCreating boxes from error bars using PatchCollection\n====================================================\n\nIn this example, we snazz up a pretty standard error bar plot by adding\na rectangle patch defined by the limits of the bars in both the x- and\ny- directions. To do this, we have to write our own custom function\ncalled ``make_error_boxes``. Close inspection of this function will\nreveal the preferred pattern in writing functions for matplotlib:\n\n  1. an `~.axes.Axes` object is passed directly to the function\n  2. the function operates on the ``Axes`` methods directly, not through\n     the ``pyplot`` interface\n  3. plotting keyword arguments that could be abbreviated are spelled out for\n     better code readability in the future (for example we use *facecolor*\n     instead of *fc*)\n  4. the artists returned by the ``Axes`` plotting methods are then\n     returned by the function so that, if desired, their styles\n     can be modified later outside of the function (they are not\n     modified in this example).\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.patches import Rectangle\n\n# Number of data points\nn = 5\n\n# Dummy data\nnp.random.seed(19680801)\nx = np.arange(0, n, 1)\ny = np.random.rand(n) * 5.\n\n# Dummy errors (above and below)\nxerr = np.random.rand(2, n) + 0.1\nyerr = np.random.rand(2, n) + 0.2\n\n\ndef make_error_boxes(ax, xdata, ydata, xerror, yerror, facecolor='r',\n                     edgecolor='none', alpha=0.5):\n\n    # Loop over data points; create box from errors at each point\n    errorboxes = [Rectangle((x - xe[0], y - ye[0]), xe.sum(), ye.sum())\n                  for x, y, xe, ye in zip(xdata, ydata, xerror.T, yerror.T)]\n\n    # Create patch collection with specified colour/alpha\n    pc = PatchCollection(errorboxes, facecolor=facecolor, alpha=alpha,\n                         edgecolor=edgecolor)\n\n    # Add collection to axes\n    ax.add_collection(pc)\n\n    # Plot errorbars\n    artists = ax.errorbar(xdata, ydata, xerr=xerror, yerr=yerror,\n                          fmt='none', ecolor='k')\n\n    return artists\n\n\n# Create figure and axes\nfig, ax = plt.subplots(1)\n\n# Call function to create error boxes\n_ = make_error_boxes(ax, x, y, xerr, yerr)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.errorbar` / `matplotlib.pyplot.errorbar`\n#    - `matplotlib.axes.Axes.add_collection`\n#    - `matplotlib.collections.PatchCollection`"
      },
      {
        "image_path": "gallery_assets/04statistics_134_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=====================\nHexagonal binned plot\n=====================\n\n`~.Axes.hexbin` is a 2D histogram plot, in which the bins are hexagons and\nthe color represents the number of data points within each bin.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nn = 100_000\nx = np.random.standard_normal(n)\ny = 2.0 + 3.0 * x + 4.0 * np.random.standard_normal(n)\nxlim = x.min(), x.max()\nylim = y.min(), y.max()\n\nfig, (ax0, ax1) = plt.subplots(ncols=2, sharey=True, figsize=(9, 4))\n\nhb = ax0.hexbin(x, y, gridsize=50, cmap='inferno')\nax0.set(xlim=xlim, ylim=ylim)\nax0.set_title(\"Hexagon binning\")\ncb = fig.colorbar(hb, ax=ax0, label='counts')\n\nhb = ax1.hexbin(x, y, gridsize=50, bins='log', cmap='inferno')\nax1.set(xlim=xlim, ylim=ylim)\nax1.set_title(\"With a log color scale\")\ncb = fig.colorbar(hb, ax=ax1, label='log10(N)')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.hexbin` / `matplotlib.pyplot.hexbin`"
      },
      {
        "image_path": "gallery_assets/04statistics_135_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========\nHistograms\n==========\n\nHow to plot histograms with Matplotlib.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import colors\nfrom matplotlib.ticker import PercentFormatter\n\n# Create a random number generator with a fixed seed for reproducibility\nrng = np.random.default_rng(19680801)\n\n# %%\n# Generate data and plot a simple histogram\n# -----------------------------------------\n#\n# To generate a 1D histogram we only need a single vector of numbers. For a 2D\n# histogram we'll need a second vector. We'll generate both below, and show\n# the histogram for each vector.\n\nN_points = 100000\nn_bins = 20\n\n# Generate two normal distributions\ndist1 = rng.standard_normal(N_points)\ndist2 = 0.4 * rng.standard_normal(N_points) + 5\n\nfig, axs = plt.subplots(1, 2, sharey=True, tight_layout=True)\n\n# We can set the number of bins with the *bins* keyword argument.\naxs[0].hist(dist1, bins=n_bins)\naxs[1].hist(dist2, bins=n_bins)\n\n\n# %%\n# Updating histogram colors\n# -------------------------\n#\n# The histogram method returns (among other things) a ``patches`` object. This\n# gives us access to the properties of the objects drawn. Using this, we can\n# edit the histogram to our liking. Let's change the color of each bar\n# based on its y value.\n\nfig, axs = plt.subplots(1, 2, tight_layout=True)\n\n# N is the count in each bin, bins is the lower-limit of the bin\nN, bins, patches = axs[0].hist(dist1, bins=n_bins)\n\n# We'll color code by height, but you could use any scalar\nfracs = N / N.max()\n\n# we need to normalize the data to 0..1 for the full range of the colormap\nnorm = colors.Normalize(fracs.min(), fracs.max())\n\n# Now, we'll loop through our objects and set the color of each accordingly\nfor thisfrac, thispatch in zip(fracs, patches):\n    color = plt.cm.viridis(norm(thisfrac))\n    thispatch.set_facecolor(color)\n\n# We can also normalize our inputs by the total number of counts\naxs[1].hist(dist1, bins=n_bins, density=True)\n\n# Now we format the y-axis to display percentage\naxs[1].yaxis.set_major_formatter(PercentFormatter(xmax=1))\n\n\n# %%\n# Plot a 2D histogram\n# -------------------\n#\n# To plot a 2D histogram, one only needs two vectors of the same length,\n# corresponding to each axis of the histogram.\n\nfig, ax = plt.subplots(tight_layout=True)\nhist = ax.hist2d(dist1, dist2)\n\n\n# %%\n# Customizing your histogram\n# --------------------------\n#\n# Customizing a 2D histogram is similar to the 1D case, you can control\n# visual components such as the bin size or color normalization.\n\nfig, axs = plt.subplots(3, 1, figsize=(5, 15), sharex=True, sharey=True,\n                        tight_layout=True)\n\n# We can increase the number of bins on each axis\naxs[0].hist2d(dist1, dist2, bins=40)\n\n# As well as define normalization of the colors\naxs[1].hist2d(dist1, dist2, bins=40, norm=colors.LogNorm())\n\n# We can also define custom numbers of bins for each axis\naxs[2].hist2d(dist1, dist2, bins=(80, 10), norm=colors.LogNorm())\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.hist` / `matplotlib.pyplot.hist`\n#    - `matplotlib.pyplot.hist2d`\n#    - `matplotlib.ticker.PercentFormatter`"
      },
      {
        "image_path": "gallery_assets/04statistics_136_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============================================\nSome features of the histogram (hist) function\n==============================================\n\nIn addition to the basic histogram, this demo shows a few optional features:\n\n* Setting the number of data bins.\n* The *density* parameter, which normalizes bin heights so that the integral of\n  the histogram is 1. The resulting histogram is an approximation of the\n  probability density function.\n\nSelecting different bin counts and sizes can significantly affect the shape\nof a histogram. The Astropy docs have a great section_ on how to select these\nparameters.\n\n.. _section: http://docs.astropy.org/en/stable/visualization/histogram.html\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\n# example data\nmu = 100  # mean of distribution\nsigma = 15  # standard deviation of distribution\nx = mu + sigma * np.random.randn(437)\n\nnum_bins = 50\n\nfig, ax = plt.subplots()\n\n# the histogram of the data\nn, bins, patches = ax.hist(x, num_bins, density=True)\n\n# add a 'best fit' line\ny = ((1 / (np.sqrt(2 * np.pi) * sigma)) *\n     np.exp(-0.5 * (1 / sigma * (bins - mu))**2))\nax.plot(bins, y, '--')\nax.set_xlabel('Smarts')\nax.set_ylabel('Probability density')\nax.set_title(r'Histogram of IQ: $\\mu=100$, $\\sigma=15$')\n\n# Tweak spacing to prevent clipping of ylabel\nfig.tight_layout()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.hist` / `matplotlib.pyplot.hist`\n#    - `matplotlib.axes.Axes.set_title`\n#    - `matplotlib.axes.Axes.set_xlabel`\n#    - `matplotlib.axes.Axes.set_ylabel`"
      },
      {
        "image_path": "gallery_assets/04statistics_137_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================================================================\nDemo of the histogram function's different ``histtype`` settings\n================================================================\n\n* Histogram with step curve that has a color fill.\n* Histogram with step curve with no fill.\n* Histogram with custom and unequal bin widths.\n* Two histograms with stacked bars.\n\nSelecting different bin counts and sizes can significantly affect the\nshape of a histogram. The Astropy docs have a great section on how to\nselect these parameters:\nhttp://docs.astropy.org/en/stable/visualization/histogram.html\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nmu_x = 200\nsigma_x = 25\nx = np.random.normal(mu_x, sigma_x, size=100)\n\nmu_w = 200\nsigma_w = 10\nw = np.random.normal(mu_w, sigma_w, size=100)\n\nfig, axs = plt.subplots(nrows=2, ncols=2)\n\naxs[0, 0].hist(x, 20, density=True, histtype='stepfilled', facecolor='g',\n               alpha=0.75)\naxs[0, 0].set_title('stepfilled')\n\naxs[0, 1].hist(x, 20, density=True, histtype='step', facecolor='g',\n               alpha=0.75)\naxs[0, 1].set_title('step')\n\naxs[1, 0].hist(x, density=True, histtype='barstacked', rwidth=0.8)\naxs[1, 0].hist(w, density=True, histtype='barstacked', rwidth=0.8)\naxs[1, 0].set_title('barstacked')\n\n# Create a histogram by providing the bin edges (unequally spaced).\nbins = [100, 150, 180, 195, 205, 220, 250, 300]\naxs[1, 1].hist(x, bins, density=True, histtype='bar', rwidth=0.8)\naxs[1, 1].set_title('bar, unequal bins')\n\nfig.tight_layout()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.hist` / `matplotlib.pyplot.hist`"
      },
      {
        "image_path": "gallery_assets/04statistics_138_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=====================================================\nThe histogram (hist) function with multiple data sets\n=====================================================\n\nPlot histogram with multiple sample sets and demonstrate:\n\n* Use of legend with multiple sample sets\n* Stacked bars\n* Step curve with no fill\n* Data sets of different sample sizes\n\nSelecting different bin counts and sizes can significantly affect the\nshape of a histogram. The Astropy docs have a great section on how to\nselect these parameters:\nhttp://docs.astropy.org/en/stable/visualization/histogram.html\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nn_bins = 10\nx = np.random.randn(1000, 3)\n\nfig, ((ax0, ax1), (ax2, ax3)) = plt.subplots(nrows=2, ncols=2)\n\ncolors = ['red', 'tan', 'lime']\nax0.hist(x, n_bins, density=True, histtype='bar', color=colors, label=colors)\nax0.legend(prop={'size': 10})\nax0.set_title('bars with legend')\n\nax1.hist(x, n_bins, density=True, histtype='bar', stacked=True)\nax1.set_title('stacked bar')\n\nax2.hist(x, n_bins, histtype='step', stacked=True, fill=False)\nax2.set_title('stack step (unfilled)')\n\n# Make a multiple-histogram of data-sets with different length.\nx_multi = [np.random.randn(n) for n in [10000, 5000, 2000]]\nax3.hist(x_multi, n_bins, histtype='bar')\nax3.set_title('different sample sizes')\n\nfig.tight_layout()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.hist` / `matplotlib.pyplot.hist`"
      },
      {
        "image_path": "gallery_assets/04statistics_139_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========================================\nProducing multiple histograms side by side\n==========================================\n\nThis example plots horizontal histograms of different samples along\na categorical x-axis. Additionally, the histograms are plotted to\nbe symmetrical about their x-position, thus making them very similar\nto violin plots.\n\nTo make this highly specialized plot, we can't use the standard ``hist``\nmethod. Instead, we use ``barh`` to draw the horizontal bars directly. The\nvertical positions and lengths of the bars are computed via the\n``np.histogram`` function. The histograms for all the samples are\ncomputed using the same range (min and max values) and number of bins,\nso that the bins for each sample are in the same vertical positions.\n\nSelecting different bin counts and sizes can significantly affect the\nshape of a histogram. The Astropy docs have a great section on how to\nselect these parameters:\nhttp://docs.astropy.org/en/stable/visualization/histogram.html\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\nnumber_of_bins = 20\n\n# An example of three data sets to compare\nnumber_of_data_points = 387\nlabels = [\"A\", \"B\", \"C\"]\ndata_sets = [np.random.normal(0, 1, number_of_data_points),\n             np.random.normal(6, 1, number_of_data_points),\n             np.random.normal(-3, 1, number_of_data_points)]\n\n# Computed quantities to aid plotting\nhist_range = (np.min(data_sets), np.max(data_sets))\nbinned_data_sets = [\n    np.histogram(d, range=hist_range, bins=number_of_bins)[0]\n    for d in data_sets\n]\nbinned_maximums = np.max(binned_data_sets, axis=1)\nx_locations = np.arange(0, sum(binned_maximums), np.max(binned_maximums))\n\n# The bin_edges are the same for all of the histograms\nbin_edges = np.linspace(hist_range[0], hist_range[1], number_of_bins + 1)\nheights = np.diff(bin_edges)\ncenters = bin_edges[:-1] + heights / 2\n\n# Cycle through and plot each histogram\nfig, ax = plt.subplots()\nfor x_loc, binned_data in zip(x_locations, binned_data_sets):\n    lefts = x_loc - 0.5 * binned_data\n    ax.barh(centers, binned_data, height=heights, left=lefts)\n\nax.set_xticks(x_locations, labels)\n\nax.set_ylabel(\"Data values\")\nax.set_xlabel(\"Data sets\")\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.barh` / `matplotlib.pyplot.barh`"
      },
      {
        "image_path": "gallery_assets/04statistics_140_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=====================\nTime Series Histogram\n=====================\n\nThis example demonstrates how to efficiently visualize large numbers of time\nseries in a way that could potentially reveal hidden substructure and patterns\nthat are not immediately obvious, and display them in a visually appealing way.\n\nIn this example, we generate multiple sinusoidal \"signal\" series that are\nburied under a larger number of random walk \"noise/background\" series. For an\nunbiased Gaussian random walk with standard deviation of \u03c3, the RMS deviation\nfrom the origin after n steps is \u03c3*sqrt(n). So in order to keep the sinusoids\nvisible on the same scale as the random walks, we scale the amplitude by the\nrandom walk RMS. In addition, we also introduce a small random offset ``phi``\nto shift the sines left/right, and some additive random noise to shift\nindividual data points up/down to make the signal a bit more \"realistic\" (you\nwouldn't expect a perfect sine wave to appear in your data).\n\nThe first plot shows the typical way of visualizing multiple time series by\noverlaying them on top of each other with ``plt.plot`` and a small value of\n``alpha``. The second and third plots show how to reinterpret the data as a 2d\nhistogram, with optional interpolation between data points, by using\n``np.histogram2d`` and ``plt.pcolormesh``.\n\"\"\"\nfrom copy import copy\nimport time\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport numpy.matlib\n\nfrom matplotlib.colors import LogNorm\n\nfig, axes = plt.subplots(nrows=3, figsize=(6, 8), layout='constrained')\n\n# Make some data; a 1D random walk + small fraction of sine waves\nnum_series = 1000\nnum_points = 100\nSNR = 0.10  # Signal to Noise Ratio\nx = np.linspace(0, 4 * np.pi, num_points)\n# Generate unbiased Gaussian random walks\nY = np.cumsum(np.random.randn(num_series, num_points), axis=-1)\n# Generate sinusoidal signals\nnum_signal = round(SNR * num_series)\nphi = (np.pi / 8) * np.random.randn(num_signal, 1)  # small random offset\nY[-num_signal:] = (\n    np.sqrt(np.arange(num_points))[None, :]  # random walk RMS scaling factor\n    * (np.sin(x[None, :] - phi)\n       + 0.05 * np.random.randn(num_signal, num_points))  # small random noise\n)\n\n\n# Plot series using `plot` and a small value of `alpha`. With this view it is\n# very difficult to observe the sinusoidal behavior because of how many\n# overlapping series there are. It also takes a bit of time to run because so\n# many individual artists need to be generated.\ntic = time.time()\naxes[0].plot(x, Y.T, color=\"C0\", alpha=0.1)\ntoc = time.time()\naxes[0].set_title(\"Line plot with alpha\")\nprint(f\"{toc-tic:.3f} sec. elapsed\")\n\n\n# Now we will convert the multiple time series into a histogram. Not only will\n# the hidden signal be more visible, but it is also a much quicker procedure.\ntic = time.time()\n# Linearly interpolate between the points in each time series\nnum_fine = 800\nx_fine = np.linspace(x.min(), x.max(), num_fine)\ny_fine = np.empty((num_series, num_fine), dtype=float)\nfor i in range(num_series):\n    y_fine[i, :] = np.interp(x_fine, x, Y[i, :])\ny_fine = y_fine.flatten()\nx_fine = np.matlib.repmat(x_fine, num_series, 1).flatten()\n\n\n# Plot (x, y) points in 2d histogram with log colorscale\n# It is pretty evident that there is some kind of structure under the noise\n# You can tune vmax to make signal more visible\ncmap = copy(plt.cm.plasma)\ncmap.set_bad(cmap(0))\nh, xedges, yedges = np.histogram2d(x_fine, y_fine, bins=[400, 100])\npcm = axes[1].pcolormesh(xedges, yedges, h.T, cmap=cmap,\n                         norm=LogNorm(vmax=1.5e2), rasterized=True)\nfig.colorbar(pcm, ax=axes[1], label=\"# points\", pad=0)\naxes[1].set_title(\"2d histogram and log color scale\")\n\n# Same data but on linear color scale\npcm = axes[2].pcolormesh(xedges, yedges, h.T, cmap=cmap,\n                         vmax=1.5e2, rasterized=True)\nfig.colorbar(pcm, ax=axes[2], label=\"# points\", pad=0)\naxes[2].set_title(\"2d histogram and linear color scale\")\n\ntoc = time.time()\nprint(f\"{toc-tic:.3f} sec. elapsed\")\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pcolormesh` / `matplotlib.pyplot.pcolormesh`\n#    - `matplotlib.figure.Figure.colorbar`"
      },
      {
        "image_path": "gallery_assets/04statistics_141_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================\nViolin plot basics\n==================\n\nViolin plots are similar to histograms and box plots in that they show\nan abstract representation of the probability distribution of the\nsample. Rather than showing counts of data points that fall into bins\nor order statistics, violin plots use kernel density estimation (KDE) to\ncompute an empirical distribution of the sample. That computation\nis controlled by several parameters. This example demonstrates how to\nmodify the number of points at which the KDE is evaluated (``points``)\nand how to modify the bandwidth of the KDE (``bw_method``).\n\nFor more information on violin plots and KDE, the scikit-learn docs\nhave a great section: https://scikit-learn.org/stable/modules/density.html\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# fake data\nfs = 10  # fontsize\npos = [1, 2, 4, 5, 7, 8]\ndata = [np.random.normal(0, std, size=100) for std in pos]\n\nfig, axs = plt.subplots(nrows=2, ncols=5, figsize=(10, 6))\n\naxs[0, 0].violinplot(data, pos, points=20, widths=0.3,\n                     showmeans=True, showextrema=True, showmedians=True)\naxs[0, 0].set_title('Custom violinplot 1', fontsize=fs)\n\naxs[0, 1].violinplot(data, pos, points=40, widths=0.5,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     bw_method='silverman')\naxs[0, 1].set_title('Custom violinplot 2', fontsize=fs)\n\naxs[0, 2].violinplot(data, pos, points=60, widths=0.7, showmeans=True,\n                     showextrema=True, showmedians=True, bw_method=0.5)\naxs[0, 2].set_title('Custom violinplot 3', fontsize=fs)\n\naxs[0, 3].violinplot(data, pos, points=60, widths=0.7, showmeans=True,\n                     showextrema=True, showmedians=True, bw_method=0.5,\n                     quantiles=[[0.1], [], [], [0.175, 0.954], [0.75], [0.25]])\naxs[0, 3].set_title('Custom violinplot 4', fontsize=fs)\n\naxs[0, 4].violinplot(data[-1:], pos[-1:], points=60, widths=0.7,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[0.05, 0.1, 0.8, 0.9], bw_method=0.5)\naxs[0, 4].set_title('Custom violinplot 5', fontsize=fs)\n\naxs[1, 0].violinplot(data, pos, points=80, vert=False, widths=0.7,\n                     showmeans=True, showextrema=True, showmedians=True)\naxs[1, 0].set_title('Custom violinplot 6', fontsize=fs)\n\naxs[1, 1].violinplot(data, pos, points=100, vert=False, widths=0.9,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     bw_method='silverman')\naxs[1, 1].set_title('Custom violinplot 7', fontsize=fs)\n\naxs[1, 2].violinplot(data, pos, points=200, vert=False, widths=1.1,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     bw_method=0.5)\naxs[1, 2].set_title('Custom violinplot 8', fontsize=fs)\n\naxs[1, 3].violinplot(data, pos, points=200, vert=False, widths=1.1,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[[0.1], [], [], [0.175, 0.954], [0.75], [0.25]],\n                     bw_method=0.5)\naxs[1, 3].set_title('Custom violinplot 9', fontsize=fs)\n\naxs[1, 4].violinplot(data[-1:], pos[-1:], points=200, vert=False, widths=1.1,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[0.05, 0.1, 0.8, 0.9], bw_method=0.5)\naxs[1, 4].set_title('Custom violinplot 10', fontsize=fs)\n\n\nfor ax in axs.flat:\n    ax.set_yticklabels([])\n\nfig.suptitle(\"Violin Plotting Examples\")\nfig.subplots_adjust(hspace=0.4)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.violinplot` / `matplotlib.pyplot.violinplot`"
      }
    ],
    "05pie_and_polar_charts": [
      {
        "image_path": "gallery_assets/05pie_and_polar_charts_142_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========\nBar of pie\n==========\n\nMake a \"bar of pie\" chart where the first slice of the pie is\n\"exploded\" into a bar chart with a further breakdown of said slice's\ncharacteristics. The example demonstrates using a figure with multiple\nsets of axes and using the axes patches list to add two ConnectionPatches\nto link the subplot charts.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import ConnectionPatch\n\n# make figure and assign axis objects\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(9, 5))\nfig.subplots_adjust(wspace=0)\n\n# pie chart parameters\noverall_ratios = [.27, .56, .17]\nlabels = ['Approve', 'Disapprove', 'Undecided']\nexplode = [0.1, 0, 0]\n# rotate so that first wedge is split by the x-axis\nangle = -180 * overall_ratios[0]\nwedges, *_ = ax1.pie(overall_ratios, autopct='%1.1f%%', startangle=angle,\n                     labels=labels, explode=explode)\n\n# bar chart parameters\nage_ratios = [.33, .54, .07, .06]\nage_labels = ['Under 35', '35-49', '50-65', 'Over 65']\nbottom = 1\nwidth = .2\n\n# Adding from the top matches the legend.\nfor j, (height, label) in enumerate(reversed([*zip(age_ratios, age_labels)])):\n    bottom -= height\n    bc = ax2.bar(0, height, width, bottom=bottom, color='C0', label=label,\n                 alpha=0.1 + 0.25 * j)\n    ax2.bar_label(bc, labels=[f\"{height:.0%}\"], label_type='center')\n\nax2.set_title('Age of approvers')\nax2.legend()\nax2.axis('off')\nax2.set_xlim(- 2.5 * width, 2.5 * width)\n\n# use ConnectionPatch to draw lines between the two plots\ntheta1, theta2 = wedges[0].theta1, wedges[0].theta2\ncenter, r = wedges[0].center, wedges[0].r\nbar_height = sum(age_ratios)\n\n# draw top connecting line\nx = r * np.cos(np.pi / 180 * theta2) + center[0]\ny = r * np.sin(np.pi / 180 * theta2) + center[1]\ncon = ConnectionPatch(xyA=(-width / 2, bar_height), coordsA=ax2.transData,\n                      xyB=(x, y), coordsB=ax1.transData)\ncon.set_color([0, 0, 0])\ncon.set_linewidth(4)\nax2.add_artist(con)\n\n# draw bottom connecting line\nx = r * np.cos(np.pi / 180 * theta1) + center[0]\ny = r * np.sin(np.pi / 180 * theta1) + center[1]\ncon = ConnectionPatch(xyA=(-width / 2, 0), coordsA=ax2.transData,\n                      xyB=(x, y), coordsB=ax1.transData)\ncon.set_color([0, 0, 0])\nax2.add_artist(con)\ncon.set_linewidth(4)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`\n#    - `matplotlib.axes.Axes.pie` / `matplotlib.pyplot.pie`\n#    - `matplotlib.patches.ConnectionPatch`"
      },
      {
        "image_path": "gallery_assets/05pie_and_polar_charts_143_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================\nNested pie charts\n=================\n\nThe following examples show two ways to build a nested pie chart\nin Matplotlib. Such charts are often referred to as donut charts.\n\nSee also the :doc:`/gallery/specialty_plots/leftventricle_bullseye` example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# %%\n# The most straightforward way to build a pie chart is to use the\n# `~matplotlib.axes.Axes.pie` method.\n#\n# In this case, pie takes values corresponding to counts in a group.\n# We'll first generate some fake data, corresponding to three groups.\n# In the inner circle, we'll treat each number as belonging to its\n# own group. In the outer circle, we'll plot them as members of their\n# original 3 groups.\n#\n# The effect of the donut shape is achieved by setting a ``width`` to\n# the pie's wedges through the *wedgeprops* argument.\n\n\nfig, ax = plt.subplots()\n\nsize = 0.3\nvals = np.array([[60., 32.], [37., 40.], [29., 10.]])\n\ncmap = plt.colormaps[\"tab20c\"]\nouter_colors = cmap(np.arange(3)*4)\ninner_colors = cmap([1, 2, 5, 6, 9, 10])\n\nax.pie(vals.sum(axis=1), radius=1, colors=outer_colors,\n       wedgeprops=dict(width=size, edgecolor='w'))\n\nax.pie(vals.flatten(), radius=1-size, colors=inner_colors,\n       wedgeprops=dict(width=size, edgecolor='w'))\n\nax.set(aspect=\"equal\", title='Pie plot with `ax.pie`')\nplt.show()\n\n# %%\n# However, you can accomplish the same output by using a bar plot on\n# axes with a polar coordinate system. This may give more flexibility on\n# the exact design of the plot.\n#\n# In this case, we need to map x-values of the bar chart onto radians of\n# a circle. The cumulative sum of the values are used as the edges\n# of the bars.\n\nfig, ax = plt.subplots(subplot_kw=dict(projection=\"polar\"))\n\nsize = 0.3\nvals = np.array([[60., 32.], [37., 40.], [29., 10.]])\n# Normalize vals to 2 pi\nvalsnorm = vals/np.sum(vals)*2*np.pi\n# Obtain the ordinates of the bar edges\nvalsleft = np.cumsum(np.append(0, valsnorm.flatten()[:-1])).reshape(vals.shape)\n\ncmap = plt.colormaps[\"tab20c\"]\nouter_colors = cmap(np.arange(3)*4)\ninner_colors = cmap([1, 2, 5, 6, 9, 10])\n\nax.bar(x=valsleft[:, 0],\n       width=valsnorm.sum(axis=1), bottom=1-size, height=size,\n       color=outer_colors, edgecolor='w', linewidth=1, align=\"edge\")\n\nax.bar(x=valsleft.flatten(),\n       width=valsnorm.flatten(), bottom=1-2*size, height=size,\n       color=inner_colors, edgecolor='w', linewidth=1, align=\"edge\")\n\nax.set(title=\"Pie plot with `ax.bar` and polar coordinates\")\nax.set_axis_off()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pie` / `matplotlib.pyplot.pie`\n#    - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`\n#    - `matplotlib.projections.polar`\n#    - ``Axes.set`` (`matplotlib.artist.Artist.set`)\n#    - `matplotlib.axes.Axes.set_axis_off`"
      },
      {
        "image_path": "gallery_assets/05pie_and_polar_charts_144_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========================\nLabeling a pie and a donut\n==========================\n\nWelcome to the Matplotlib bakery. We will create a pie and a donut\nchart through the `pie method <matplotlib.axes.Axes.pie>` and\nshow how to label them with a `legend <matplotlib.axes.Axes.legend>`\nas well as with `annotations <matplotlib.axes.Axes.annotate>`.\n\"\"\"\n\n# %%\n# As usual we would start by defining the imports and create a figure with\n# subplots.\n# Now it's time for the pie. Starting with a pie recipe, we create the data\n# and a list of labels from it.\n#\n# We can provide a function to the ``autopct`` argument, which will expand\n# automatic percentage labeling by showing absolute values; we calculate\n# the latter back from relative data and the known sum of all values.\n#\n# We then create the pie and store the returned objects for later.  The first\n# returned element of the returned tuple is a list of the wedges.  Those are\n# `matplotlib.patches.Wedge` patches, which can directly be used as the handles\n# for a legend. We can use the legend's ``bbox_to_anchor`` argument to position\n# the legend outside of the pie. Here we use the axes coordinates ``(1, 0, 0.5,\n# 1)`` together with the location ``\"center left\"``; i.e. the left central\n# point of the legend will be at the left central point of the bounding box,\n# spanning from ``(1, 0)`` to ``(1.5, 1)`` in axes coordinates.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots(figsize=(6, 3), subplot_kw=dict(aspect=\"equal\"))\n\nrecipe = [\"375 g flour\",\n          \"75 g sugar\",\n          \"250 g butter\",\n          \"300 g berries\"]\n\ndata = [float(x.split()[0]) for x in recipe]\ningredients = [x.split()[-1] for x in recipe]\n\n\ndef func(pct, allvals):\n    absolute = int(np.round(pct/100.*np.sum(allvals)))\n    return f\"{pct:.1f}%\\n({absolute:d} g)\"\n\n\nwedges, texts, autotexts = ax.pie(data, autopct=lambda pct: func(pct, data),\n                                  textprops=dict(color=\"w\"))\n\nax.legend(wedges, ingredients,\n          title=\"Ingredients\",\n          loc=\"center left\",\n          bbox_to_anchor=(1, 0, 0.5, 1))\n\nplt.setp(autotexts, size=8, weight=\"bold\")\n\nax.set_title(\"Matplotlib bakery: A pie\")\n\nplt.show()\n\n\n# %%\n# Now it's time for the donut. Starting with a donut recipe, we transcribe\n# the data to numbers (converting 1 egg to 50 g), and directly plot the pie.\n# The pie? Wait... it's going to be donut, is it not?\n# Well, as we see here, the donut is a pie, having a certain ``width`` set to\n# the wedges, which is different from its radius. It's as easy as it gets.\n# This is done via the ``wedgeprops`` argument.\n#\n# We then want to label the wedges via\n# `annotations <matplotlib.axes.Axes.annotate>`. We first create some\n# dictionaries of common properties, which we can later pass as keyword\n# argument. We then iterate over all wedges and for each\n#\n# * calculate the angle of the wedge's center,\n# * from that obtain the coordinates of the point at that angle on the\n#   circumference,\n# * determine the horizontal alignment of the text, depending on which side\n#   of the circle the point lies,\n# * update the connection style with the obtained angle to have the annotation\n#   arrow point outwards from the donut,\n# * finally, create the annotation with all the previously\n#   determined parameters.\n\n\nfig, ax = plt.subplots(figsize=(6, 3), subplot_kw=dict(aspect=\"equal\"))\n\nrecipe = [\"225 g flour\",\n          \"90 g sugar\",\n          \"1 egg\",\n          \"60 g butter\",\n          \"100 ml milk\",\n          \"1/2 package of yeast\"]\n\ndata = [225, 90, 50, 60, 100, 5]\n\nwedges, texts = ax.pie(data, wedgeprops=dict(width=0.5), startangle=-40)\n\nbbox_props = dict(boxstyle=\"square,pad=0.3\", fc=\"w\", ec=\"k\", lw=0.72)\nkw = dict(arrowprops=dict(arrowstyle=\"-\"),\n          bbox=bbox_props, zorder=0, va=\"center\")\n\nfor i, p in enumerate(wedges):\n    ang = (p.theta2 - p.theta1)/2. + p.theta1\n    y = np.sin(np.deg2rad(ang))\n    x = np.cos(np.deg2rad(ang))\n    horizontalalignment = {-1: \"right\", 1: \"left\"}[int(np.sign(x))]\n    connectionstyle = f\"angle,angleA=0,angleB={ang}\"\n    kw[\"arrowprops\"].update({\"connectionstyle\": connectionstyle})\n    ax.annotate(recipe[i], xy=(x, y), xytext=(1.35*np.sign(x), 1.4*y),\n                horizontalalignment=horizontalalignment, **kw)\n\nax.set_title(\"Matplotlib bakery: A donut\")\n\nplt.show()\n\n# %%\n# And here it is, the donut. Note however, that if we were to use this recipe,\n# the ingredients would suffice for around 6 donuts - producing one huge\n# donut is untested and might result in kitchen errors.\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pie` / `matplotlib.pyplot.pie`\n#    - `matplotlib.axes.Axes.legend` / `matplotlib.pyplot.legend`"
      },
      {
        "image_path": "gallery_assets/05pie_and_polar_charts_145_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n.. redirect-from:: gallery/pie_and_polar_charts/pie_demo2\n\n==========\nPie charts\n==========\n\nDemo of plotting a pie chart.\n\nThis example illustrates various parameters of `~matplotlib.axes.Axes.pie`.\n\"\"\"\n\n# %%\n# Label slices\n# ------------\n#\n# Plot a pie chart of animals and label the slices. To add\n# labels, pass a list of labels to the *labels* parameter\n\nimport matplotlib.pyplot as plt\n\nlabels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\nsizes = [15, 30, 45, 10]\n\nfig, ax = plt.subplots()\nax.pie(sizes, labels=labels)\n\n# %%\n# Each slice of the pie chart is a `.patches.Wedge` object; therefore in\n# addition to the customizations shown here, each wedge can be customized using\n# the *wedgeprops* argument, as demonstrated in\n# :doc:`/gallery/pie_and_polar_charts/nested_pie`.\n#\n# Auto-label slices\n# -----------------\n#\n# Pass a function or format string to *autopct* to label slices.\n\nfig, ax = plt.subplots()\nax.pie(sizes, labels=labels, autopct='%1.1f%%')\n\n# %%\n# By default, the label values are obtained from the percent size of the slice.\n#\n# Color slices\n# ------------\n#\n# Pass a list of colors to *colors* to set the color of each slice.\n\nfig, ax = plt.subplots()\nax.pie(sizes, labels=labels,\n       colors=['olivedrab', 'rosybrown', 'gray', 'saddlebrown'])\n\n# %%\n# Hatch slices\n# ------------\n#\n# Pass a list of hatch patterns to *hatch* to set the pattern of each slice.\n\nfig, ax = plt.subplots()\nax.pie(sizes, labels=labels, hatch=['**O', 'oO', 'O.O', '.||.'])\n\n# %%\n# Swap label and autopct text positions\n# -------------------------------------\n# Use the *labeldistance* and *pctdistance* parameters to position the *labels*\n# and *autopct* text respectively.\n\nfig, ax = plt.subplots()\nax.pie(sizes, labels=labels, autopct='%1.1f%%',\n       pctdistance=1.25, labeldistance=.6)\n\n# %%\n# *labeldistance* and *pctdistance* are ratios of the radius; therefore they\n# vary between ``0`` for the center of the pie and ``1`` for the edge of the\n# pie, and can be set to greater than ``1`` to place text outside the pie.\n#\n# Explode, shade, and rotate slices\n# ---------------------------------\n#\n# In addition to the basic pie chart, this demo shows a few optional features:\n#\n# * offsetting a slice using *explode*\n# * add a drop-shadow using *shadow*\n# * custom start angle using *startangle*\n#\n# This example orders the slices, separates (explodes) them, and rotates them.\n\nexplode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\nfig, ax = plt.subplots()\nax.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',\n       shadow=True, startangle=90)\nplt.show()\n\n# %%\n# The default *startangle* is 0, which would start the first slice (\"Frogs\") on\n# the positive x-axis. This example sets ``startangle = 90`` such that all the\n# slices are rotated counter-clockwise by 90 degrees, and the frog slice starts\n# on the positive y-axis.\n#\n# Controlling the size\n# --------------------\n#\n# By changing the *radius* parameter, and often the text size for better visual\n# appearance, the pie chart can be scaled.\n\nfig, ax = plt.subplots()\n\nax.pie(sizes, labels=labels, autopct='%.0f%%',\n       textprops={'size': 'smaller'}, radius=0.5)\nplt.show()\n\n# %%\n# Modifying the shadow\n# --------------------\n#\n# The *shadow* parameter may optionally take a dictionary with arguments to\n# the `.Shadow` patch. This can be used to modify the default shadow.\n\nfig, ax = plt.subplots()\nax.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',\n       shadow={'ox': -0.04, 'edgecolor': 'none', 'shade': 0.9}, startangle=90)\nplt.show()\n\n# %%\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pie` / `matplotlib.pyplot.pie`"
      },
      {
        "image_path": "gallery_assets/05pie_and_polar_charts_146_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======================\nBar chart on polar axis\n=======================\n\nDemo of bar plot on a polar axis.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# Compute pie slices\nN = 20\ntheta = np.linspace(0.0, 2 * np.pi, N, endpoint=False)\nradii = 10 * np.random.rand(N)\nwidth = np.pi / 4 * np.random.rand(N)\ncolors = plt.cm.viridis(radii / 10.)\n\nax = plt.subplot(projection='polar')\nax.bar(theta, radii, width=width, bottom=0.0, color=colors, alpha=0.5)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`\n#    - `matplotlib.projections.polar`"
      },
      {
        "image_path": "gallery_assets/05pie_and_polar_charts_147_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========\nPolar plot\n==========\n\nDemo of a line plot on a polar axis.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\n\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\nax.plot(theta, r)\nax.set_rmax(2)\nax.set_rticks([0.5, 1, 1.5, 2])  # Less radial ticks\nax.set_rlabel_position(-22.5)  # Move radial labels away from plotted line\nax.grid(True)\n\nax.set_title(\"A line plot on a polar axis\", va='bottom')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`\n#    - `matplotlib.projections.polar`\n#    - `matplotlib.projections.polar.PolarAxes`\n#    - `matplotlib.projections.polar.PolarAxes.set_rticks`\n#    - `matplotlib.projections.polar.PolarAxes.set_rmax`\n#    - `matplotlib.projections.polar.PolarAxes.set_rlabel_position`"
      },
      {
        "image_path": "gallery_assets/05pie_and_polar_charts_148_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================================\nError bar rendering on polar axis\n=================================\n\nDemo of error bar plot in polar coordinates.\nTheta error bars are curved lines ended with caps oriented towards the\ncenter.\nRadius error bars are straight lines oriented towards center with\nperpendicular caps.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ntheta = np.arange(0, 2 * np.pi, np.pi / 4)\nr = theta / np.pi / 2 + 0.5\n\nfig = plt.figure(figsize=(10, 10))\nax = fig.add_subplot(projection='polar')\nax.errorbar(theta, r, xerr=0.25, yerr=0.1, capsize=7, fmt=\"o\", c=\"seagreen\")\nax.set_title(\"Pretty polar error bars\")\nplt.show()\n\n# %%\n# Please acknowledge that large theta error bars will be overlapping.\n# This may reduce readability of the output plot. See example figure below:\n\nfig = plt.figure(figsize=(10, 10))\nax = fig.add_subplot(projection='polar')\nax.errorbar(theta, r, xerr=5.25, yerr=0.1, capsize=7, fmt=\"o\", c=\"darkred\")\nax.set_title(\"Overlapping theta error bars\")\nplt.show()\n\n# %%\n# On the other hand, large radius error bars will never overlap, they just\n# lead to unwanted scale in the data, reducing the displayed range.\n\nfig = plt.figure(figsize=(10, 10))\nax = fig.add_subplot(projection='polar')\nax.errorbar(theta, r, xerr=0.25, yerr=10.1, capsize=7, fmt=\"o\", c=\"orangered\")\nax.set_title(\"Large radius error bars\")\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.errorbar` / `matplotlib.pyplot.errorbar`\n#    - `matplotlib.projections.polar`"
      },
      {
        "image_path": "gallery_assets/05pie_and_polar_charts_149_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============\nPolar legend\n============\n\nUsing a legend on a polar-axis plot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection=\"polar\", facecolor=\"lightgoldenrodyellow\")\n\nr = np.linspace(0, 3, 301)\ntheta = 2 * np.pi * r\nax.plot(theta, r, color=\"tab:orange\", lw=3, label=\"a line\")\nax.plot(0.5 * theta, r, color=\"tab:blue\", ls=\"--\", lw=3, label=\"another line\")\nax.tick_params(grid_color=\"palegoldenrod\")\n# For polar axes, it may be useful to move the legend slightly away from the\n# axes center, to avoid overlap between the legend and the axes.  The following\n# snippet places the legend's lower left corner just outside the polar axes\n# at an angle of 67.5 degrees in polar coordinates.\nangle = np.deg2rad(67.5)\nax.legend(loc=\"lower left\",\n          bbox_to_anchor=(.5 + np.cos(angle)/2, .5 + np.sin(angle)/2))\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`\n#    - `matplotlib.axes.Axes.legend` / `matplotlib.pyplot.legend`\n#    - `matplotlib.projections.polar`\n#    - `matplotlib.projections.polar.PolarAxes`"
      },
      {
        "image_path": "gallery_assets/05pie_and_polar_charts_150_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========================\nScatter plot on polar axis\n==========================\n\nSize increases radially in this example and color increases with angle\n(just to verify the symbols are being scattered correctly).\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# Compute areas and colors\nN = 150\nr = 2 * np.random.rand(N)\ntheta = 2 * np.pi * np.random.rand(N)\narea = 200 * r**2\ncolors = theta\n\nfig = plt.figure()\nax = fig.add_subplot(projection='polar')\nc = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)\n\n# %%\n# Scatter plot on polar axis, with offset origin\n# ----------------------------------------------\n#\n# The main difference with the previous plot is the configuration of the origin\n# radius, producing an annulus. Additionally, the theta zero location is set to\n# rotate the plot.\n\nfig = plt.figure()\nax = fig.add_subplot(projection='polar')\nc = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)\n\nax.set_rorigin(-2.5)\nax.set_theta_zero_location('W', offset=10)\n\n# %%\n# Scatter plot on polar axis confined to a sector\n# -----------------------------------------------\n#\n# The main difference with the previous plots is the configuration of the\n# theta start and end limits, producing a sector instead of a full circle.\n\nfig = plt.figure()\nax = fig.add_subplot(projection='polar')\nc = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)\n\nax.set_thetamin(45)\nax.set_thetamax(135)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.scatter` / `matplotlib.pyplot.scatter`\n#    - `matplotlib.projections.polar`\n#    - `matplotlib.projections.polar.PolarAxes.set_rorigin`\n#    - `matplotlib.projections.polar.PolarAxes.set_theta_zero_location`\n#    - `matplotlib.projections.polar.PolarAxes.set_thetamin`\n#    - `matplotlib.projections.polar.PolarAxes.set_thetamax`"
      }
    ],
    "07color": [
      {
        "image_path": "gallery_assets/07color_151_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nColor by y-value\n================\n\nUse masked arrays to plot a line with different colors by y-value.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\ns = np.sin(2 * np.pi * t)\n\nupper = 0.77\nlower = -0.77\n\nsupper = np.ma.masked_where(s < upper, s)\nslower = np.ma.masked_where(s > lower, s)\nsmiddle = np.ma.masked_where((s < lower) | (s > upper), s)\n\nfig, ax = plt.subplots()\nax.plot(t, smiddle, t, slower, t, supper)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`"
      },
      {
        "image_path": "gallery_assets/07color_152_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n====================================\nColors in the default property cycle\n====================================\n\nDisplay the colors from the default prop_cycle, which is obtained from the\n:ref:`rc parameters<customizing>`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nprop_cycle = plt.rcParams['axes.prop_cycle']\ncolors = prop_cycle.by_key()['color']\n\nlwbase = plt.rcParams['lines.linewidth']\nthin = lwbase / 2\nthick = lwbase * 3\n\nfig, axs = plt.subplots(nrows=2, ncols=2, sharex=True, sharey=True)\nfor icol in range(2):\n    if icol == 0:\n        lwx, lwy = thin, lwbase\n    else:\n        lwx, lwy = lwbase, thick\n    for irow in range(2):\n        for i, color in enumerate(colors):\n            axs[irow, icol].axhline(i, color=color, lw=lwx)\n            axs[irow, icol].axvline(i, color=color, lw=lwy)\n\n    axs[1, icol].set_facecolor('k')\n    axs[1, icol].xaxis.set_ticks(np.arange(0, 10, 2))\n    axs[0, icol].set_title(f'line widths (pts): {lwx:g}, {lwy:g}',\n                           fontsize='medium')\n\nfor irow in range(2):\n    axs[irow, 0].yaxis.set_ticks(np.arange(0, 10, 2))\n\nfig.suptitle('Colors in the default prop_cycle', fontsize='large')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.axhline` / `matplotlib.pyplot.axhline`\n#    - `matplotlib.axes.Axes.axvline` / `matplotlib.pyplot.axvline`\n#    - `matplotlib.axes.Axes.set_facecolor`\n#    - `matplotlib.figure.Figure.suptitle`"
      },
      {
        "image_path": "gallery_assets/07color_153_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========\nColor Demo\n==========\n\nMatplotlib recognizes the following formats to specify a color:\n\n1) an RGB or RGBA tuple of float values in ``[0, 1]`` (e.g. ``(0.1, 0.2, 0.5)``\n   or ``(0.1, 0.2, 0.5, 0.3)``).  RGBA is short for Red, Green, Blue, Alpha;\n2) a hex RGB or RGBA string (e.g., ``'#0F0F0F'`` or ``'#0F0F0F0F'``);\n3) a shorthand hex RGB or RGBA string, equivalent to the hex RGB or RGBA\n   string obtained by duplicating each character, (e.g., ``'#abc'``, equivalent\n   to ``'#aabbcc'``, or ``'#abcd'``, equivalent to ``'#aabbccdd'``);\n4) a string representation of a float value in ``[0, 1]`` inclusive for gray\n   level (e.g., ``'0.5'``);\n5) a single letter string, i.e. one of\n   ``{'b', 'g', 'r', 'c', 'm', 'y', 'k', 'w'}``, which are short-hand notations\n   for shades of blue, green, red, cyan, magenta, yellow, black, and white;\n6) a X11/CSS4 (\"html\") color name, e.g. ``\"blue\"``;\n7) a name from the `xkcd color survey <https://xkcd.com/color/rgb/>`__,\n   prefixed with ``'xkcd:'`` (e.g., ``'xkcd:sky blue'``);\n8) a \"Cn\" color spec, i.e. ``'C'`` followed by a number, which is an index into\n   the default property cycle (:rc:`axes.prop_cycle`); the indexing is intended\n   to occur at rendering time, and defaults to black if the cycle does not\n   include color.\n9) one of ``{'tab:blue', 'tab:orange', 'tab:green', 'tab:red', 'tab:purple',\n   'tab:brown', 'tab:pink', 'tab:gray', 'tab:olive', 'tab:cyan'}`` which are\n   the Tableau Colors from the 'tab10' categorical palette (which is the\n   default color cycle);\n\nFor more information on colors in matplotlib see\n\n* the :ref:`colors_def` tutorial;\n* the `matplotlib.colors` API;\n* the :doc:`/gallery/color/named_colors` example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(0.0, 2.0, 201)\ns = np.sin(2 * np.pi * t)\n\n# 1) RGB tuple:\nfig, ax = plt.subplots(facecolor=(.18, .31, .31))\n# 2) hex string:\nax.set_facecolor('#eafff5')\n# 3) gray level string:\nax.set_title('Voltage vs. time chart', color='0.7')\n# 4) single letter color string\nax.set_xlabel('Time [s]', color='c')\n# 5) a named color:\nax.set_ylabel('Voltage [mV]', color='peachpuff')\n# 6) a named xkcd color:\nax.plot(t, s, 'xkcd:crimson')\n# 7) Cn notation:\nax.plot(t, .7*s, color='C4', linestyle='--')\n# 8) tab notation:\nax.tick_params(labelcolor='tab:orange')\n\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.colors`\n#    - `matplotlib.axes.Axes.plot`\n#    - `matplotlib.axes.Axes.set_facecolor`\n#    - `matplotlib.axes.Axes.set_title`\n#    - `matplotlib.axes.Axes.set_xlabel`\n#    - `matplotlib.axes.Axes.set_ylabel`\n#    - `matplotlib.axes.Axes.tick_params`"
      },
      {
        "image_path": "gallery_assets/07color_154_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========\nColorbar\n========\n\nUse `~.Figure.colorbar` by specifying the mappable object (here\nthe `.AxesImage` returned by `~.axes.Axes.imshow`)\nand the axes to attach the colorbar to.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# setup some generic data\nN = 37\nx, y = np.mgrid[:N, :N]\nZ = (np.cos(x*0.2) + np.sin(y*0.3))\n\n# mask out the negative and positive values, respectively\nZpos = np.ma.masked_less(Z, 0)\nZneg = np.ma.masked_greater(Z, 0)\n\nfig, (ax1, ax2, ax3) = plt.subplots(figsize=(13, 3), ncols=3)\n\n# plot just the positive data and save the\n# color \"mappable\" object returned by ax1.imshow\npos = ax1.imshow(Zpos, cmap='Blues', interpolation='none')\n\n# add the colorbar using the figure's method,\n# telling which mappable we're talking about and\n# which axes object it should be near\nfig.colorbar(pos, ax=ax1)\n\n# repeat everything above for the negative data\n# you can specify location, anchor and shrink the colorbar\nneg = ax2.imshow(Zneg, cmap='Reds_r', interpolation='none')\nfig.colorbar(neg, ax=ax2, location='right', anchor=(0, 0.3), shrink=0.7)\n\n# Plot both positive and negative values between +/- 1.2\npos_neg_clipped = ax3.imshow(Z, cmap='RdBu', vmin=-1.2, vmax=1.2,\n                             interpolation='none')\n# Add minorticks on the colorbar to make it easy to read the\n# values off the colorbar.\ncbar = fig.colorbar(pos_neg_clipped, ax=ax3, extend='both')\ncbar.minorticks_on()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.colorbar.Colorbar.minorticks_on`\n#    - `matplotlib.colorbar.Colorbar.minorticks_off`"
      },
      {
        "image_path": "gallery_assets/07color_155_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================\nColormap reference\n==================\n\nReference for colormaps included with Matplotlib.\n\nA reversed version of each of these colormaps is available by appending\n``_r`` to the name, as shown in :ref:`reverse-cmap`.\n\nSee :ref:`colormaps` for an in-depth discussion about\ncolormaps, including colorblind-friendliness, and\n:ref:`colormap-manipulation` for a guide to creating\ncolormaps.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncmaps = [('Perceptually Uniform Sequential', [\n            'viridis', 'plasma', 'inferno', 'magma', 'cividis']),\n         ('Sequential', [\n            'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds',\n            'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu',\n            'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn']),\n         ('Sequential (2)', [\n            'binary', 'gist_yarg', 'gist_gray', 'gray', 'bone', 'pink',\n            'spring', 'summer', 'autumn', 'winter', 'cool', 'Wistia',\n            'hot', 'afmhot', 'gist_heat', 'copper']),\n         ('Diverging', [\n            'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu',\n            'RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic']),\n         ('Cyclic', ['twilight', 'twilight_shifted', 'hsv']),\n         ('Qualitative', [\n            'Pastel1', 'Pastel2', 'Paired', 'Accent',\n            'Dark2', 'Set1', 'Set2', 'Set3',\n            'tab10', 'tab20', 'tab20b', 'tab20c']),\n         ('Miscellaneous', [\n            'flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern',\n            'gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg',\n            'gist_rainbow', 'rainbow', 'jet', 'turbo', 'nipy_spectral',\n            'gist_ncar'])]\n\ngradient = np.linspace(0, 1, 256)\ngradient = np.vstack((gradient, gradient))\n\n\ndef plot_color_gradients(cmap_category, cmap_list):\n    # Create figure and adjust figure height to number of colormaps\n    nrows = len(cmap_list)\n    figh = 0.35 + 0.15 + (nrows + (nrows-1)*0.1)*0.22\n    fig, axs = plt.subplots(nrows=nrows, figsize=(6.4, figh))\n    fig.subplots_adjust(top=1-.35/figh, bottom=.15/figh, left=0.2, right=0.99)\n\n    axs[0].set_title(f\"{cmap_category} colormaps\", fontsize=14)\n\n    for ax, cmap_name in zip(axs, cmap_list):\n        ax.imshow(gradient, aspect='auto', cmap=cmap_name)\n        ax.text(-.01, .5, cmap_name, va='center', ha='right', fontsize=10,\n                transform=ax.transAxes)\n\n    # Turn off *all* ticks & spines, not just the ones with colormaps.\n    for ax in axs:\n        ax.set_axis_off()\n\n\nfor cmap_category, cmap_list in cmaps:\n    plot_color_gradients(cmap_category, cmap_list)\n\n\n# %%\n# .. _reverse-cmap:\n#\n# Reversed colormaps\n# ------------------\n#\n# Append ``_r`` to the name of any built-in colormap to get the reversed\n# version:\n\nplot_color_gradients(\"Original and reversed \", ['viridis', 'viridis_r'])\n\n# %%\n# The built-in reversed colormaps are generated using `.Colormap.reversed`.\n# For an example, see :ref:`reversing-colormap`\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.colors`\n#    - `matplotlib.axes.Axes.imshow`\n#    - `matplotlib.figure.Figure.text`\n#    - `matplotlib.axes.Axes.set_axis_off`"
      },
      {
        "image_path": "gallery_assets/07color_156_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n====================\nList of named colors\n====================\n\nThis plots a list of the named colors supported in matplotlib.\nFor more information on colors in matplotlib see\n\n* the :ref:`colors_def` tutorial;\n* the `matplotlib.colors` API;\n* the :doc:`/gallery/color/color_demo`.\n\n----------------------------\nHelper Function for Plotting\n----------------------------\nFirst we define a helper function for making a table of colors, then we use it\non some common color categories.\n\"\"\"\n\nimport math\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Rectangle\n\n\ndef plot_colortable(colors, *, ncols=4, sort_colors=True):\n\n    cell_width = 212\n    cell_height = 22\n    swatch_width = 48\n    margin = 12\n\n    # Sort colors by hue, saturation, value and name.\n    if sort_colors is True:\n        names = sorted(\n            colors, key=lambda c: tuple(mcolors.rgb_to_hsv(mcolors.to_rgb(c))))\n    else:\n        names = list(colors)\n\n    n = len(names)\n    nrows = math.ceil(n / ncols)\n\n    width = cell_width * 4 + 2 * margin\n    height = cell_height * nrows + 2 * margin\n    dpi = 72\n\n    fig, ax = plt.subplots(figsize=(width / dpi, height / dpi), dpi=dpi)\n    fig.subplots_adjust(margin/width, margin/height,\n                        (width-margin)/width, (height-margin)/height)\n    ax.set_xlim(0, cell_width * 4)\n    ax.set_ylim(cell_height * (nrows-0.5), -cell_height/2.)\n    ax.yaxis.set_visible(False)\n    ax.xaxis.set_visible(False)\n    ax.set_axis_off()\n\n    for i, name in enumerate(names):\n        row = i % nrows\n        col = i // nrows\n        y = row * cell_height\n\n        swatch_start_x = cell_width * col\n        text_pos_x = cell_width * col + swatch_width + 7\n\n        ax.text(text_pos_x, y, name, fontsize=14,\n                horizontalalignment='left',\n                verticalalignment='center')\n\n        ax.add_patch(\n            Rectangle(xy=(swatch_start_x, y-9), width=swatch_width,\n                      height=18, facecolor=colors[name], edgecolor='0.7')\n        )\n\n    return fig\n\n# %%\n# -----------\n# Base colors\n# -----------\n\nplot_colortable(mcolors.BASE_COLORS, ncols=3, sort_colors=False)\n\n# %%\n# ---------------\n# Tableau Palette\n# ---------------\n\nplot_colortable(mcolors.TABLEAU_COLORS, ncols=2, sort_colors=False)\n\n# %%\n# ----------\n# CSS Colors\n# ----------\n\n# sphinx_gallery_thumbnail_number = 3\nplot_colortable(mcolors.CSS4_COLORS)\nplt.show()\n\n# %%\n# -----------\n# XKCD Colors\n# -----------\n# XKCD colors are supported, but they produce a large figure, so we skip them\n# for now. You can use the following code if desired::\n#\n#     xkcd_fig = plot_colortable(mcolors.XKCD_COLORS)\n#     xkcd_fig.savefig(\"XKCD_Colors.png\")\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.colors`\n#    - `matplotlib.colors.rgb_to_hsv`\n#    - `matplotlib.colors.to_rgba`\n#    - `matplotlib.figure.Figure.get_size_inches`\n#    - `matplotlib.figure.Figure.subplots_adjust`\n#    - `matplotlib.axes.Axes.text`\n#    - `matplotlib.patches.Rectangle`"
      }
    ],
    "08shapes_and_collections": [
      {
        "image_path": "gallery_assets/08shapes_and_collections_157_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========\nArrow guide\n===========\n\nAdding arrow patches to plots.\n\nArrows are often used to annotate plots. This tutorial shows how to plot arrows\nthat behave differently when the data limits on a plot are changed. In general,\npoints on a plot can either be fixed in \"data space\" or \"display space\".\nSomething plotted in data space moves when the data limits are altered - an\nexample would be the points in a scatter plot. Something plotted in display\nspace stays static when data limits are altered - an example would be a\nfigure title or the axis labels.\n\nArrows consist of a head (and possibly a tail) and a stem drawn between a\nstart point and end point, called 'anchor points' from now on.\nHere we show three use cases for plotting arrows, depending on whether the\nhead or anchor points need to be fixed in data or display space:\n\n1. Head shape fixed in display space, anchor points fixed in data space\n2. Head shape and anchor points fixed in display space\n3. Entire patch fixed in data space\n\nBelow each use case is presented in turn.\n\n.. redirect-from:: /gallery/text_labels_and_annotations/arrow_simple_demo\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\n\nx_tail = 0.1\ny_tail = 0.5\nx_head = 0.9\ny_head = 0.8\ndx = x_head - x_tail\ndy = y_head - y_tail\n\n\n# %%\n# Head shape fixed in display space and anchor points fixed in data space\n# -----------------------------------------------------------------------\n#\n# This is useful if you are annotating a plot, and don't want the arrow\n# to change shape or position if you pan or scale the plot.\n#\n# In this case we use `.patches.FancyArrowPatch`.\n#\n# Note that when the axis limits are changed, the arrow shape stays the same,\n# but the anchor points move.\n\nfig, axs = plt.subplots(nrows=2)\narrow = mpatches.FancyArrowPatch((x_tail, y_tail), (x_head, y_head),\n                                 mutation_scale=100)\naxs[0].add_patch(arrow)\n\narrow = mpatches.FancyArrowPatch((x_tail, y_tail), (x_head, y_head),\n                                 mutation_scale=100)\naxs[1].add_patch(arrow)\naxs[1].set(xlim=(0, 2), ylim=(0, 2))\n\n# %%\n# Head shape and anchor points fixed in display space\n# ---------------------------------------------------\n#\n# This is useful if you are annotating a plot, and don't want the arrow to\n# change shape or position if you pan or scale the plot.\n#\n# In this case we use `.patches.FancyArrowPatch`, and pass the keyword argument\n# ``transform=ax.transAxes`` where ``ax`` is the axes we are adding the patch\n# to.\n#\n# Note that when the axis limits are changed, the arrow shape and location\n# stay the same.\n\nfig, axs = plt.subplots(nrows=2)\narrow = mpatches.FancyArrowPatch((x_tail, y_tail), (x_head, y_head),\n                                 mutation_scale=100,\n                                 transform=axs[0].transAxes)\naxs[0].add_patch(arrow)\n\narrow = mpatches.FancyArrowPatch((x_tail, y_tail), (x_head, y_head),\n                                 mutation_scale=100,\n                                 transform=axs[1].transAxes)\naxs[1].add_patch(arrow)\naxs[1].set(xlim=(0, 2), ylim=(0, 2))\n\n\n# %%\n# Head shape and anchor points fixed in data space\n# ------------------------------------------------\n#\n# In this case we use `.patches.Arrow`, or `.patches.FancyArrow` (the latter is\n# in orange).\n#\n# Note that when the axis limits are changed, the arrow shape and location\n# change.\n#\n# `.FancyArrow`'s API is relatively awkward, and requires in particular passing\n# ``length_includes_head=True`` so that the arrow *tip* is ``(dx, dy)`` away\n# from the arrow start.  It is only included in this reference because it is\n# the arrow class returned by `.Axes.arrow` (in green).\n\nfig, axs = plt.subplots(nrows=2)\n\narrow = mpatches.Arrow(x_tail, y_tail, dx, dy)\naxs[0].add_patch(arrow)\narrow = mpatches.FancyArrow(x_tail, y_tail - .4, dx, dy,\n                            width=.1, length_includes_head=True, color=\"C1\")\naxs[0].add_patch(arrow)\naxs[0].arrow(x_tail + 1, y_tail - .4, dx, dy,\n             width=.1, length_includes_head=True, color=\"C2\")\n\narrow = mpatches.Arrow(x_tail, y_tail, dx, dy)\naxs[1].add_patch(arrow)\narrow = mpatches.FancyArrow(x_tail, y_tail - .4, dx, dy,\n                            width=.1, length_includes_head=True, color=\"C1\")\naxs[1].add_patch(arrow)\naxs[1].arrow(x_tail + 1, y_tail - .4, dx, dy,\n             width=.1, length_includes_head=True, color=\"C2\")\naxs[1].set(xlim=(0, 2), ylim=(0, 2))\n\n# %%\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/08shapes_and_collections_158_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n.. _artist_reference:\n\n================================\nReference for Matplotlib artists\n================================\n\nThis example displays several of Matplotlib's graphics primitives (artists).\nA full list of artists is documented at :ref:`the artist API <artist-api>`.\n\nSee also :doc:`/gallery/shapes_and_collections/patch_collection`, which groups\nall artists into a single `.PatchCollection` instead.\n\nCopyright (c) 2010, Bartosz Telenczuk\nBSD License\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib as mpl\nimport matplotlib.lines as mlines\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\n# Prepare the data for the PathPatch below.\nPath = mpath.Path\ncodes, verts = zip(*[\n    (Path.MOVETO, [0.018, -0.11]),\n    (Path.CURVE4, [-0.031, -0.051]),\n    (Path.CURVE4, [-0.115, 0.073]),\n    (Path.CURVE4, [-0.03, 0.073]),\n    (Path.LINETO, [-0.011, 0.039]),\n    (Path.CURVE4, [0.043, 0.121]),\n    (Path.CURVE4, [0.075, -0.005]),\n    (Path.CURVE4, [0.035, -0.027]),\n    (Path.CLOSEPOLY, [0.018, -0.11])])\n\nartists = [\n    mpatches.Circle((0, 0), 0.1, ec=\"none\"),\n    mpatches.Rectangle((-0.025, -0.05), 0.05, 0.1, ec=\"none\"),\n    mpatches.Wedge((0, 0), 0.1, 30, 270, ec=\"none\"),\n    mpatches.RegularPolygon((0, 0), 5, radius=0.1),\n    mpatches.Ellipse((0, 0), 0.2, 0.1),\n    mpatches.Arrow(-0.05, -0.05, 0.1, 0.1, width=0.1),\n    mpatches.PathPatch(mpath.Path(verts, codes), ec=\"none\"),\n    mpatches.FancyBboxPatch((-0.025, -0.05), 0.05, 0.1, ec=\"none\",\n                            boxstyle=mpatches.BoxStyle(\"Round\", pad=0.02)),\n    mlines.Line2D([-0.06, 0.0, 0.1], [0.05, -0.05, 0.05], lw=5),\n]\n\naxs = plt.figure(figsize=(6, 6), layout=\"constrained\").subplots(3, 3)\nfor i, (ax, artist) in enumerate(zip(axs.flat, artists)):\n    artist.set(color=mpl.colormaps[\"hsv\"](i / len(artists)))\n    ax.add_artist(artist)\n    ax.set(title=type(artist).__name__,\n           aspect=1, xlim=(-.2, .2), ylim=(-.2, .2))\n    ax.set_axis_off()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.path`\n#    - `matplotlib.path.Path`\n#    - `matplotlib.lines`\n#    - `matplotlib.lines.Line2D`\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.Circle`\n#    - `matplotlib.patches.Ellipse`\n#    - `matplotlib.patches.Wedge`\n#    - `matplotlib.patches.Rectangle`\n#    - `matplotlib.patches.Arrow`\n#    - `matplotlib.patches.PathPatch`\n#    - `matplotlib.patches.FancyBboxPatch`\n#    - `matplotlib.patches.RegularPolygon`\n#    - `matplotlib.axes.Axes.add_artist`"
      },
      {
        "image_path": "gallery_assets/08shapes_and_collections_159_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========================================================\nLine, Poly and RegularPoly Collection with autoscaling\n=========================================================\n\nFor the first two subplots, we will use spirals.  Their size will be set in\nplot units, not data units.  Their positions will be set in data units by using\nthe *offsets* and *offset_transform* keyword arguments of the `.LineCollection`\nand `.PolyCollection`.\n\nThe third subplot will make regular polygons, with the same\ntype of scaling and positioning as in the first two.\n\nThe last subplot illustrates the use of ``offsets=(xo, yo)``,\nthat is, a single tuple instead of a list of tuples, to generate\nsuccessively offset curves, with the offset given in data\nunits.  This behavior is available only for the LineCollection.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import collections, transforms\n\nnverts = 50\nnpts = 100\n\n# Make some spirals\nr = np.arange(nverts)\ntheta = np.linspace(0, 2*np.pi, nverts)\nxx = r * np.sin(theta)\nyy = r * np.cos(theta)\nspiral = np.column_stack([xx, yy])\n\n# Fixing random state for reproducibility\nrs = np.random.RandomState(19680801)\n\n# Make some offsets\nxyo = rs.randn(npts, 2)\n\n# Make a list of colors cycling through the default series.\ncolors = plt.rcParams['axes.prop_cycle'].by_key()['color']\n\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\nfig.subplots_adjust(top=0.92, left=0.07, right=0.97,\n                    hspace=0.3, wspace=0.3)\n\n\ncol = collections.LineCollection(\n    [spiral], offsets=xyo, offset_transform=ax1.transData)\ntrans = fig.dpi_scale_trans + transforms.Affine2D().scale(1.0/72.0)\ncol.set_transform(trans)  # the points to pixels transform\n# Note: the first argument to the collection initializer\n# must be a list of sequences of (x, y) tuples; we have only\n# one sequence, but we still have to put it in a list.\nax1.add_collection(col, autolim=True)\n# autolim=True enables autoscaling.  For collections with\n# offsets like this, it is neither efficient nor accurate,\n# but it is good enough to generate a plot that you can use\n# as a starting point.  If you know beforehand the range of\n# x and y that you want to show, it is better to set them\n# explicitly, leave out the *autolim* keyword argument (or set it to False),\n# and omit the 'ax1.autoscale_view()' call below.\n\n# Make a transform for the line segments such that their size is\n# given in points:\ncol.set_color(colors)\n\nax1.autoscale_view()  # See comment above, after ax1.add_collection.\nax1.set_title('LineCollection using offsets')\n\n\n# The same data as above, but fill the curves.\ncol = collections.PolyCollection(\n    [spiral], offsets=xyo, offset_transform=ax2.transData)\ntrans = transforms.Affine2D().scale(fig.dpi/72.0)\ncol.set_transform(trans)  # the points to pixels transform\nax2.add_collection(col, autolim=True)\ncol.set_color(colors)\n\n\nax2.autoscale_view()\nax2.set_title('PolyCollection using offsets')\n\n# 7-sided regular polygons\n\ncol = collections.RegularPolyCollection(\n    7, sizes=np.abs(xx) * 10.0, offsets=xyo, offset_transform=ax3.transData)\ntrans = transforms.Affine2D().scale(fig.dpi / 72.0)\ncol.set_transform(trans)  # the points to pixels transform\nax3.add_collection(col, autolim=True)\ncol.set_color(colors)\nax3.autoscale_view()\nax3.set_title('RegularPolyCollection using offsets')\n\n\n# Simulate a series of ocean current profiles, successively\n# offset by 0.1 m/s so that they form what is sometimes called\n# a \"waterfall\" plot or a \"stagger\" plot.\n\nnverts = 60\nncurves = 20\noffs = (0.1, 0.0)\n\nyy = np.linspace(0, 2*np.pi, nverts)\nym = np.max(yy)\nxx = (0.2 + (ym - yy) / ym) ** 2 * np.cos(yy - 0.4) * 0.5\nsegs = []\nfor i in range(ncurves):\n    xxx = xx + 0.02*rs.randn(nverts)\n    curve = np.column_stack([xxx, yy * 100])\n    segs.append(curve)\n\ncol = collections.LineCollection(segs, offsets=offs)\nax4.add_collection(col, autolim=True)\ncol.set_color(colors)\nax4.autoscale_view()\nax4.set_title('Successive data offsets')\nax4.set_xlabel('Zonal velocity component (m/s)')\nax4.set_ylabel('Depth (m)')\n# Reverse the y-axis so depth increases downward\nax4.set_ylim(ax4.get_ylim()[::-1])\n\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.figure.Figure`\n#    - `matplotlib.collections`\n#    - `matplotlib.collections.LineCollection`\n#    - `matplotlib.collections.RegularPolyCollection`\n#    - `matplotlib.axes.Axes.add_collection`\n#    - `matplotlib.axes.Axes.autoscale_view`\n#    - `matplotlib.transforms.Affine2D`\n#    - `matplotlib.transforms.Affine2D.scale`"
      },
      {
        "image_path": "gallery_assets/08shapes_and_collections_160_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============\nCompound path\n=============\n\nMake a compound path -- in this case two simple polygons, a rectangle\nand a triangle.  Use ``CLOSEPOLY`` and ``MOVETO`` for the different parts of\nthe compound path\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\n\nvertices = []\ncodes = []\n\ncodes = [Path.MOVETO] + [Path.LINETO]*3 + [Path.CLOSEPOLY]\nvertices = [(1, 1), (1, 2), (2, 2), (2, 1), (0, 0)]\n\ncodes += [Path.MOVETO] + [Path.LINETO]*2 + [Path.CLOSEPOLY]\nvertices += [(4, 4), (5, 5), (5, 4), (0, 0)]\n\npath = Path(vertices, codes)\n\npathpatch = PathPatch(path, facecolor='none', edgecolor='green')\n\nfig, ax = plt.subplots()\nax.add_patch(pathpatch)\nax.set_title('A compound path')\n\nax.autoscale_view()\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.path`\n#    - `matplotlib.path.Path`\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.PathPatch`\n#    - `matplotlib.axes.Axes.add_patch`\n#    - `matplotlib.axes.Axes.autoscale_view`"
      },
      {
        "image_path": "gallery_assets/08shapes_and_collections_161_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========\nDolphins\n========\n\nThis example shows how to draw, and manipulate shapes given vertices\nand nodes using the `~.path.Path`, `~.patches.PathPatch` and\n`~matplotlib.transforms` classes.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cm as cm\nfrom matplotlib.patches import Circle, PathPatch\nfrom matplotlib.path import Path\nfrom matplotlib.transforms import Affine2D\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nr = np.random.rand(50)\nt = np.random.rand(50) * np.pi * 2.0\nx = r * np.cos(t)\ny = r * np.sin(t)\n\nfig, ax = plt.subplots(figsize=(6, 6))\ncircle = Circle((0, 0), 1, facecolor='none',\n                edgecolor=(0, 0.8, 0.8), linewidth=3, alpha=0.5)\nax.add_patch(circle)\n\nim = plt.imshow(np.random.random((100, 100)),\n                origin='lower', cmap=cm.winter,\n                interpolation='spline36',\n                extent=([-1, 1, -1, 1]))\nim.set_clip_path(circle)\n\nplt.plot(x, y, 'o', color=(0.9, 0.9, 1.0), alpha=0.8)\n\n# Dolphin from OpenClipart library by Andy Fitzsimon\n#   <cc:License rdf:about=\"http://web.resource.org/cc/PublicDomain\">\n#     <cc:permits rdf:resource=\"http://web.resource.org/cc/Reproduction\"/>\n#     <cc:permits rdf:resource=\"http://web.resource.org/cc/Distribution\"/>\n#     <cc:permits rdf:resource=\"http://web.resource.org/cc/DerivativeWorks\"/>\n#   </cc:License>\n\ndolphin = \"\"\"\nM -0.59739425,160.18173 C -0.62740401,160.18885 -0.57867129,160.11183\n-0.57867129,160.11183 C -0.57867129,160.11183 -0.5438361,159.89315\n-0.39514638,159.81496 C -0.24645668,159.73678 -0.18316813,159.71981\n-0.18316813,159.71981 C -0.18316813,159.71981 -0.10322971,159.58124\n-0.057804323,159.58725 C -0.029723983,159.58913 -0.061841603,159.60356\n-0.071265813,159.62815 C -0.080250183,159.65325 -0.082918513,159.70554\n-0.061841203,159.71248 C -0.040763903,159.7194 -0.0066711426,159.71091\n0.077336307,159.73612 C 0.16879567,159.76377 0.28380306,159.86448\n0.31516668,159.91533 C 0.3465303,159.96618 0.5011127,160.1771\n0.5011127,160.1771 C 0.63668998,160.19238 0.67763022,160.31259\n0.66556395,160.32668 C 0.65339985,160.34212 0.66350443,160.33642\n0.64907098,160.33088 C 0.63463742,160.32533 0.61309688,160.297\n0.5789627,160.29339 C 0.54348657,160.28968 0.52329693,160.27674\n0.50728856,160.27737 C 0.49060916,160.27795 0.48965803,160.31565\n0.46114204,160.33673 C 0.43329696,160.35786 0.4570711,160.39871\n0.43309565,160.40685 C 0.4105108,160.41442 0.39416631,160.33027\n0.3954995,160.2935 C 0.39683269,160.25672 0.43807996,160.21522\n0.44567915,160.19734 C 0.45327833,160.17946 0.27946869,159.9424\n-0.061852613,159.99845 C -0.083965233,160.0427 -0.26176109,160.06683\n-0.26176109,160.06683 C -0.30127962,160.07028 -0.21167141,160.09731\n-0.24649368,160.1011 C -0.32642366,160.11569 -0.34521187,160.06895\n-0.40622293,160.0819 C -0.467234,160.09485 -0.56738444,160.17461\n-0.59739425,160.18173\n\"\"\"\n\nvertices = []\ncodes = []\nparts = dolphin.split()\ni = 0\ncode_map = {\n    'M': Path.MOVETO,\n    'C': Path.CURVE4,\n    'L': Path.LINETO,\n}\n\nwhile i < len(parts):\n    path_code = code_map[parts[i]]\n    npoints = Path.NUM_VERTICES_FOR_CODE[path_code]\n    codes.extend([path_code] * npoints)\n    vertices.extend([[*map(float, y.split(','))]\n                     for y in parts[i + 1:][:npoints]])\n    i += npoints + 1\nvertices = np.array(vertices)\nvertices[:, 1] -= 160\n\ndolphin_path = Path(vertices, codes)\ndolphin_patch = PathPatch(dolphin_path, facecolor=(0.6, 0.6, 0.6),\n                          edgecolor=(0.0, 0.0, 0.0))\nax.add_patch(dolphin_patch)\n\nvertices = Affine2D().rotate_deg(60).transform(vertices)\ndolphin_path2 = Path(vertices, codes)\ndolphin_patch2 = PathPatch(dolphin_path2, facecolor=(0.5, 0.5, 0.5),\n                           edgecolor=(0.0, 0.0, 0.0))\nax.add_patch(dolphin_patch2)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.path`\n#    - `matplotlib.path.Path`\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.PathPatch`\n#    - `matplotlib.patches.Circle`\n#    - `matplotlib.axes.Axes.add_patch`\n#    - `matplotlib.transforms`\n#    - `matplotlib.transforms.Affine2D`\n#    - `matplotlib.transforms.Affine2D.rotate_deg`"
      },
      {
        "image_path": "gallery_assets/08shapes_and_collections_162_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "r\"\"\"\n=============\nMmh Donuts!!!\n=============\n\nDraw donuts (miam!) using `~.path.Path`\\s and `~.patches.PathPatch`\\es.\nThis example shows the effect of the path's orientations in a compound path.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\n\ndef wise(v):\n    if v == 1:\n        return \"CCW\"\n    else:\n        return \"CW\"\n\n\ndef make_circle(r):\n    t = np.arange(0, np.pi * 2.0, 0.01)\n    t = t.reshape((len(t), 1))\n    x = r * np.cos(t)\n    y = r * np.sin(t)\n    return np.hstack((x, y))\n\nPath = mpath.Path\n\nfig, ax = plt.subplots()\n\ninside_vertices = make_circle(0.5)\noutside_vertices = make_circle(1.0)\ncodes = np.ones(\n    len(inside_vertices), dtype=mpath.Path.code_type) * mpath.Path.LINETO\ncodes[0] = mpath.Path.MOVETO\n\nfor i, (inside, outside) in enumerate(((1, 1), (1, -1), (-1, 1), (-1, -1))):\n    # Concatenate the inside and outside subpaths together, changing their\n    # order as needed\n    vertices = np.concatenate((outside_vertices[::outside],\n                               inside_vertices[::inside]))\n    # Shift the path\n    vertices[:, 0] += i * 2.5\n    # The codes will be all \"LINETO\" commands, except for \"MOVETO\"s at the\n    # beginning of each subpath\n    all_codes = np.concatenate((codes, codes))\n    # Create the Path object\n    path = mpath.Path(vertices, all_codes)\n    # Add plot it\n    patch = mpatches.PathPatch(path, facecolor='#885500', edgecolor='black')\n    ax.add_patch(patch)\n\n    ax.annotate(f\"Outside {wise(outside)},\\nInside {wise(inside)}\",\n                (i * 2.5, -1.5), va=\"top\", ha=\"center\")\n\nax.set_xlim(-2, 10)\nax.set_ylim(-3, 2)\nax.set_title('Mmm, donuts!')\nax.set_aspect(1.0)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.path`\n#    - `matplotlib.path.Path`\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.PathPatch`\n#    - `matplotlib.patches.Circle`\n#    - `matplotlib.axes.Axes.add_patch`\n#    - `matplotlib.axes.Axes.annotate`\n#    - `matplotlib.axes.Axes.set_aspect`\n#    - `matplotlib.axes.Axes.set_xlim`\n#    - `matplotlib.axes.Axes.set_ylim`\n#    - `matplotlib.axes.Axes.set_title`"
      },
      {
        "image_path": "gallery_assets/08shapes_and_collections_163_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================\nEllipse Collection\n==================\n\nDrawing a collection of ellipses. While this would equally be possible using\na `~.collections.EllipseCollection` or `~.collections.PathCollection`, the use\nof an `~.collections.EllipseCollection` allows for much shorter code.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import EllipseCollection\n\nx = np.arange(10)\ny = np.arange(15)\nX, Y = np.meshgrid(x, y)\n\nXY = np.column_stack((X.ravel(), Y.ravel()))\n\nww = X / 10.0\nhh = Y / 15.0\naa = X * 9\n\n\nfig, ax = plt.subplots()\n\nec = EllipseCollection(ww, hh, aa, units='x', offsets=XY,\n                       offset_transform=ax.transData)\nec.set_array((X + Y).ravel())\nax.add_collection(ec)\nax.autoscale_view()\nax.set_xlabel('X')\nax.set_ylabel('y')\ncbar = plt.colorbar(ec)\ncbar.set_label('X+Y')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.collections`\n#    - `matplotlib.collections.EllipseCollection`\n#    - `matplotlib.axes.Axes.add_collection`\n#    - `matplotlib.axes.Axes.autoscale_view`\n#    - `matplotlib.cm.ScalarMappable.set_array`"
      },
      {
        "image_path": "gallery_assets/08shapes_and_collections_164_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============\nEllipse Demo\n============\n\nDraw many ellipses. Here individual ellipses are drawn. Compare this\nto the :doc:`Ellipse collection example\n</gallery/shapes_and_collections/ellipse_collection>`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Ellipse\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nNUM = 250\n\nells = [Ellipse(xy=np.random.rand(2) * 10,\n                width=np.random.rand(), height=np.random.rand(),\n                angle=np.random.rand() * 360)\n        for i in range(NUM)]\n\nfig, ax = plt.subplots(subplot_kw={'aspect': 'equal'})\nfor e in ells:\n    ax.add_artist(e)\n    e.set_clip_box(ax.bbox)\n    e.set_alpha(np.random.rand())\n    e.set_facecolor(np.random.rand(3))\n\nax.set_xlim(0, 10)\nax.set_ylim(0, 10)\n\nplt.show()\n\n# %%\n# ===============\n# Ellipse Rotated\n# ===============\n#\n# Draw many ellipses with different angles.\n#\n\nangle_step = 45  # degrees\nangles = np.arange(0, 180, angle_step)\n\nfig, ax = plt.subplots(subplot_kw={'aspect': 'equal'})\n\nfor angle in angles:\n    ellipse = Ellipse((0, 0), 4, 2, angle=angle, alpha=0.1)\n    ax.add_artist(ellipse)\n\nax.set_xlim(-2.2, 2.2)\nax.set_ylim(-2.2, 2.2)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.Ellipse`\n#    - `matplotlib.axes.Axes.add_artist`\n#    - `matplotlib.artist.Artist.set_clip_box`\n#    - `matplotlib.artist.Artist.set_alpha`\n#    - `matplotlib.patches.Patch.set_facecolor`"
      },
      {
        "image_path": "gallery_assets/08shapes_and_collections_165_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===================\nDrawing fancy boxes\n===================\n\nThe following examples show how to plot boxes with different visual properties.\n\"\"\"\n\nimport inspect\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatch\nfrom matplotlib.patches import FancyBboxPatch\nimport matplotlib.transforms as mtransforms\n\n# %%\n# First we'll show some sample boxes with fancybox.\n\nstyles = mpatch.BoxStyle.get_styles()\nncol = 2\nnrow = (len(styles) + 1) // ncol\naxs = (plt.figure(figsize=(3 * ncol, 1 + nrow))\n       .add_gridspec(1 + nrow, ncol, wspace=.5).subplots())\nfor ax in axs.flat:\n    ax.set_axis_off()\nfor ax in axs[0, :]:\n    ax.text(.2, .5, \"boxstyle\",\n            transform=ax.transAxes, size=\"large\", color=\"tab:blue\",\n            horizontalalignment=\"right\", verticalalignment=\"center\")\n    ax.text(.4, .5, \"default parameters\",\n            transform=ax.transAxes,\n            horizontalalignment=\"left\", verticalalignment=\"center\")\nfor ax, (stylename, stylecls) in zip(axs[1:, :].T.flat, styles.items()):\n    ax.text(.2, .5, stylename, bbox=dict(boxstyle=stylename, fc=\"w\", ec=\"k\"),\n            transform=ax.transAxes, size=\"large\", color=\"tab:blue\",\n            horizontalalignment=\"right\", verticalalignment=\"center\")\n    ax.text(.4, .5, str(inspect.signature(stylecls))[1:-1].replace(\", \", \"\\n\"),\n            transform=ax.transAxes,\n            horizontalalignment=\"left\", verticalalignment=\"center\")\n\n\n# %%\n# Next we'll show off multiple fancy boxes at once.\n\n\ndef add_fancy_patch_around(ax, bb, **kwargs):\n    fancy = FancyBboxPatch(bb.p0, bb.width, bb.height,\n                           fc=(1, 0.8, 1, 0.5), ec=(1, 0.5, 1, 0.5),\n                           **kwargs)\n    ax.add_patch(fancy)\n    return fancy\n\n\ndef draw_control_points_for_patches(ax):\n    for patch in ax.patches:\n        patch.axes.plot(*patch.get_path().vertices.T, \".\",\n                        c=patch.get_edgecolor())\n\n\nfig, axs = plt.subplots(2, 2, figsize=(8, 8))\n\n# Bbox object around which the fancy box will be drawn.\nbb = mtransforms.Bbox([[0.3, 0.4], [0.7, 0.6]])\n\nax = axs[0, 0]\n# a fancy box with round corners. pad=0.1\nfancy = add_fancy_patch_around(ax, bb, boxstyle=\"round,pad=0.1\")\nax.set(xlim=(0, 1), ylim=(0, 1), aspect=1,\n       title='boxstyle=\"round,pad=0.1\"')\n\nax = axs[0, 1]\n# bbox=round has two optional arguments: pad and rounding_size.\n# They can be set during the initialization.\nfancy = add_fancy_patch_around(ax, bb, boxstyle=\"round,pad=0.1\")\n# The boxstyle and its argument can be later modified with set_boxstyle().\n# Note that the old attributes are simply forgotten even if the boxstyle name\n# is same.\nfancy.set_boxstyle(\"round,pad=0.1,rounding_size=0.2\")\n# or: fancy.set_boxstyle(\"round\", pad=0.1, rounding_size=0.2)\nax.set(xlim=(0, 1), ylim=(0, 1), aspect=1,\n       title='boxstyle=\"round,pad=0.1,rounding_size=0.2\"')\n\nax = axs[1, 0]\n# mutation_scale determines the overall scale of the mutation, i.e. both pad\n# and rounding_size is scaled according to this value.\nfancy = add_fancy_patch_around(\n    ax, bb, boxstyle=\"round,pad=0.1\", mutation_scale=2)\nax.set(xlim=(0, 1), ylim=(0, 1), aspect=1,\n       title='boxstyle=\"round,pad=0.1\"\\n mutation_scale=2')\n\nax = axs[1, 1]\n# When the aspect ratio of the axes is not 1, the fancy box may not be what you\n# expected (green).\nfancy = add_fancy_patch_around(ax, bb, boxstyle=\"round,pad=0.2\")\nfancy.set(facecolor=\"none\", edgecolor=\"green\")\n# You can compensate this by setting the mutation_aspect (pink).\nfancy = add_fancy_patch_around(\n    ax, bb, boxstyle=\"round,pad=0.3\", mutation_aspect=0.5)\nax.set(xlim=(-.5, 1.5), ylim=(0, 1), aspect=2,\n       title='boxstyle=\"round,pad=0.3\"\\nmutation_aspect=.5')\n\nfor ax in axs.flat:\n    draw_control_points_for_patches(ax)\n    # Draw the original bbox (using boxstyle=square with pad=0).\n    fancy = add_fancy_patch_around(ax, bb, boxstyle=\"square,pad=0\")\n    fancy.set(edgecolor=\"black\", facecolor=\"none\", zorder=10)\n\nfig.tight_layout()\n\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.FancyBboxPatch`\n#    - `matplotlib.patches.BoxStyle`\n#    - ``matplotlib.patches.BoxStyle.get_styles``\n#    - `matplotlib.transforms.Bbox`\n#    - `matplotlib.figure.Figure.text`\n#    - `matplotlib.axes.Axes.text`"
      },
      {
        "image_path": "gallery_assets/08shapes_and_collections_166_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========\nHatch demo\n==========\n\nHatches can be added to most polygons in Matplotlib, including `~.Axes.bar`,\n`~.Axes.fill_between`, `~.Axes.contourf`, and children of `~.patches.Polygon`.\nThey are currently supported in the PS, PDF, SVG, OSX, and Agg backends. The WX\nand Cairo backends do not currently support hatching.\n\nSee also :doc:`/gallery/images_contours_and_fields/contourf_hatching` for\nan example using `~.Axes.contourf`, and\n:doc:`/gallery/shapes_and_collections/hatch_style_reference` for swatches\nof the existing hatches.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Ellipse, Polygon\n\nx = np.arange(1, 5)\ny1 = np.arange(1, 5)\ny2 = np.ones(y1.shape) * 4\n\nfig = plt.figure()\naxs = fig.subplot_mosaic([['bar1', 'patches'], ['bar2', 'patches']])\n\naxs['bar1'].bar(x, y1, edgecolor='black', hatch=\"/\")\naxs['bar1'].bar(x, y2, bottom=y1, edgecolor='black', hatch='//')\n\naxs['bar2'].bar(x, y1, edgecolor='black', hatch=['--', '+', 'x', '\\\\'])\naxs['bar2'].bar(x, y2, bottom=y1, edgecolor='black',\n                hatch=['*', 'o', 'O', '.'])\n\nx = np.arange(0, 40, 0.2)\naxs['patches'].fill_between(x, np.sin(x) * 4 + 30, y2=0,\n                            hatch='///', zorder=2, fc='c')\naxs['patches'].add_patch(Ellipse((4, 50), 10, 10, fill=True,\n                                 hatch='*', facecolor='y'))\naxs['patches'].add_patch(Polygon([(10, 20), (30, 50), (50, 10)],\n                                 hatch='\\\\/...', facecolor='g'))\naxs['patches'].set_xlim([0, 40])\naxs['patches'].set_ylim([10, 60])\naxs['patches'].set_aspect(1)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.Ellipse`\n#    - `matplotlib.patches.Polygon`\n#    - `matplotlib.axes.Axes.add_patch`\n#    - `matplotlib.patches.Patch.set_hatch`\n#    - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`"
      },
      {
        "image_path": "gallery_assets/08shapes_and_collections_167_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=====================\nHatch style reference\n=====================\n\nHatches can be added to most polygons in Matplotlib, including `~.Axes.bar`,\n`~.Axes.fill_between`, `~.Axes.contourf`, and children of `~.patches.Polygon`.\nThey are currently supported in the PS, PDF, SVG, OSX, and Agg backends. The WX\nand Cairo backends do not currently support hatching.\n\nSee also :doc:`/gallery/images_contours_and_fields/contourf_hatching` for\nan example using `~.Axes.contourf`, and\n:doc:`/gallery/shapes_and_collections/hatch_demo` for more usage examples.\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.patches import Rectangle\n\nfig, axs = plt.subplots(2, 5, layout='constrained', figsize=(6.4, 3.2))\n\nhatches = ['/', '\\\\', '|', '-', '+', 'x', 'o', 'O', '.', '*']\n\n\ndef hatches_plot(ax, h):\n    ax.add_patch(Rectangle((0, 0), 2, 2, fill=False, hatch=h))\n    ax.text(1, -0.5, f\"' {h} '\", size=15, ha=\"center\")\n    ax.axis('equal')\n    ax.axis('off')\n\nfor ax, h in zip(axs.flat, hatches):\n    hatches_plot(ax, h)\n\n# %%\n# Hatching patterns can be repeated to increase the density.\n\nfig, axs = plt.subplots(2, 5, layout='constrained', figsize=(6.4, 3.2))\n\nhatches = ['//', '\\\\\\\\', '||', '--', '++', 'xx', 'oo', 'OO', '..', '**']\n\nfor ax, h in zip(axs.flat, hatches):\n    hatches_plot(ax, h)\n\n# %%\n# Hatching patterns can be combined to create additional patterns.\n\nfig, axs = plt.subplots(2, 5, layout='constrained', figsize=(6.4, 3.2))\n\nhatches = ['/o', '\\\\|', '|*', '-\\\\', '+o', 'x*', 'o-', 'O|', 'O.', '*-']\n\nfor ax, h in zip(axs.flat, hatches):\n    hatches_plot(ax, h)\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.Rectangle`\n#    - `matplotlib.axes.Axes.add_patch`\n#    - `matplotlib.axes.Axes.text`"
      },
      {
        "image_path": "gallery_assets/08shapes_and_collections_168_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============================================\nPlotting multiple lines with a LineCollection\n=============================================\n\nMatplotlib can efficiently draw multiple lines at once using a\n`~.LineCollection`, as showcased below.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import LineCollection\n\nx = np.arange(100)\n# Here are many sets of y to plot vs. x\nys = x[:50, np.newaxis] + x[np.newaxis, :]\n\nsegs = np.zeros((50, 100, 2))\nsegs[:, :, 1] = ys\nsegs[:, :, 0] = x\n\n# Mask some values to test masked array support:\nsegs = np.ma.masked_where((segs > 50) & (segs < 60), segs)\n\n# We need to set the plot limits, they will not autoscale\nfig, ax = plt.subplots()\nax.set_xlim(x.min(), x.max())\nax.set_ylim(ys.min(), ys.max())\n\n# *colors* is sequence of rgba tuples.\n# *linestyle* is a string or dash tuple. Legal string values are\n# solid|dashed|dashdot|dotted.  The dash tuple is (offset, onoffseq) where\n# onoffseq is an even length tuple of on and off ink in points.  If linestyle\n# is omitted, 'solid' is used.\n# See `matplotlib.collections.LineCollection` for more information.\ncolors = plt.rcParams['axes.prop_cycle'].by_key()['color']\n\nline_segments = LineCollection(segs, linewidths=(0.5, 1, 1.5, 2),\n                               colors=colors, linestyle='solid')\nax.add_collection(line_segments)\nax.set_title('Line collection with masked arrays')\nplt.show()\n\n# %%\n# In the following example, instead of passing a list of colors\n# (``colors=colors``), we pass an array of values (``array=x``) that get\n# colormapped.\n\nN = 50\nx = np.arange(N)\nys = [x + i for i in x]  # Many sets of y to plot vs. x\nsegs = [np.column_stack([x, y]) for y in ys]\n\nfig, ax = plt.subplots()\nax.set_xlim(np.min(x), np.max(x))\nax.set_ylim(np.min(ys), np.max(ys))\n\nline_segments = LineCollection(segs, array=x,\n                               linewidths=(0.5, 1, 1.5, 2),\n                               linestyles='solid')\nax.add_collection(line_segments)\naxcb = fig.colorbar(line_segments)\naxcb.set_label('Line Number')\nax.set_title('Line Collection with mapped colors')\nplt.sci(line_segments)  # This allows interactive changing of the colormap.\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.collections`\n#    - `matplotlib.collections.LineCollection`\n#    - `matplotlib.cm.ScalarMappable.set_array`\n#    - `matplotlib.axes.Axes.add_collection`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.pyplot.sci`"
      },
      {
        "image_path": "gallery_assets/08shapes_and_collections_169_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============================\nCircles, Wedges and Polygons\n============================\n\nThis example demonstrates how to use `.collections.PatchCollection`.\n\nSee also :doc:`/gallery/shapes_and_collections/artist_reference`, which instead\nadds each artist separately to its own axes.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.patches import Circle, Polygon, Wedge\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\n\nresolution = 50  # the number of vertices\nN = 3\nx = np.random.rand(N)\ny = np.random.rand(N)\nradii = 0.1*np.random.rand(N)\npatches = []\nfor x1, y1, r in zip(x, y, radii):\n    circle = Circle((x1, y1), r)\n    patches.append(circle)\n\nx = np.random.rand(N)\ny = np.random.rand(N)\nradii = 0.1*np.random.rand(N)\ntheta1 = 360.0*np.random.rand(N)\ntheta2 = 360.0*np.random.rand(N)\nfor x1, y1, r, t1, t2 in zip(x, y, radii, theta1, theta2):\n    wedge = Wedge((x1, y1), r, t1, t2)\n    patches.append(wedge)\n\n# Some limiting conditions on Wedge\npatches += [\n    Wedge((.3, .7), .1, 0, 360),             # Full circle\n    Wedge((.7, .8), .2, 0, 360, width=0.05),  # Full ring\n    Wedge((.8, .3), .2, 0, 45),              # Full sector\n    Wedge((.8, .3), .2, 45, 90, width=0.10),  # Ring sector\n]\n\nfor i in range(N):\n    polygon = Polygon(np.random.rand(N, 2), closed=True)\n    patches.append(polygon)\n\ncolors = 100 * np.random.rand(len(patches))\np = PatchCollection(patches, alpha=0.4)\np.set_array(colors)\nax.add_collection(p)\nfig.colorbar(p, ax=ax)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.Circle`\n#    - `matplotlib.patches.Wedge`\n#    - `matplotlib.patches.Polygon`\n#    - `matplotlib.collections.PatchCollection`\n#    - `matplotlib.collections.Collection.set_array`\n#    - `matplotlib.axes.Axes.add_collection`\n#    - `matplotlib.figure.Figure.colorbar`"
      },
      {
        "image_path": "gallery_assets/08shapes_and_collections_170_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "r\"\"\"\n================\nPathPatch object\n================\n\nThis example shows how to create `~.path.Path` and `~.patches.PathPatch`\nobjects through Matplotlib's API.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\nfig, ax = plt.subplots()\n\nPath = mpath.Path\npath_data = [\n    (Path.MOVETO, (1.58, -2.57)),\n    (Path.CURVE4, (0.35, -1.1)),\n    (Path.CURVE4, (-1.75, 2.0)),\n    (Path.CURVE4, (0.375, 2.0)),\n    (Path.LINETO, (0.85, 1.15)),\n    (Path.CURVE4, (2.2, 3.2)),\n    (Path.CURVE4, (3, 0.05)),\n    (Path.CURVE4, (2.0, -0.5)),\n    (Path.CLOSEPOLY, (1.58, -2.57)),\n    ]\ncodes, verts = zip(*path_data)\npath = mpath.Path(verts, codes)\npatch = mpatches.PathPatch(path, facecolor='r', alpha=0.5)\nax.add_patch(patch)\n\n# plot control points and connecting lines\nx, y = zip(*path.vertices)\nline, = ax.plot(x, y, 'go-')\n\nax.grid()\nax.axis('equal')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.path`\n#    - `matplotlib.path.Path`\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.PathPatch`\n#    - `matplotlib.axes.Axes.add_patch`"
      },
      {
        "image_path": "gallery_assets/08shapes_and_collections_171_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============\nBezier Curve\n============\n\nThis example showcases the `~.patches.PathPatch` object to create a Bezier\npolycurve path patch.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\nPath = mpath.Path\n\nfig, ax = plt.subplots()\npp1 = mpatches.PathPatch(\n    Path([(0, 0), (1, 0), (1, 1), (0, 0)],\n         [Path.MOVETO, Path.CURVE3, Path.CURVE3, Path.CLOSEPOLY]),\n    fc=\"none\", transform=ax.transData)\n\nax.add_patch(pp1)\nax.plot([0.75], [0.25], \"ro\")\nax.set_title('The red point should be on the path')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.path`\n#    - `matplotlib.path.Path`\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.PathPatch`\n#    - `matplotlib.axes.Axes.add_patch`"
      },
      {
        "image_path": "gallery_assets/08shapes_and_collections_172_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============\nScatter plot\n============\n\nThis example showcases a simple scatter plot.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nN = 50\nx = np.random.rand(N)\ny = np.random.rand(N)\ncolors = np.random.rand(N)\narea = (30 * np.random.rand(N))**2  # 0 to 15 point radii\n\nplt.scatter(x, y, s=area, c=colors, alpha=0.5)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.scatter` / `matplotlib.pyplot.scatter`"
      }
    ],
    "10pyplots": [
      {
        "image_path": "gallery_assets/10pyplots_173_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============\nInfinite lines\n==============\n\n`~.axes.Axes.axvline` and `~.axes.Axes.axhline` draw infinite vertical /\nhorizontal lines, at given *x* / *y* positions. They are usually used to mark\nspecial data values, e.g. in this example the center and limit values of the\nsigmoid function.\n\n`~.axes.Axes.axline` draws infinite straight lines in arbitrary directions.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(-10, 10, 100)\nsig = 1 / (1 + np.exp(-t))\n\nplt.axhline(y=0, color=\"black\", linestyle=\"--\")\nplt.axhline(y=0.5, color=\"black\", linestyle=\":\")\nplt.axhline(y=1.0, color=\"black\", linestyle=\"--\")\nplt.axvline(color=\"grey\")\nplt.axline((0, 0.5), slope=0.25, color=\"black\", linestyle=(0, (5, 5)))\nplt.plot(t, sig, linewidth=2, label=r\"$\\sigma(t) = \\frac{1}{1 + e^{-t}}$\")\nplt.xlim(-10, 10)\nplt.xlabel(\"t\")\nplt.legend(fontsize=14)\nplt.show()\n\n# %%\n# `~.axes.Axes.axline` can also be used with a ``transform`` parameter, which\n# applies to the point, but not to the slope. This can be useful for drawing\n# diagonal grid lines with a fixed slope, which stay in place when the\n# plot limits are moved.\n\nfor pos in np.linspace(-2, 1, 10):\n    plt.axline((pos, 0), slope=0.5, color='k', transform=plt.gca().transAxes)\n\nplt.ylim([0, 1])\nplt.xlim([0, 1])\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.axhline` / `matplotlib.pyplot.axhline`\n#    - `matplotlib.axes.Axes.axvline` / `matplotlib.pyplot.axvline`\n#    - `matplotlib.axes.Axes.axline` / `matplotlib.pyplot.axline`"
      },
      {
        "image_path": "gallery_assets/10pyplots_174_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========\nSimple plot\n===========\n\nA simple plot where a list of numbers are plotted against their index,\nresulting in a straight line. Use a format string (here, 'o-r') to set the\nmarkers (circles), linestyle (solid line) and color (red).\n\n.. redirect-from:: /gallery/pyplots/fig_axes_labels_simple\n.. redirect-from:: /gallery/pyplots/pyplot_formatstr\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nplt.plot([1, 2, 3, 4], 'o-r')\nplt.ylabel('some numbers')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.plot`\n#    - `matplotlib.pyplot.ylabel`\n#    - `matplotlib.pyplot.show`"
      },
      {
        "image_path": "gallery_assets/10pyplots_175_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============================\nText and mathtext using pyplot\n==============================\n\nSet the special text objects `~.pyplot.title`, `~.pyplot.xlabel`, and\n`~.pyplot.ylabel` through the dedicated pyplot functions.  Additional text\nobjects can be placed in the axes using `~.pyplot.text`.\n\nYou can use TeX-like mathematical typesetting in all texts; see also\n:ref:`mathtext`.\n\n.. redirect-from:: /gallery/pyplots/pyplot_mathtext\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\ns = np.sin(2*np.pi*t)\n\nplt.plot(t, s)\nplt.text(0, -1, r'Hello, world!', fontsize=15)\nplt.title(r'$\\mathcal{A}\\sin(\\omega t)$', fontsize=20)\nplt.xlabel('Time [s]')\nplt.ylabel('Voltage [mV]')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.hist`\n#    - `matplotlib.pyplot.xlabel`\n#    - `matplotlib.pyplot.ylabel`\n#    - `matplotlib.pyplot.text`\n#    - `matplotlib.pyplot.grid`\n#    - `matplotlib.pyplot.show`"
      },
      {
        "image_path": "gallery_assets/10pyplots_176_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========================\nMultiple lines using pyplot\n===========================\n\nPlot three datasets with a single call to `~matplotlib.pyplot.plot`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# evenly sampled time at 200ms intervals\nt = np.arange(0., 5., 0.2)\n\n# red dashes, blue squares and green triangles\nplt.plot(t, t, 'r--', t, t**2, 'bs', t, t**3, 'g^')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`"
      },
      {
        "image_path": "gallery_assets/10pyplots_177_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========================\nTwo subplots using pyplot\n=========================\n\nCreate a figure with two subplots using `.pyplot.subplot`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef f(t):\n    return np.exp(-t) * np.cos(2*np.pi*t)\n\n\nt1 = np.arange(0.0, 5.0, 0.1)\nt2 = np.arange(0.0, 5.0, 0.02)\n\nplt.figure()\nplt.subplot(211)\nplt.plot(t1, f(t1), color='tab:blue', marker='o')\nplt.plot(t2, f(t2), color='black')\n\nplt.subplot(212)\nplt.plot(t2, np.cos(2*np.pi*t2), color='tab:orange', linestyle='--')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.figure`\n#    - `matplotlib.pyplot.subplot`"
      }
    ],
    "11axes_grid1": [
      {
        "image_path": "gallery_assets/11axes_grid1_178_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========================\nAnchored Direction Arrow\n========================\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.font_manager as fm\nfrom mpl_toolkits.axes_grid1.anchored_artists import AnchoredDirectionArrows\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\nax.imshow(np.random.random((10, 10)))\n\n# Simple example\nsimple_arrow = AnchoredDirectionArrows(ax.transAxes, 'X', 'Y')\nax.add_artist(simple_arrow)\n\n# High contrast arrow\nhigh_contrast_part_1 = AnchoredDirectionArrows(\n                            ax.transAxes,\n                            '111', r'11$\\overline{2}$',\n                            loc='upper right',\n                            arrow_props={'ec': 'w', 'fc': 'none', 'alpha': 1,\n                                         'lw': 2}\n                            )\nax.add_artist(high_contrast_part_1)\n\nhigh_contrast_part_2 = AnchoredDirectionArrows(\n                            ax.transAxes,\n                            '111', r'11$\\overline{2}$',\n                            loc='upper right',\n                            arrow_props={'ec': 'none', 'fc': 'k'},\n                            text_props={'ec': 'w', 'fc': 'k', 'lw': 0.4}\n                            )\nax.add_artist(high_contrast_part_2)\n\n# Rotated arrow\nfontprops = fm.FontProperties(family='serif')\n\nrotated_arrow = AnchoredDirectionArrows(\n                    ax.transAxes,\n                    '30', '120',\n                    loc='center',\n                    color='w',\n                    angle=30,\n                    fontproperties=fontprops\n                    )\nax.add_artist(rotated_arrow)\n\n# Altering arrow directions\na1 = AnchoredDirectionArrows(\n        ax.transAxes, 'A', 'B', loc='lower center',\n        length=-0.15,\n        sep_x=0.03, sep_y=0.03,\n        color='r'\n    )\nax.add_artist(a1)\n\na2 = AnchoredDirectionArrows(\n        ax.transAxes, 'A', ' B', loc='lower left',\n        aspect_ratio=-1,\n        sep_x=0.01, sep_y=-0.02,\n        color='orange'\n        )\nax.add_artist(a2)\n\n\na3 = AnchoredDirectionArrows(\n        ax.transAxes, ' A', 'B', loc='lower right',\n        length=-0.15,\n        aspect_ratio=-1,\n        sep_y=-0.1, sep_x=0.04,\n        color='cyan'\n        )\nax.add_artist(a3)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_179_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================================\nHBoxDivider and VBoxDivider demo\n================================\n\nUsing an `.HBoxDivider` to arrange subplots.\n\nNote that both axes' location are adjusted so that they have\nequal heights while maintaining their aspect ratios.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1.axes_divider import HBoxDivider, VBoxDivider\nimport mpl_toolkits.axes_grid1.axes_size as Size\n\narr1 = np.arange(20).reshape((4, 5))\narr2 = np.arange(20).reshape((5, 4))\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nax1.imshow(arr1)\nax2.imshow(arr2)\n\npad = 0.5  # pad in inches\ndivider = HBoxDivider(\n    fig, 111,\n    horizontal=[Size.AxesX(ax1), Size.Fixed(pad), Size.AxesX(ax2)],\n    vertical=[Size.AxesY(ax1), Size.Scaled(1), Size.AxesY(ax2)])\nax1.set_axes_locator(divider.new_locator(0))\nax2.set_axes_locator(divider.new_locator(2))\n\nplt.show()\n\n# %%\n# Using a `.VBoxDivider` to arrange subplots.\n#\n# Note that both axes' location are adjusted so that they have\n# equal widths while maintaining their aspect ratios.\n\nfig, (ax1, ax2) = plt.subplots(2, 1)\nax1.imshow(arr1)\nax2.imshow(arr2)\n\ndivider = VBoxDivider(\n    fig, 111,\n    horizontal=[Size.AxesX(ax1), Size.Scaled(1), Size.AxesX(ax2)],\n    vertical=[Size.AxesY(ax1), Size.Fixed(pad), Size.AxesY(ax2)])\n\nax1.set_axes_locator(divider.new_locator(0))\nax2.set_axes_locator(divider.new_locator(2))\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_180_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========================\nColorbar with AxesDivider\n=========================\n\nThe `.axes_divider.make_axes_locatable` function takes an existing axes, adds\nit to a new `.AxesDivider` and returns the `.AxesDivider`.  The `.append_axes`\nmethod of the `.AxesDivider` can then be used to create a new axes on a given\nside (\"top\", \"right\", \"bottom\", or \"left\") of the original axes. This example\nuses `.append_axes` to add colorbars next to axes.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nfig.subplots_adjust(wspace=0.5)\n\nim1 = ax1.imshow([[1, 2], [3, 4]])\nax1_divider = make_axes_locatable(ax1)\n# Add an Axes to the right of the main Axes.\ncax1 = ax1_divider.append_axes(\"right\", size=\"7%\", pad=\"2%\")\ncb1 = fig.colorbar(im1, cax=cax1)\n\nim2 = ax2.imshow([[1, 2], [3, 4]])\nax2_divider = make_axes_locatable(ax2)\n# Add an Axes above the main Axes.\ncax2 = ax2_divider.append_axes(\"top\", size=\"7%\", pad=\"2%\")\ncb2 = fig.colorbar(im2, cax=cax2, orientation=\"horizontal\")\n# Change tick position to top (with the default tick position \"bottom\", ticks\n# overlap the image).\ncax2.xaxis.set_ticks_position(\"top\")\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_181_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============================================================\nControlling the position and size of colorbars with Inset Axes\n==============================================================\n\nThis example shows how to control the position, height, and width of\ncolorbars using `~mpl_toolkits.axes_grid1.inset_locator.inset_axes`.\n\nInset axes placement is controlled as for legends: either by providing a *loc*\noption (\"upper right\", \"best\", ...), or by providing a locator with respect to\nthe parent bbox.  Parameters such as *bbox_to_anchor* and *borderpad* likewise\nwork in the same way, and are also demonstrated here.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=[6, 3])\n\nim1 = ax1.imshow([[1, 2], [2, 3]])\naxins1 = inset_axes(\n    ax1,\n    width=\"50%\",  # width: 50% of parent_bbox width\n    height=\"5%\",  # height: 5%\n    loc=\"upper right\",\n)\naxins1.xaxis.set_ticks_position(\"bottom\")\nfig.colorbar(im1, cax=axins1, orientation=\"horizontal\", ticks=[1, 2, 3])\n\nim = ax2.imshow([[1, 2], [2, 3]])\naxins = inset_axes(\n    ax2,\n    width=\"5%\",  # width: 5% of parent_bbox width\n    height=\"50%\",  # height: 50%\n    loc=\"lower left\",\n    bbox_to_anchor=(1.05, 0., 1, 1),\n    bbox_transform=ax2.transAxes,\n    borderpad=0,\n)\nfig.colorbar(im, cax=axins, ticks=[1, 2, 3])\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_182_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============================\nAxes with a fixed physical size\n===============================\n\nNote that this can be accomplished with the main library for\nAxes on Figures that do not change size: :ref:`fixed_size_axes`\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import Divider, Size\n\n# %%\n\n\nfig = plt.figure(figsize=(6, 6))\n\n# The first items are for padding and the second items are for the axes.\n# sizes are in inch.\nh = [Size.Fixed(1.0), Size.Fixed(4.5)]\nv = [Size.Fixed(0.7), Size.Fixed(5.)]\n\ndivider = Divider(fig, (0, 0, 1, 1), h, v, aspect=False)\n# The width and height of the rectangle are ignored.\n\nax = fig.add_axes(divider.get_position(),\n                  axes_locator=divider.new_locator(nx=1, ny=1))\n\nax.plot([1, 2, 3])\n\n# %%\n\n\nfig = plt.figure(figsize=(6, 6))\n\n# The first & third items are for padding and the second items are for the\n# axes. Sizes are in inches.\nh = [Size.Fixed(1.0), Size.Scaled(1.), Size.Fixed(.2)]\nv = [Size.Fixed(0.7), Size.Scaled(1.), Size.Fixed(.5)]\n\ndivider = Divider(fig, (0, 0, 1, 1), h, v, aspect=False)\n# The width and height of the rectangle are ignored.\n\nax = fig.add_axes(divider.get_position(),\n                  axes_locator=divider.new_locator(nx=1, ny=1))\n\nax.plot([1, 2, 3])\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_183_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========================================\nSetting a fixed aspect on ImageGrid cells\n=========================================\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nfig = plt.figure()\n\ngrid1 = ImageGrid(fig, 121, (2, 2), axes_pad=0.1,\n                  aspect=True, share_all=True)\nfor i in [0, 1]:\n    grid1[i].set_aspect(2)\n\ngrid2 = ImageGrid(fig, 122, (2, 2), axes_pad=0.1,\n                  aspect=True, share_all=True)\nfor i in [1, 3]:\n    grid2[i].set_aspect(2)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_184_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================\nInset locator demo\n==================\n\n\"\"\"\n\n# %%\n# The `.inset_locator`'s `~.inset_locator.inset_axes` allows\n# easily placing insets in the corners of the axes by specifying a width and\n# height and optionally a location (loc) that accepts locations as codes,\n# similar to `~matplotlib.axes.Axes.legend`.\n# By default, the inset is offset by some points from the axes,\n# controlled via the *borderpad* parameter.\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\nfig, (ax, ax2) = plt.subplots(1, 2, figsize=[5.5, 2.8])\n\n# Create inset of width 1.3 inches and height 0.9 inches\n# at the default upper right location\naxins = inset_axes(ax, width=1.3, height=0.9)\n\n# Create inset of width 30% and height 40% of the parent axes' bounding box\n# at the lower left corner (loc=3)\naxins2 = inset_axes(ax, width=\"30%\", height=\"40%\", loc=3)\n\n# Create inset of mixed specifications in the second subplot;\n# width is 30% of parent axes' bounding box and\n# height is 1 inch at the upper left corner (loc=2)\naxins3 = inset_axes(ax2, width=\"30%\", height=1., loc=2)\n\n# Create an inset in the lower right corner (loc=4) with borderpad=1, i.e.\n# 10 points padding (as 10pt is the default fontsize) to the parent axes\naxins4 = inset_axes(ax2, width=\"20%\", height=\"20%\", loc=4, borderpad=1)\n\n# Turn ticklabels of insets off\nfor axi in [axins, axins2, axins3, axins4]:\n    axi.tick_params(labelleft=False, labelbottom=False)\n\nplt.show()\n\n\n# %%\n# The parameters *bbox_to_anchor* and *bbox_transform* can be used for a more\n# fine-grained control over the inset position and size or even to position\n# the inset at completely arbitrary positions.\n# The *bbox_to_anchor* sets the bounding box in coordinates according to the\n# *bbox_transform*.\n#\n\nfig = plt.figure(figsize=[5.5, 2.8])\nax = fig.add_subplot(121)\n\n# We use the axes transform as bbox_transform. Therefore, the bounding box\n# needs to be specified in axes coordinates ((0, 0) is the lower left corner\n# of the axes, (1, 1) is the upper right corner).\n# The bounding box (.2, .4, .6, .5) starts at (.2, .4) and ranges to (.8, .9)\n# in those coordinates.\n# Inside this bounding box an inset of half the bounding box' width and\n# three quarters of the bounding box' height is created. The lower left corner\n# of the inset is aligned to the lower left corner of the bounding box (loc=3).\n# The inset is then offset by the default 0.5 in units of the font size.\n\naxins = inset_axes(ax, width=\"50%\", height=\"75%\",\n                   bbox_to_anchor=(.2, .4, .6, .5),\n                   bbox_transform=ax.transAxes, loc=3)\n\n# For visualization purposes we mark the bounding box by a rectangle\nax.add_patch(plt.Rectangle((.2, .4), .6, .5, ls=\"--\", ec=\"c\", fc=\"none\",\n                           transform=ax.transAxes))\n\n# We set the axis limits to something other than the default, in order to not\n# distract from the fact that axes coordinates are used here.\nax.set(xlim=(0, 10), ylim=(0, 10))\n\n\n# Note how the two following insets are created at the same positions, one by\n# use of the default parent axes' bbox and the other via a bbox in axes\n# coordinates and the respective transform.\nax2 = fig.add_subplot(222)\naxins2 = inset_axes(ax2, width=\"30%\", height=\"50%\")\n\nax3 = fig.add_subplot(224)\naxins3 = inset_axes(ax3, width=\"100%\", height=\"100%\",\n                    bbox_to_anchor=(.7, .5, .3, .5),\n                    bbox_transform=ax3.transAxes)\n\n# For visualization purposes we mark the bounding box by a rectangle\nax2.add_patch(plt.Rectangle((0, 0), 1, 1, ls=\"--\", lw=2, ec=\"c\", fc=\"none\"))\nax3.add_patch(plt.Rectangle((.7, .5), .3, .5, ls=\"--\", lw=2,\n                            ec=\"c\", fc=\"none\"))\n\n# Turn ticklabels off\nfor axi in [axins2, axins3, ax2, ax3]:\n    axi.tick_params(labelleft=False, labelbottom=False)\n\nplt.show()\n\n\n# %%\n# In the above the axes transform together with 4-tuple bounding boxes has been\n# used as it mostly is useful to specify an inset relative to the axes it is\n# an inset to. However, other use cases are equally possible. The following\n# example examines some of those.\n#\n\nfig = plt.figure(figsize=[5.5, 2.8])\nax = fig.add_subplot(131)\n\n# Create an inset outside the axes\naxins = inset_axes(ax, width=\"100%\", height=\"100%\",\n                   bbox_to_anchor=(1.05, .6, .5, .4),\n                   bbox_transform=ax.transAxes, loc=2, borderpad=0)\naxins.tick_params(left=False, right=True, labelleft=False, labelright=True)\n\n# Create an inset with a 2-tuple bounding box. Note that this creates a\n# bbox without extent. This hence only makes sense when specifying\n# width and height in absolute units (inches).\naxins2 = inset_axes(ax, width=0.5, height=0.4,\n                    bbox_to_anchor=(0.33, 0.25),\n                    bbox_transform=ax.transAxes, loc=3, borderpad=0)\n\n\nax2 = fig.add_subplot(133)\nax2.set_xscale(\"log\")\nax2.set(xlim=(1e-6, 1e6), ylim=(-2, 6))\n\n# Create inset in data coordinates using ax.transData as transform\naxins3 = inset_axes(ax2, width=\"100%\", height=\"100%\",\n                    bbox_to_anchor=(1e-2, 2, 1e3, 3),\n                    bbox_transform=ax2.transData, loc=2, borderpad=0)\n\n# Create an inset horizontally centered in figure coordinates and vertically\n# bound to line up with the axes.\nfrom matplotlib.transforms import blended_transform_factory  # noqa\n\ntransform = blended_transform_factory(fig.transFigure, ax2.transAxes)\naxins4 = inset_axes(ax2, width=\"16%\", height=\"34%\",\n                    bbox_to_anchor=(0, 0, 1, 1),\n                    bbox_transform=transform, loc=8, borderpad=0)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_185_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n====================================\nMake room for ylabel using axes_grid\n====================================\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nfrom mpl_toolkits.axes_grid1.axes_divider import make_axes_area_auto_adjustable\n\nfig = plt.figure()\nax = fig.add_axes([0, 0, 1, 1])\n\nax.set_yticks([0.5], labels=[\"very long label\"])\n\nmake_axes_area_auto_adjustable(ax)\n\n# %%\n\nfig = plt.figure()\nax1 = fig.add_axes([0, 0, 1, 0.5])\nax2 = fig.add_axes([0, 0.5, 1, 0.5])\n\nax1.set_yticks([0.5], labels=[\"very long label\"])\nax1.set_ylabel(\"Y label\")\n\nax2.set_title(\"Title\")\n\nmake_axes_area_auto_adjustable(ax1, pad=0.1, use_axes=[ax1, ax2])\nmake_axes_area_auto_adjustable(ax2, pad=0.1, use_axes=[ax1, ax2])\n\n# %%\n\nfig = plt.figure()\nax1 = fig.add_axes([0, 0, 1, 1])\ndivider = make_axes_locatable(ax1)\n\nax2 = divider.append_axes(\"right\", \"100%\", pad=0.3, sharey=ax1)\nax2.tick_params(labelleft=False)\nfig.add_axes(ax2)\n\ndivider.add_auto_adjustable_area(use_axes=[ax1], pad=0.1,\n                                 adjust_dirs=[\"left\"])\ndivider.add_auto_adjustable_area(use_axes=[ax2], pad=0.1,\n                                 adjust_dirs=[\"right\"])\ndivider.add_auto_adjustable_area(use_axes=[ax1, ax2], pad=0.1,\n                                 adjust_dirs=[\"top\", \"bottom\"])\n\nax1.set_yticks([0.5], labels=[\"very long label\"])\n\nax2.set_title(\"Title\")\nax2.set_xlabel(\"X - Label\")\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_186_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============\nParasite Simple\n===============\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import host_subplot\n\nhost = host_subplot(111)\npar = host.twinx()\n\nhost.set_xlabel(\"Distance\")\nhost.set_ylabel(\"Density\")\npar.set_ylabel(\"Temperature\")\n\np1, = host.plot([0, 1, 2], [0, 1, 2], label=\"Density\")\np2, = par.plot([0, 1, 2], [0, 3, 2], label=\"Temperature\")\n\nhost.legend(labelcolor=\"linecolor\")\n\nhost.yaxis.get_label().set_color(p1.get_color())\npar.yaxis.get_label().set_color(p2.get_color())\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_187_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nParasite Simple2\n================\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nimport matplotlib.transforms as mtransforms\nfrom mpl_toolkits.axes_grid1.parasite_axes import HostAxes\n\nobs = [[\"01_S1\", 3.88, 0.14, 1970, 63],\n       [\"01_S4\", 5.6, 0.82, 1622, 150],\n       [\"02_S1\", 2.4, 0.54, 1570, 40],\n       [\"03_S1\", 4.1, 0.62, 2380, 170]]\n\n\nfig = plt.figure()\n\nax_kms = fig.add_subplot(axes_class=HostAxes, aspect=1)\n\n# angular proper motion(\"/yr) to linear velocity(km/s) at distance=2.3kpc\npm_to_kms = 1./206265.*2300*3.085e18/3.15e7/1.e5\n\naux_trans = mtransforms.Affine2D().scale(pm_to_kms, 1.)\nax_pm = ax_kms.twin(aux_trans)\n\nfor n, ds, dse, w, we in obs:\n    time = ((2007 + (10. + 4/30.)/12) - 1988.5)\n    v = ds / time * pm_to_kms\n    ve = dse / time * pm_to_kms\n    ax_kms.errorbar([v], [w], xerr=[ve], yerr=[we], color=\"k\")\n\n\nax_kms.axis[\"bottom\"].set_label(\"Linear velocity at 2.3 kpc [km/s]\")\nax_kms.axis[\"left\"].set_label(\"FWHM [km/s]\")\nax_pm.axis[\"top\"].set_label(r\"Proper Motion [$''$/yr]\")\nax_pm.axis[\"top\"].label.set_visible(True)\nax_pm.axis[\"right\"].major_ticklabels.set_visible(False)\n\nax_kms.set_xlim(950, 3700)\nax_kms.set_ylim(950, 3100)\n# xlim and ylim of ax_pms will be automatically adjusted.\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_188_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================================\nScatter Histogram (Locatable Axes)\n==================================\n\nShow the marginal distributions of a scatter plot as histograms at the sides of\nthe plot.\n\nFor a nice alignment of the main axes with the marginals, the axes positions\nare defined by a ``Divider``, produced via `.make_axes_locatable`.  Note that\nthe ``Divider`` API allows setting axes sizes and pads in inches, which is its\nmain feature.\n\nIf one wants to set axes sizes and pads relative to the main Figure, see the\n:doc:`/gallery/lines_bars_and_markers/scatter_hist` example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# the random data\nx = np.random.randn(1000)\ny = np.random.randn(1000)\n\n\nfig, ax = plt.subplots(figsize=(5.5, 5.5))\n\n# the scatter plot:\nax.scatter(x, y)\n\n# Set aspect of the main axes.\nax.set_aspect(1.)\n\n# create new axes on the right and on the top of the current axes\ndivider = make_axes_locatable(ax)\n# below height and pad are in inches\nax_histx = divider.append_axes(\"top\", 1.2, pad=0.1, sharex=ax)\nax_histy = divider.append_axes(\"right\", 1.2, pad=0.1, sharey=ax)\n\n# make some labels invisible\nax_histx.xaxis.set_tick_params(labelbottom=False)\nax_histy.yaxis.set_tick_params(labelleft=False)\n\n# now determine nice limits by hand:\nbinwidth = 0.25\nxymax = max(np.max(np.abs(x)), np.max(np.abs(y)))\nlim = (int(xymax/binwidth) + 1)*binwidth\n\nbins = np.arange(-lim, lim + binwidth, binwidth)\nax_histx.hist(x, bins=bins)\nax_histy.hist(y, bins=bins, orientation='horizontal')\n\n# the xaxis of ax_histx and yaxis of ax_histy are shared with ax,\n# thus there is no need to manually adjust the xlim and ylim of these\n# axis.\n\nax_histx.set_yticks([0, 50, 100])\nax_histy.set_xticks([0, 50, 100])\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `mpl_toolkits.axes_grid1.axes_divider.make_axes_locatable`\n#    - `matplotlib.axes.Axes.set_aspect`\n#    - `matplotlib.axes.Axes.scatter`\n#    - `matplotlib.axes.Axes.hist`"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_189_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======================\nSimple Anchored Artists\n=======================\n\nThis example illustrates the use of the anchored helper classes found in\n:mod:`matplotlib.offsetbox` and in :mod:`mpl_toolkits.axes_grid1`.\nAn implementation of a similar figure, but without use of the toolkit,\ncan be found in :doc:`/gallery/misc/anchored_artists`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n\ndef draw_text(ax):\n    \"\"\"\n    Draw two text-boxes, anchored by different corners to the upper-left\n    corner of the figure.\n    \"\"\"\n    from matplotlib.offsetbox import AnchoredText\n    at = AnchoredText(\"Figure 1a\",\n                      loc='upper left', prop=dict(size=8), frameon=True,\n                      )\n    at.patch.set_boxstyle(\"round,pad=0.,rounding_size=0.2\")\n    ax.add_artist(at)\n\n    at2 = AnchoredText(\"Figure 1(b)\",\n                       loc='lower left', prop=dict(size=8), frameon=True,\n                       bbox_to_anchor=(0., 1.),\n                       bbox_transform=ax.transAxes\n                       )\n    at2.patch.set_boxstyle(\"round,pad=0.,rounding_size=0.2\")\n    ax.add_artist(at2)\n\n\ndef draw_circle(ax):\n    \"\"\"\n    Draw a circle in axis coordinates\n    \"\"\"\n    from matplotlib.patches import Circle\n    from mpl_toolkits.axes_grid1.anchored_artists import AnchoredDrawingArea\n    ada = AnchoredDrawingArea(20, 20, 0, 0,\n                              loc='upper right', pad=0., frameon=False)\n    p = Circle((10, 10), 10)\n    ada.da.add_artist(p)\n    ax.add_artist(ada)\n\n\ndef draw_sizebar(ax):\n    \"\"\"\n    Draw a horizontal bar with length of 0.1 in data coordinates,\n    with a fixed label underneath.\n    \"\"\"\n    from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar\n    asb = AnchoredSizeBar(ax.transData,\n                          0.1,\n                          r\"1$^{\\prime}$\",\n                          loc='lower center',\n                          pad=0.1, borderpad=0.5, sep=5,\n                          frameon=False)\n    ax.add_artist(asb)\n\n\nfig, ax = plt.subplots()\nax.set_aspect(1.)\n\ndraw_text(ax)\ndraw_circle(ax)\ndraw_sizebar(ax)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_190_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=====================\nSimple Axes Divider 1\n=====================\n\nSee also :ref:`axes_grid`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import Divider, Size\n\n\ndef label_axes(ax, text):\n    \"\"\"Place a label at the center of an Axes, and remove the axis ticks.\"\"\"\n    ax.text(.5, .5, text, transform=ax.transAxes,\n            horizontalalignment=\"center\", verticalalignment=\"center\")\n    ax.tick_params(bottom=False, labelbottom=False,\n                   left=False, labelleft=False)\n\n\n# %%\n# Fixed axes sizes; fixed paddings.\n\nfig = plt.figure(figsize=(6, 6))\nfig.suptitle(\"Fixed axes sizes, fixed paddings\")\n\n# Sizes are in inches.\nhoriz = [Size.Fixed(1.), Size.Fixed(.5), Size.Fixed(1.5), Size.Fixed(.5)]\nvert = [Size.Fixed(1.5), Size.Fixed(.5), Size.Fixed(1.)]\n\nrect = (0.1, 0.1, 0.8, 0.8)\n# Divide the axes rectangle into a grid with sizes specified by horiz * vert.\ndiv = Divider(fig, rect, horiz, vert, aspect=False)\n\n# The rect parameter will actually be ignored and overridden by axes_locator.\nax1 = fig.add_axes(rect, axes_locator=div.new_locator(nx=0, ny=0))\nlabel_axes(ax1, \"nx=0, ny=0\")\nax2 = fig.add_axes(rect, axes_locator=div.new_locator(nx=0, ny=2))\nlabel_axes(ax2, \"nx=0, ny=2\")\nax3 = fig.add_axes(rect, axes_locator=div.new_locator(nx=2, ny=2))\nlabel_axes(ax3, \"nx=2, ny=2\")\nax4 = fig.add_axes(rect, axes_locator=div.new_locator(nx=2, nx1=4, ny=0))\nlabel_axes(ax4, \"nx=2, nx1=4, ny=0\")\n\n# %%\n# Axes sizes that scale with the figure size; fixed paddings.\n\nfig = plt.figure(figsize=(6, 6))\nfig.suptitle(\"Scalable axes sizes, fixed paddings\")\n\nhoriz = [Size.Scaled(1.5), Size.Fixed(.5), Size.Scaled(1.), Size.Scaled(.5)]\nvert = [Size.Scaled(1.), Size.Fixed(.5), Size.Scaled(1.5)]\n\nrect = (0.1, 0.1, 0.8, 0.8)\n# Divide the axes rectangle into a grid with sizes specified by horiz * vert.\ndiv = Divider(fig, rect, horiz, vert, aspect=False)\n\n# The rect parameter will actually be ignored and overridden by axes_locator.\nax1 = fig.add_axes(rect, axes_locator=div.new_locator(nx=0, ny=0))\nlabel_axes(ax1, \"nx=0, ny=0\")\nax2 = fig.add_axes(rect, axes_locator=div.new_locator(nx=0, ny=2))\nlabel_axes(ax2, \"nx=0, ny=2\")\nax3 = fig.add_axes(rect, axes_locator=div.new_locator(nx=2, ny=2))\nlabel_axes(ax3, \"nx=2, ny=2\")\nax4 = fig.add_axes(rect, axes_locator=div.new_locator(nx=2, nx1=4, ny=0))\nlabel_axes(ax4, \"nx=2, nx1=4, ny=0\")\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_191_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=====================\nSimple axes divider 3\n=====================\n\nSee also :ref:`axes_grid`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import Divider\nimport mpl_toolkits.axes_grid1.axes_size as Size\n\nfig = plt.figure(figsize=(5.5, 4))\n\n# the rect parameter will be ignored as we will set axes_locator\nrect = (0.1, 0.1, 0.8, 0.8)\nax = [fig.add_axes(rect, label=\"%d\" % i) for i in range(4)]\n\n\nhoriz = [Size.AxesX(ax[0]), Size.Fixed(.5), Size.AxesX(ax[1])]\nvert = [Size.AxesY(ax[0]), Size.Fixed(.5), Size.AxesY(ax[2])]\n\n# divide the axes rectangle into grid whose size is specified by horiz * vert\ndivider = Divider(fig, rect, horiz, vert, aspect=False)\n\n\nax[0].set_axes_locator(divider.new_locator(nx=0, ny=0))\nax[1].set_axes_locator(divider.new_locator(nx=2, ny=0))\nax[2].set_axes_locator(divider.new_locator(nx=0, ny=2))\nax[3].set_axes_locator(divider.new_locator(nx=2, ny=2))\n\nax[0].set_xlim(0, 2)\nax[1].set_xlim(0, 1)\n\nax[0].set_ylim(0, 1)\nax[2].set_ylim(0, 2)\n\ndivider.set_aspect(1.)\n\nfor ax1 in ax:\n    ax1.tick_params(labelbottom=False, labelleft=False)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_192_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nSimple ImageGrid\n================\n\nAlign multiple images using `~mpl_toolkits.axes_grid1.axes_grid.ImageGrid`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nim1 = np.arange(100).reshape((10, 10))\nim2 = im1.T\nim3 = np.flipud(im1)\nim4 = np.fliplr(im2)\n\nfig = plt.figure(figsize=(4., 4.))\ngrid = ImageGrid(fig, 111,  # similar to subplot(111)\n                 nrows_ncols=(2, 2),  # creates 2x2 grid of axes\n                 axes_pad=0.1,  # pad between axes in inch.\n                 )\n\nfor ax, im in zip(grid, [im1, im2, im3, im4]):\n    # Iterating over the grid returns the Axes.\n    ax.imshow(im)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_193_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nSimple Axisline4\n================\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1 import host_subplot\n\nax = host_subplot(111)\nxx = np.arange(0, 2*np.pi, 0.01)\nax.plot(xx, np.sin(xx))\n\nax2 = ax.twin()  # ax2 is responsible for \"top\" axis and \"right\" axis\nax2.set_xticks([0., .5*np.pi, np.pi, 1.5*np.pi, 2*np.pi],\n               labels=[\"$0$\", r\"$\\frac{1}{2}\\pi$\",\n                       r\"$\\pi$\", r\"$\\frac{3}{2}\\pi$\", r\"$2\\pi$\"])\n\nax2.axis[\"right\"].major_ticklabels.set_visible(False)\nax2.axis[\"top\"].major_ticklabels.set_visible(True)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/11axes_grid1_194_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============\nSimple Colorbar\n===============\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\nax = plt.subplot()\nim = ax.imshow(np.arange(100).reshape((10, 10)))\n\n# create an Axes on the right side of ax. The width of cax will be 5%\n# of ax and the padding between cax and ax will be fixed at 0.05 inch.\ndivider = make_axes_locatable(ax)\ncax = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n\nplt.colorbar(im, cax=cax)\n\nplt.show()"
      }
    ],
    "12axisartist": [
      {
        "image_path": "gallery_assets/12axisartist_195_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============\nAxis Direction\n==============\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axisartist.Axes)\n\n    ax.set_ylim(-0.1, 1.5)\n    ax.set_yticks([0, 1])\n\n    ax.axis[:].set_visible(False)\n\n    ax.axis[\"x\"] = ax.new_floating_axis(1, 0.5)\n    ax.axis[\"x\"].set_axisline_style(\"->\", size=1.5)\n\n    return ax\n\n\nplt.rcParams.update({\n    \"axes.titlesize\": \"medium\",\n    \"axes.titley\": 1.1,\n})\n\nfig = plt.figure(figsize=(10, 4))\nfig.subplots_adjust(bottom=0.1, top=0.9, left=0.05, right=0.95)\n\nax1 = setup_axes(fig, 251)\nax1.axis[\"x\"].set_axis_direction(\"left\")\n\nax2 = setup_axes(fig, 252)\nax2.axis[\"x\"].label.set_text(\"Label\")\nax2.axis[\"x\"].toggle(ticklabels=False)\nax2.axis[\"x\"].set_axislabel_direction(\"+\")\nax2.set_title(\"label direction=$+$\")\n\nax3 = setup_axes(fig, 253)\nax3.axis[\"x\"].label.set_text(\"Label\")\nax3.axis[\"x\"].toggle(ticklabels=False)\nax3.axis[\"x\"].set_axislabel_direction(\"-\")\nax3.set_title(\"label direction=$-$\")\n\nax4 = setup_axes(fig, 254)\nax4.axis[\"x\"].set_ticklabel_direction(\"+\")\nax4.set_title(\"ticklabel direction=$+$\")\n\nax5 = setup_axes(fig, 255)\nax5.axis[\"x\"].set_ticklabel_direction(\"-\")\nax5.set_title(\"ticklabel direction=$-$\")\n\nax7 = setup_axes(fig, 257)\nax7.axis[\"x\"].label.set_text(\"rotation=10\")\nax7.axis[\"x\"].label.set_rotation(10)\nax7.axis[\"x\"].toggle(ticklabels=False)\n\nax8 = setup_axes(fig, 258)\nax8.axis[\"x\"].set_axislabel_direction(\"-\")\nax8.axis[\"x\"].label.set_text(\"rotation=10\")\nax8.axis[\"x\"].label.set_rotation(10)\nax8.axis[\"x\"].toggle(ticklabels=False)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/12axisartist_196_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===================\naxis_direction demo\n===================\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nimport mpl_toolkits.axisartist as axisartist\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\nimport mpl_toolkits.axisartist.grid_finder as grid_finder\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import \\\n    GridHelperCurveLinear\n\n\ndef setup_axes(fig, rect):\n    \"\"\"Polar projection, but in a rectangular box.\"\"\"\n    # see demo_curvelinear_grid.py for details\n    grid_helper = GridHelperCurveLinear(\n        Affine2D().scale(np.pi/180., 1.) + PolarAxes.PolarTransform(),\n        extreme_finder=angle_helper.ExtremeFinderCycle(\n            20, 20,\n            lon_cycle=360, lat_cycle=None,\n            lon_minmax=None, lat_minmax=(0, np.inf),\n        ),\n        grid_locator1=angle_helper.LocatorDMS(12),\n        grid_locator2=grid_finder.MaxNLocator(5),\n        tick_formatter1=angle_helper.FormatterDMS(),\n    )\n    ax = fig.add_subplot(\n        rect, axes_class=axisartist.Axes, grid_helper=grid_helper,\n        aspect=1, xlim=(-5, 12), ylim=(-5, 10))\n    ax.axis[:].toggle(ticklabels=False)\n    ax.grid(color=\".9\")\n    return ax\n\n\ndef add_floating_axis1(ax):\n    ax.axis[\"lat\"] = axis = ax.new_floating_axis(0, 30)\n    axis.label.set_text(r\"$\\theta = 30^{\\circ}$\")\n    axis.label.set_visible(True)\n    return axis\n\n\ndef add_floating_axis2(ax):\n    ax.axis[\"lon\"] = axis = ax.new_floating_axis(1, 6)\n    axis.label.set_text(r\"$r = 6$\")\n    axis.label.set_visible(True)\n    return axis\n\n\nfig = plt.figure(figsize=(8, 4), layout=\"constrained\")\n\nfor i, d in enumerate([\"bottom\", \"left\", \"top\", \"right\"]):\n    ax = setup_axes(fig, rect=241+i)\n    axis = add_floating_axis1(ax)\n    axis.set_axis_direction(d)\n    ax.set(title=d)\n\nfor i, d in enumerate([\"bottom\", \"left\", \"top\", \"right\"]):\n    ax = setup_axes(fig, rect=245+i)\n    axis = add_floating_axis2(ax)\n    axis.set_axis_direction(d)\n    ax.set(title=d)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/12axisartist_197_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nAxis line styles\n================\n\nThis example shows some configurations for axis style.\n\nNote: The `mpl_toolkits.axisartist` axes classes may be confusing for new\nusers. If the only aim is to obtain arrow heads at the ends of the axes,\nrather check out the :doc:`/gallery/spines/centered_spines_with_arrows`\nexample.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axisartist.axislines import AxesZero\n\nfig = plt.figure()\nax = fig.add_subplot(axes_class=AxesZero)\n\nfor direction in [\"xzero\", \"yzero\"]:\n    # adds arrows at the ends of each axis\n    ax.axis[direction].set_axisline_style(\"-|>\")\n\n    # adds X and Y-axis from the origin\n    ax.axis[direction].set_visible(True)\n\nfor direction in [\"left\", \"right\", \"bottom\", \"top\"]:\n    # hides borders\n    ax.axis[direction].set_visible(False)\n\nx = np.linspace(-0.5, 1., 100)\nax.plot(x, np.sin(x*np.pi))\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/12axisartist_198_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========================\n``floating_axes`` features\n==========================\n\nDemonstration of features of the :mod:`.floating_axes` module:\n\n* Using `~.axes.Axes.scatter` and `~.axes.Axes.bar` with changing the shape of\n  the plot.\n* Using `~.floating_axes.GridHelperCurveLinear` to rotate the plot and set the\n  plot boundary.\n* Using `~.Figure.add_subplot` to create a subplot using the return value from\n  `~.floating_axes.GridHelperCurveLinear`.\n* Making a sector plot by adding more features to\n  `~.floating_axes.GridHelperCurveLinear`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\nimport mpl_toolkits.axisartist.floating_axes as floating_axes\nfrom mpl_toolkits.axisartist.grid_finder import (DictFormatter, FixedLocator,\n                                                 MaxNLocator)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef setup_axes1(fig, rect):\n    \"\"\"\n    A simple one.\n    \"\"\"\n    tr = Affine2D().scale(2, 1).rotate_deg(30)\n\n    grid_helper = floating_axes.GridHelperCurveLinear(\n        tr, extremes=(-0.5, 3.5, 0, 4),\n        grid_locator1=MaxNLocator(nbins=4),\n        grid_locator2=MaxNLocator(nbins=4))\n\n    ax1 = fig.add_subplot(\n        rect, axes_class=floating_axes.FloatingAxes, grid_helper=grid_helper)\n    ax1.grid()\n\n    aux_ax = ax1.get_aux_axes(tr)\n\n    return ax1, aux_ax\n\n\ndef setup_axes2(fig, rect):\n    \"\"\"\n    With custom locator and formatter.\n    Note that the extreme values are swapped.\n    \"\"\"\n    tr = PolarAxes.PolarTransform()\n\n    pi = np.pi\n    angle_ticks = [(0, r\"$0$\"),\n                   (.25*pi, r\"$\\frac{1}{4}\\pi$\"),\n                   (.5*pi, r\"$\\frac{1}{2}\\pi$\")]\n    grid_locator1 = FixedLocator([v for v, s in angle_ticks])\n    tick_formatter1 = DictFormatter(dict(angle_ticks))\n\n    grid_locator2 = MaxNLocator(2)\n\n    grid_helper = floating_axes.GridHelperCurveLinear(\n        tr, extremes=(.5*pi, 0, 2, 1),\n        grid_locator1=grid_locator1,\n        grid_locator2=grid_locator2,\n        tick_formatter1=tick_formatter1,\n        tick_formatter2=None)\n\n    ax1 = fig.add_subplot(\n        rect, axes_class=floating_axes.FloatingAxes, grid_helper=grid_helper)\n    ax1.grid()\n\n    # create a parasite axes whose transData in RA, cz\n    aux_ax = ax1.get_aux_axes(tr)\n\n    aux_ax.patch = ax1.patch  # for aux_ax to have a clip path as in ax\n    ax1.patch.zorder = 0.9  # but this has a side effect that the patch is\n    # drawn twice, and possibly over some other\n    # artists. So, we decrease the zorder a bit to\n    # prevent this.\n\n    return ax1, aux_ax\n\n\ndef setup_axes3(fig, rect):\n    \"\"\"\n    Sometimes, things like axis_direction need to be adjusted.\n    \"\"\"\n\n    # rotate a bit for better orientation\n    tr_rotate = Affine2D().translate(-95, 0)\n\n    # scale degree to radians\n    tr_scale = Affine2D().scale(np.pi/180., 1.)\n\n    tr = tr_rotate + tr_scale + PolarAxes.PolarTransform()\n\n    grid_locator1 = angle_helper.LocatorHMS(4)\n    tick_formatter1 = angle_helper.FormatterHMS()\n\n    grid_locator2 = MaxNLocator(3)\n\n    # Specify theta limits in degrees\n    ra0, ra1 = 8.*15, 14.*15\n    # Specify radial limits\n    cz0, cz1 = 0, 14000\n    grid_helper = floating_axes.GridHelperCurveLinear(\n        tr, extremes=(ra0, ra1, cz0, cz1),\n        grid_locator1=grid_locator1,\n        grid_locator2=grid_locator2,\n        tick_formatter1=tick_formatter1,\n        tick_formatter2=None)\n\n    ax1 = fig.add_subplot(\n        rect, axes_class=floating_axes.FloatingAxes, grid_helper=grid_helper)\n\n    # adjust axis\n    ax1.axis[\"left\"].set_axis_direction(\"bottom\")\n    ax1.axis[\"right\"].set_axis_direction(\"top\")\n\n    ax1.axis[\"bottom\"].set_visible(False)\n    ax1.axis[\"top\"].set_axis_direction(\"bottom\")\n    ax1.axis[\"top\"].toggle(ticklabels=True, label=True)\n    ax1.axis[\"top\"].major_ticklabels.set_axis_direction(\"top\")\n    ax1.axis[\"top\"].label.set_axis_direction(\"top\")\n\n    ax1.axis[\"left\"].label.set_text(r\"cz [km$^{-1}$]\")\n    ax1.axis[\"top\"].label.set_text(r\"$\\alpha_{1950}$\")\n    ax1.grid()\n\n    # create a parasite axes whose transData in RA, cz\n    aux_ax = ax1.get_aux_axes(tr)\n\n    aux_ax.patch = ax1.patch  # for aux_ax to have a clip path as in ax\n    ax1.patch.zorder = 0.9  # but this has a side effect that the patch is\n    # drawn twice, and possibly over some other\n    # artists. So, we decrease the zorder a bit to\n    # prevent this.\n\n    return ax1, aux_ax\n\n\n# %%\nfig = plt.figure(figsize=(8, 4))\nfig.subplots_adjust(wspace=0.3, left=0.05, right=0.95)\n\nax1, aux_ax1 = setup_axes1(fig, 131)\naux_ax1.bar([0, 1, 2, 3], [3, 2, 1, 3])\n\nax2, aux_ax2 = setup_axes2(fig, 132)\ntheta = np.random.rand(10)*.5*np.pi\nradius = np.random.rand(10) + 1.\naux_ax2.scatter(theta, radius)\n\nax3, aux_ax3 = setup_axes3(fig, 133)\n\ntheta = (8 + np.random.rand(10)*(14 - 8))*15.  # in degrees\nradius = np.random.rand(10)*14000.\naux_ax3.scatter(theta, radius)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/12axisartist_199_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================\nfloating_axis demo\n==================\n\nAxis within rectangular frame.\n\nThe following code demonstrates how to put a floating polar curve within a\nrectangular box. In order to get a better sense of polar curves, please look at\n:doc:`/gallery/axisartist/demo_curvelinear_grid`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nfrom mpl_toolkits.axisartist import GridHelperCurveLinear, HostAxes\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\n\n\ndef curvelinear_test2(fig):\n    \"\"\"Polar projection, but in a rectangular box.\"\"\"\n    # see demo_curvelinear_grid.py for details\n    tr = Affine2D().scale(np.pi / 180., 1.) + PolarAxes.PolarTransform()\n\n    extreme_finder = angle_helper.ExtremeFinderCycle(20,\n                                                     20,\n                                                     lon_cycle=360,\n                                                     lat_cycle=None,\n                                                     lon_minmax=None,\n                                                     lat_minmax=(0, np.inf),\n                                                     )\n\n    grid_locator1 = angle_helper.LocatorDMS(12)\n\n    tick_formatter1 = angle_helper.FormatterDMS()\n\n    grid_helper = GridHelperCurveLinear(tr,\n                                        extreme_finder=extreme_finder,\n                                        grid_locator1=grid_locator1,\n                                        tick_formatter1=tick_formatter1\n                                        )\n\n    ax1 = fig.add_subplot(axes_class=HostAxes, grid_helper=grid_helper)\n\n    # Now creates floating axis\n\n    # floating axis whose first coordinate (theta) is fixed at 60\n    ax1.axis[\"lat\"] = axis = ax1.new_floating_axis(0, 60)\n    axis.label.set_text(r\"$\\theta = 60^{\\circ}$\")\n    axis.label.set_visible(True)\n\n    # floating axis whose second coordinate (r) is fixed at 6\n    ax1.axis[\"lon\"] = axis = ax1.new_floating_axis(1, 6)\n    axis.label.set_text(r\"$r = 6$\")\n\n    ax1.set_aspect(1.)\n    ax1.set_xlim(-5, 12)\n    ax1.set_ylim(-5, 10)\n\n    ax1.grid(True)\n\n\nfig = plt.figure(figsize=(5, 5))\ncurvelinear_test2(fig)\nplt.show()"
      },
      {
        "image_path": "gallery_assets/12axisartist_200_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================\nParasite Axes demo\n==================\n\nCreate a parasite axes. Such axes would share the x scale with a host axes,\nbut show a different scale in y direction.\n\nThis approach uses `mpl_toolkits.axes_grid1.parasite_axes.HostAxes` and\n`mpl_toolkits.axes_grid1.parasite_axes.ParasiteAxes`.\n\nThe standard and recommended approach is to use instead standard Matplotlib\naxes, as shown in the :doc:`/gallery/spines/multiple_yaxis_with_spines`\nexample.\n\nAn alternative approach using `mpl_toolkits.axes_grid1` and\n`mpl_toolkits.axisartist` is shown in the\n:doc:`/gallery/axisartist/demo_parasite_axes2` example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axisartist.parasite_axes import HostAxes\n\nfig = plt.figure()\n\nhost = fig.add_axes([0.15, 0.1, 0.65, 0.8], axes_class=HostAxes)\npar1 = host.get_aux_axes(viewlim_mode=None, sharex=host)\npar2 = host.get_aux_axes(viewlim_mode=None, sharex=host)\n\nhost.axis[\"right\"].set_visible(False)\n\npar1.axis[\"right\"].set_visible(True)\npar1.axis[\"right\"].major_ticklabels.set_visible(True)\npar1.axis[\"right\"].label.set_visible(True)\n\npar2.axis[\"right2\"] = par2.new_fixed_axis(loc=\"right\", offset=(60, 0))\n\np1, = host.plot([0, 1, 2], [0, 1, 2], label=\"Density\")\np2, = par1.plot([0, 1, 2], [0, 3, 2], label=\"Temperature\")\np3, = par2.plot([0, 1, 2], [50, 30, 15], label=\"Velocity\")\n\nhost.set(xlim=(0, 2), ylim=(0, 2), xlabel=\"Distance\", ylabel=\"Density\")\npar1.set(ylim=(0, 4), ylabel=\"Temperature\")\npar2.set(ylim=(1, 65), ylabel=\"Velocity\")\n\nhost.legend()\n\nhost.axis[\"left\"].label.set_color(p1.get_color())\npar1.axis[\"right\"].label.set_color(p2.get_color())\npar2.axis[\"right2\"].label.set_color(p3.get_color())\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/12axisartist_201_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================\nParasite axis demo\n==================\n\nThis example demonstrates the use of parasite axis to plot multiple datasets\nonto one single plot.\n\nNotice how in this example, *par1* and *par2* are both obtained by calling\n``twinx()``, which ties their x-limits with the host's x-axis. From there, each\nof those two axis behave separately from each other: different datasets can be\nplotted, and the y-limits are adjusted separately.\n\nThis approach uses `mpl_toolkits.axes_grid1.parasite_axes.host_subplot` and\n`mpl_toolkits.axisartist.axislines.Axes`.\n\nThe standard and recommended approach is to use instead standard Matplotlib\naxes, as shown in the :doc:`/gallery/spines/multiple_yaxis_with_spines`\nexample.\n\nAn alternative approach using `mpl_toolkits.axes_grid1.parasite_axes.HostAxes`\nand `mpl_toolkits.axes_grid1.parasite_axes.ParasiteAxes` is shown in the\n:doc:`/gallery/axisartist/demo_parasite_axes` example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits import axisartist\nfrom mpl_toolkits.axes_grid1 import host_subplot\n\nhost = host_subplot(111, axes_class=axisartist.Axes)\nplt.subplots_adjust(right=0.75)\n\npar1 = host.twinx()\npar2 = host.twinx()\n\npar2.axis[\"right\"] = par2.new_fixed_axis(loc=\"right\", offset=(60, 0))\n\npar1.axis[\"right\"].toggle(all=True)\npar2.axis[\"right\"].toggle(all=True)\n\np1, = host.plot([0, 1, 2], [0, 1, 2], label=\"Density\")\np2, = par1.plot([0, 1, 2], [0, 3, 2], label=\"Temperature\")\np3, = par2.plot([0, 1, 2], [50, 30, 15], label=\"Velocity\")\n\nhost.set(xlim=(0, 2), ylim=(0, 2), xlabel=\"Distance\", ylabel=\"Density\")\npar1.set(ylim=(0, 4), ylabel=\"Temperature\")\npar2.set(ylim=(1, 65), ylabel=\"Velocity\")\n\nhost.legend()\n\nhost.axis[\"left\"].label.set_color(p1.get_color())\npar1.axis[\"right\"].label.set_color(p2.get_color())\npar2.axis[\"right\"].label.set_color(p3.get_color())\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/12axisartist_202_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===================\nTicklabel alignment\n===================\n\n\"\"\"\n\n\nimport matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axisartist.Axes)\n    ax.set_yticks([0.2, 0.8], labels=[\"short\", \"loooong\"])\n    ax.set_xticks([0.2, 0.8], labels=[r\"$\\frac{1}{2}\\pi$\", r\"$\\pi$\"])\n    return ax\n\n\nfig = plt.figure(figsize=(3, 5))\nfig.subplots_adjust(left=0.5, hspace=0.7)\n\nax = setup_axes(fig, 311)\nax.set_ylabel(\"ha=right\")\nax.set_xlabel(\"va=baseline\")\n\nax = setup_axes(fig, 312)\nax.axis[\"left\"].major_ticklabels.set_ha(\"center\")\nax.axis[\"bottom\"].major_ticklabels.set_va(\"top\")\nax.set_ylabel(\"ha=center\")\nax.set_xlabel(\"va=top\")\n\nax = setup_axes(fig, 313)\nax.axis[\"left\"].major_ticklabels.set_ha(\"left\")\nax.axis[\"bottom\"].major_ticklabels.set_va(\"bottom\")\nax.set_ylabel(\"ha=left\")\nax.set_xlabel(\"va=bottom\")\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/12axisartist_203_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===================\nTicklabel direction\n===================\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist.axislines as axislines\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axislines.Axes)\n    ax.set_yticks([0.2, 0.8])\n    ax.set_xticks([0.2, 0.8])\n    return ax\n\n\nfig = plt.figure(figsize=(6, 3))\nfig.subplots_adjust(bottom=0.2)\n\nax = setup_axes(fig, 131)\nfor axis in ax.axis.values():\n    axis.major_ticks.set_tick_out(True)\n# or you can simply do \"ax.axis[:].major_ticks.set_tick_out(True)\"\n\nax = setup_axes(fig, 132)\nax.axis[\"left\"].set_axis_direction(\"right\")\nax.axis[\"bottom\"].set_axis_direction(\"top\")\nax.axis[\"right\"].set_axis_direction(\"left\")\nax.axis[\"top\"].set_axis_direction(\"bottom\")\n\nax = setup_axes(fig, 133)\nax.axis[\"left\"].set_axis_direction(\"right\")\nax.axis[:].major_ticks.set_tick_out(True)\n\nax.axis[\"left\"].label.set_text(\"Long Label Left\")\nax.axis[\"bottom\"].label.set_text(\"Label Bottom\")\nax.axis[\"right\"].label.set_text(\"Long Label Right\")\nax.axis[\"right\"].label.set_visible(True)\nax.axis[\"left\"].label.set_pad(0)\nax.axis[\"bottom\"].label.set_pad(10)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/12axisartist_204_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=====================\nSimple axis direction\n=====================\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\nfig = plt.figure(figsize=(4, 2.5))\nax1 = fig.add_subplot(axes_class=axisartist.Axes)\nfig.subplots_adjust(right=0.8)\n\nax1.axis[\"left\"].major_ticklabels.set_axis_direction(\"top\")\nax1.axis[\"left\"].label.set_text(\"Left label\")\n\nax1.axis[\"right\"].label.set_visible(True)\nax1.axis[\"right\"].label.set_text(\"Right label\")\nax1.axis[\"right\"].label.set_axis_direction(\"left\")\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/12axisartist_205_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========================================\nSimple axis tick label and tick directions\n==========================================\n\nFirst subplot moves the tick labels to inside the spines.\nSecond subplot moves the ticks to inside the spines.\nThese effects can be obtained for a standard Axes by `~.Axes.tick_params`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axisartist.Axes)\n    ax.set_yticks([0.2, 0.8])\n    ax.set_xticks([0.2, 0.8])\n    return ax\n\n\nfig = plt.figure(figsize=(5, 2))\nfig.subplots_adjust(wspace=0.4, bottom=0.3)\n\nax1 = setup_axes(fig, 121)\nax1.set_xlabel(\"ax1 X-label\")\nax1.set_ylabel(\"ax1 Y-label\")\n\nax1.axis[:].invert_ticklabel_direction()\n\nax2 = setup_axes(fig, 122)\nax2.set_xlabel(\"ax2 X-label\")\nax2.set_ylabel(\"ax2 Y-label\")\n\nax2.axis[:].major_ticks.set_tick_out(False)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/12axisartist_206_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============\nSimple Axis Pad\n===============\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nimport mpl_toolkits.axisartist as axisartist\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\nimport mpl_toolkits.axisartist.grid_finder as grid_finder\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import \\\n    GridHelperCurveLinear\n\n\ndef setup_axes(fig, rect):\n    \"\"\"Polar projection, but in a rectangular box.\"\"\"\n\n    # see demo_curvelinear_grid.py for details\n    tr = Affine2D().scale(np.pi/180., 1.) + PolarAxes.PolarTransform()\n\n    extreme_finder = angle_helper.ExtremeFinderCycle(20, 20,\n                                                     lon_cycle=360,\n                                                     lat_cycle=None,\n                                                     lon_minmax=None,\n                                                     lat_minmax=(0, np.inf),\n                                                     )\n\n    grid_locator1 = angle_helper.LocatorDMS(12)\n    grid_locator2 = grid_finder.MaxNLocator(5)\n\n    tick_formatter1 = angle_helper.FormatterDMS()\n\n    grid_helper = GridHelperCurveLinear(tr,\n                                        extreme_finder=extreme_finder,\n                                        grid_locator1=grid_locator1,\n                                        grid_locator2=grid_locator2,\n                                        tick_formatter1=tick_formatter1\n                                        )\n\n    ax1 = fig.add_subplot(\n        rect, axes_class=axisartist.Axes, grid_helper=grid_helper)\n    ax1.axis[:].set_visible(False)\n    ax1.set_aspect(1.)\n    ax1.set_xlim(-5, 12)\n    ax1.set_ylim(-5, 10)\n\n    return ax1\n\n\ndef add_floating_axis1(ax1):\n    ax1.axis[\"lat\"] = axis = ax1.new_floating_axis(0, 30)\n    axis.label.set_text(r\"$\\theta = 30^{\\circ}$\")\n    axis.label.set_visible(True)\n\n    return axis\n\n\ndef add_floating_axis2(ax1):\n    ax1.axis[\"lon\"] = axis = ax1.new_floating_axis(1, 6)\n    axis.label.set_text(r\"$r = 6$\")\n    axis.label.set_visible(True)\n\n    return axis\n\n\nfig = plt.figure(figsize=(9, 3.))\nfig.subplots_adjust(left=0.01, right=0.99, bottom=0.01, top=0.99,\n                    wspace=0.01, hspace=0.01)\n\n\ndef ann(ax1, d):\n    if plt.rcParams[\"text.usetex\"]:\n        d = d.replace(\"_\", r\"\\_\")\n\n    ax1.annotate(d, (0.5, 1), (5, -5),\n                 xycoords=\"axes fraction\", textcoords=\"offset points\",\n                 va=\"top\", ha=\"center\")\n\n\nax1 = setup_axes(fig, rect=141)\naxis = add_floating_axis1(ax1)\nann(ax1, r\"default\")\n\nax1 = setup_axes(fig, rect=142)\naxis = add_floating_axis1(ax1)\naxis.major_ticklabels.set_pad(10)\nann(ax1, r\"ticklabels.set_pad(10)\")\n\nax1 = setup_axes(fig, rect=143)\naxis = add_floating_axis1(ax1)\naxis.label.set_pad(20)\nann(ax1, r\"label.set_pad(20)\")\n\nax1 = setup_axes(fig, rect=144)\naxis = add_floating_axis1(ax1)\naxis.major_ticks.set_tick_out(True)\nann(ax1, \"ticks.set_tick_out(True)\")\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/12axisartist_207_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============================\nCustom spines with axisartist\n=============================\n\nThis example showcases the use of :mod:`.axisartist` to draw spines at custom\npositions (here, at ``y = 0``).\n\nNote, however, that it is simpler to achieve this effect using standard\n`.Spine` methods, as demonstrated in\n:doc:`/gallery/spines/centered_spines_with_arrows`.\n\n.. redirect-from:: /gallery/axisartist/simple_axisline2\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits import axisartist\n\nfig = plt.figure(figsize=(6, 3), layout=\"constrained\")\n# To construct axes of two different classes, we need to use gridspec (or\n# MATLAB-style add_subplot calls).\ngs = fig.add_gridspec(1, 2)\n\n\nax0 = fig.add_subplot(gs[0, 0], axes_class=axisartist.Axes)\n# Make a new axis along the first (x) axis which passes through y=0.\nax0.axis[\"y=0\"] = ax0.new_floating_axis(nth_coord=0, value=0,\n                                        axis_direction=\"bottom\")\nax0.axis[\"y=0\"].toggle(all=True)\nax0.axis[\"y=0\"].label.set_text(\"y = 0\")\n# Make other axis invisible.\nax0.axis[\"bottom\", \"top\", \"right\"].set_visible(False)\n\n\n# Alternatively, one can use AxesZero, which automatically sets up two\n# additional axis, named \"xzero\" (the y=0 axis) and \"yzero\" (the x=0 axis).\nax1 = fig.add_subplot(gs[0, 1], axes_class=axisartist.axislines.AxesZero)\n# \"xzero\" and \"yzero\" default to invisible; make xzero axis visible.\nax1.axis[\"xzero\"].set_visible(True)\nax1.axis[\"xzero\"].label.set_text(\"Axis Zero\")\n# Make other axis invisible.\nax1.axis[\"bottom\", \"top\", \"right\"].set_visible(False)\n\n\n# Draw some sample data.\nx = np.arange(0, 2*np.pi, 0.01)\nax0.plot(x, np.sin(x))\nax1.plot(x, np.sin(x))\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/12axisartist_208_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============\nSimple Axisline\n===============\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axisartist.axislines import AxesZero\n\nfig = plt.figure()\nfig.subplots_adjust(right=0.85)\nax = fig.add_subplot(axes_class=AxesZero)\n\n# make right and top axis invisible\nax.axis[\"right\"].set_visible(False)\nax.axis[\"top\"].set_visible(False)\n\n# make xzero axis (horizontal axis line through y=0) visible.\nax.axis[\"xzero\"].set_visible(True)\nax.axis[\"xzero\"].label.set_text(\"Axis Zero\")\n\nax.set_ylim(-2, 4)\nax.set_xlabel(\"Label X\")\nax.set_ylabel(\"Label Y\")\n# Or:\n# ax.axis[\"bottom\"].label.set_text(\"Label X\")\n# ax.axis[\"left\"].label.set_text(\"Label Y\")\n\n# make new (right-side) yaxis, but with some offset\nax.axis[\"right2\"] = ax.new_fixed_axis(loc=\"right\", offset=(20, 0))\nax.axis[\"right2\"].label.set_text(\"Label Y2\")\n\nax.plot([-2, 3, 2])\nplt.show()"
      },
      {
        "image_path": "gallery_assets/12axisartist_209_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nSimple Axisline3\n================\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axisartist.axislines import Axes\n\nfig = plt.figure(figsize=(3, 3))\n\nax = fig.add_subplot(axes_class=Axes)\n\nax.axis[\"right\"].set_visible(False)\nax.axis[\"top\"].set_visible(False)\n\nplt.show()"
      }
    ],
    "13showcase": [
      {
        "image_path": "gallery_assets/13showcase_210_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===================\nAnatomy of a figure\n===================\n\nThis figure shows the name of several matplotlib elements composing a figure\n\"\"\"\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Circle\nfrom matplotlib.patheffects import withStroke\nfrom matplotlib.ticker import AutoMinorLocator, MultipleLocator\n\nroyal_blue = [0, 20/256, 82/256]\n\n\n# make the figure\n\nnp.random.seed(19680801)\n\nX = np.linspace(0.5, 3.5, 100)\nY1 = 3+np.cos(X)\nY2 = 1+np.cos(1+X/0.75)/2\nY3 = np.random.uniform(Y1, Y2, len(X))\n\nfig = plt.figure(figsize=(7.5, 7.5))\nax = fig.add_axes([0.2, 0.17, 0.68, 0.7], aspect=1)\n\nax.xaxis.set_major_locator(MultipleLocator(1.000))\nax.xaxis.set_minor_locator(AutoMinorLocator(4))\nax.yaxis.set_major_locator(MultipleLocator(1.000))\nax.yaxis.set_minor_locator(AutoMinorLocator(4))\nax.xaxis.set_minor_formatter(\"{x:.2f}\")\n\nax.set_xlim(0, 4)\nax.set_ylim(0, 4)\n\nax.tick_params(which='major', width=1.0, length=10, labelsize=14)\nax.tick_params(which='minor', width=1.0, length=5, labelsize=10,\n               labelcolor='0.25')\n\nax.grid(linestyle=\"--\", linewidth=0.5, color='.25', zorder=-10)\n\nax.plot(X, Y1, c='C0', lw=2.5, label=\"Blue signal\", zorder=10)\nax.plot(X, Y2, c='C1', lw=2.5, label=\"Orange signal\")\nax.plot(X[::3], Y3[::3], linewidth=0, markersize=9,\n        marker='s', markerfacecolor='none', markeredgecolor='C4',\n        markeredgewidth=2.5)\n\nax.set_title(\"Anatomy of a figure\", fontsize=20, verticalalignment='bottom')\nax.set_xlabel(\"x Axis label\", fontsize=14)\nax.set_ylabel(\"y Axis label\", fontsize=14)\nax.legend(loc=\"upper right\", fontsize=14)\n\n\n# Annotate the figure\n\ndef annotate(x, y, text, code):\n    # Circle marker\n    c = Circle((x, y), radius=0.15, clip_on=False, zorder=10, linewidth=2.5,\n               edgecolor=royal_blue + [0.6], facecolor='none',\n               path_effects=[withStroke(linewidth=7, foreground='white')])\n    ax.add_artist(c)\n\n    # use path_effects as a background for the texts\n    # draw the path_effects and the colored text separately so that the\n    # path_effects cannot clip other texts\n    for path_effects in [[withStroke(linewidth=7, foreground='white')], []]:\n        color = 'white' if path_effects else royal_blue\n        ax.text(x, y-0.2, text, zorder=100,\n                ha='center', va='top', weight='bold', color=color,\n                style='italic', fontfamily='Courier New',\n                path_effects=path_effects)\n\n        color = 'white' if path_effects else 'black'\n        ax.text(x, y-0.33, code, zorder=100,\n                ha='center', va='top', weight='normal', color=color,\n                fontfamily='monospace', fontsize='medium',\n                path_effects=path_effects)\n\n\nannotate(3.5, -0.13, \"Minor tick label\", \"ax.xaxis.set_minor_formatter\")\nannotate(-0.03, 1.0, \"Major tick\", \"ax.yaxis.set_major_locator\")\nannotate(0.00, 3.75, \"Minor tick\", \"ax.yaxis.set_minor_locator\")\nannotate(-0.15, 3.00, \"Major tick label\", \"ax.yaxis.set_major_formatter\")\nannotate(1.68, -0.39, \"xlabel\", \"ax.set_xlabel\")\nannotate(-0.38, 1.67, \"ylabel\", \"ax.set_ylabel\")\nannotate(1.52, 4.15, \"Title\", \"ax.set_title\")\nannotate(1.75, 2.80, \"Line\", \"ax.plot\")\nannotate(2.25, 1.54, \"Markers\", \"ax.scatter\")\nannotate(3.00, 3.00, \"Grid\", \"ax.grid\")\nannotate(3.60, 3.58, \"Legend\", \"ax.legend\")\nannotate(2.5, 0.55, \"Axes\", \"fig.subplots\")\nannotate(4, 4.5, \"Figure\", \"plt.figure\")\nannotate(0.65, 0.01, \"x Axis\", \"ax.xaxis\")\nannotate(0, 0.36, \"y Axis\", \"ax.yaxis\")\nannotate(4.0, 0.7, \"Spine\", \"ax.spines\")\n\n# frame around figure\nfig.patch.set(linewidth=4, edgecolor='0.5')\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.figure`\n#    - `matplotlib.axes.Axes.text`\n#    - `matplotlib.axis.Axis.set_minor_formatter`\n#    - `matplotlib.axis.Axis.set_major_locator`\n#    - `matplotlib.axis.Axis.set_minor_locator`\n#    - `matplotlib.patches.Circle`\n#    - `matplotlib.patheffects.withStroke`\n#    - `matplotlib.ticker.FuncFormatter`"
      },
      {
        "image_path": "gallery_assets/13showcase_211_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======\nFirefox\n=======\n\nThis example shows how to create the Firefox logo with path and patches.\n\"\"\"\n\nimport re\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as patches\nfrom matplotlib.path import Path\n\n# From: https://dmitrybaranovskiy.github.io/raphael/icons/#firefox\nfirefox = \"M28.4,22.469c0.479-0.964,0.851-1.991,1.095-3.066c0.953-3.661,0.666-6.854,0.666-6.854l-0.327,2.104c0,0-0.469-3.896-1.044-5.353c-0.881-2.231-1.273-2.214-1.274-2.21c0.542,1.379,0.494,2.169,0.483,2.288c-0.01-0.016-0.019-0.032-0.027-0.047c-0.131-0.324-0.797-1.819-2.225-2.878c-2.502-2.481-5.943-4.014-9.745-4.015c-4.056,0-7.705,1.745-10.238,4.525C5.444,6.5,5.183,5.938,5.159,5.317c0,0-0.002,0.002-0.006,0.005c0-0.011-0.003-0.021-0.003-0.031c0,0-1.61,1.247-1.436,4.612c-0.299,0.574-0.56,1.172-0.777,1.791c-0.375,0.817-0.75,2.004-1.059,3.746c0,0,0.133-0.422,0.399-0.988c-0.064,0.482-0.103,0.971-0.116,1.467c-0.09,0.845-0.118,1.865-0.039,3.088c0,0,0.032-0.406,0.136-1.021c0.834,6.854,6.667,12.165,13.743,12.165l0,0c1.86,0,3.636-0.37,5.256-1.036C24.938,27.771,27.116,25.196,28.4,22.469zM16.002,3.356c2.446,0,4.73,0.68,6.68,1.86c-2.274-0.528-3.433-0.261-3.423-0.248c0.013,0.015,3.384,0.589,3.981,1.411c0,0-1.431,0-2.856,0.41c-0.065,0.019,5.242,0.663,6.327,5.966c0,0-0.582-1.213-1.301-1.42c0.473,1.439,0.351,4.17-0.1,5.528c-0.058,0.174-0.118-0.755-1.004-1.155c0.284,2.037-0.018,5.268-1.432,6.158c-0.109,0.07,0.887-3.189,0.201-1.93c-4.093,6.276-8.959,2.539-10.934,1.208c1.585,0.388,3.267,0.108,4.242-0.559c0.982-0.672,1.564-1.162,2.087-1.047c0.522,0.117,0.87-0.407,0.464-0.872c-0.405-0.466-1.392-1.105-2.725-0.757c-0.94,0.247-2.107,1.287-3.886,0.233c-1.518-0.899-1.507-1.63-1.507-2.095c0-0.366,0.257-0.88,0.734-1.028c0.58,0.062,1.044,0.214,1.537,0.466c0.005-0.135,0.006-0.315-0.001-0.519c0.039-0.077,0.015-0.311-0.047-0.596c-0.036-0.287-0.097-0.582-0.19-0.851c0.01-0.002,0.017-0.007,0.021-0.021c0.076-0.344,2.147-1.544,2.299-1.659c0.153-0.114,0.55-0.378,0.506-1.183c-0.015-0.265-0.058-0.294-2.232-0.286c-0.917,0.003-1.425-0.894-1.589-1.245c0.222-1.231,0.863-2.11,1.919-2.704c0.02-0.011,0.015-0.021-0.008-0.027c0.219-0.127-2.524-0.006-3.76,1.604C9.674,8.045,9.219,7.95,8.71,7.95c-0.638,0-1.139,0.07-1.603,0.187c-0.05,0.013-0.122,0.011-0.208-0.001C6.769,8.04,6.575,7.88,6.365,7.672c0.161-0.18,0.324-0.356,0.495-0.526C9.201,4.804,12.43,3.357,16.002,3.356z\"  # noqa\n\n\ndef svg_parse(path):\n    commands = {'M': (Path.MOVETO,),\n                'L': (Path.LINETO,),\n                'Q': (Path.CURVE3,)*2,\n                'C': (Path.CURVE4,)*3,\n                'Z': (Path.CLOSEPOLY,)}\n    vertices = []\n    codes = []\n    cmd_values = re.split(\"([A-Za-z])\", path)[1:]  # Split over commands.\n    for cmd, values in zip(cmd_values[::2], cmd_values[1::2]):\n        # Numbers are separated either by commas, or by +/- signs (but not at\n        # the beginning of the string).\n        points = ([*map(float, re.split(\",|(?<!^)(?=[+-])\", values))] if values\n                  else [(0., 0.)])  # Only for \"z/Z\" (CLOSEPOLY).\n        points = np.reshape(points, (-1, 2))\n        if cmd.islower():\n            points += vertices[-1][-1]\n        codes.extend(commands[cmd.upper()])\n        vertices.append(points)\n    return np.array(codes), np.concatenate(vertices)\n\n\n# SVG to Matplotlib\ncodes, verts = svg_parse(firefox)\npath = Path(verts, codes)\n\nxmin, ymin = verts.min(axis=0) - 1\nxmax, ymax = verts.max(axis=0) + 1\n\nfig = plt.figure(figsize=(5, 5), facecolor=\"0.75\")  # gray background\nax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect=1,\n                  xlim=(xmin, xmax),  # centering\n                  ylim=(ymax, ymin),  # centering, upside down\n                  xticks=[], yticks=[])  # no ticks\n\n# White outline (width = 6)\nax.add_patch(patches.PathPatch(path, facecolor='none', edgecolor='w', lw=6))\n# Actual shape with black outline\nax.add_patch(patches.PathPatch(path, facecolor='orange', edgecolor='k', lw=2))\n\nplt.show()  # Display"
      },
      {
        "image_path": "gallery_assets/13showcase_212_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================================\nIntegral as the area under a curve\n==================================\n\nAlthough this is a simple example, it demonstrates some important tweaks:\n\n* A simple line plot with custom color and line width.\n* A shaded region created using a Polygon patch.\n* A text label with mathtext rendering.\n* figtext calls to label the x- and y-axes.\n* Use of axis spines to hide the top and right spines.\n* Custom tick placement and labels.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Polygon\n\n\ndef func(x):\n    return (x - 3) * (x - 5) * (x - 7) + 85\n\n\na, b = 2, 9  # integral limits\nx = np.linspace(0, 10)\ny = func(x)\n\nfig, ax = plt.subplots()\nax.plot(x, y, 'r', linewidth=2)\nax.set_ylim(bottom=0)\n\n# Make the shaded region\nix = np.linspace(a, b)\niy = func(ix)\nverts = [(a, 0), *zip(ix, iy), (b, 0)]\npoly = Polygon(verts, facecolor='0.9', edgecolor='0.5')\nax.add_patch(poly)\n\nax.text(0.5 * (a + b), 30, r\"$\\int_a^b f(x)\\mathrm{d}x$\",\n        horizontalalignment='center', fontsize=20)\n\nfig.text(0.9, 0.05, '$x$')\nfig.text(0.1, 0.9, '$y$')\n\nax.spines[['top', 'right']].set_visible(False)\nax.set_xticks([a, b], labels=['$a$', '$b$'])\nax.set_yticks([])\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/13showcase_213_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========================\nStock prices over 32 years\n==========================\n\n.. redirect-from:: /gallery/showcase/bachelors_degrees_by_gender\n\nA graph of multiple time series that demonstrates custom styling of plot frame,\ntick lines, tick labels, and line graph properties. It also uses custom\nplacement of text labels along the right edge as an alternative to a\nconventional legend.\n\nNote: The third-party mpl style dufte_ produces similar-looking plots with less\ncode.\n\n.. _dufte: https://github.com/nschloe/dufte\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\nimport matplotlib.transforms as mtransforms\n\nwith get_sample_data('Stocks.csv') as file:\n    stock_data = np.genfromtxt(\n        file, delimiter=',', names=True, dtype=None,\n        converters={0: lambda x: np.datetime64(x, 'D')}, skip_header=1)\n\nfig, ax = plt.subplots(1, 1, figsize=(6, 8), layout='constrained')\n\n# These are the colors that will be used in the plot\nax.set_prop_cycle(color=[\n    '#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a',\n    '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94',\n    '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d',\n    '#17becf', '#9edae5'])\n\nstocks_name = ['IBM', 'Apple', 'Microsoft', 'Xerox', 'Amazon', 'Dell',\n               'Alphabet', 'Adobe', 'S&P 500', 'NASDAQ']\nstocks_ticker = ['IBM', 'AAPL', 'MSFT', 'XRX', 'AMZN', 'DELL', 'GOOGL',\n                 'ADBE', 'GSPC', 'IXIC']\n\n# Manually adjust the label positions vertically (units are points = 1/72 inch)\ny_offsets = {k: 0 for k in stocks_ticker}\ny_offsets['IBM'] = 5\ny_offsets['AAPL'] = -5\ny_offsets['AMZN'] = -6\n\nfor nn, column in enumerate(stocks_ticker):\n    # Plot each line separately with its own color.\n    # don't include any data with NaN.\n    good = np.nonzero(np.isfinite(stock_data[column]))\n    line, = ax.plot(stock_data['Date'][good], stock_data[column][good], lw=2.5)\n\n    # Add a text label to the right end of every line. Most of the code below\n    # is adding specific offsets y position because some labels overlapped.\n    y_pos = stock_data[column][-1]\n\n    # Use an offset transform, in points, for any text that needs to be nudged\n    # up or down.\n    offset = y_offsets[column] / 72\n    trans = mtransforms.ScaledTranslation(0, offset, fig.dpi_scale_trans)\n    trans = ax.transData + trans\n\n    # Again, make sure that all labels are large enough to be easily read\n    # by the viewer.\n    ax.text(np.datetime64('2022-10-01'), y_pos, stocks_name[nn],\n            color=line.get_color(), transform=trans)\n\nax.set_xlim(np.datetime64('1989-06-01'), np.datetime64('2023-01-01'))\n\nfig.suptitle(\"Technology company stocks prices dollars (1990-2022)\",\n             ha=\"center\")\n\n# Remove the plot frame lines. They are unnecessary here.\nax.spines[:].set_visible(False)\n\n# Ensure that the axis ticks only show up on the bottom and left of the plot.\n# Ticks on the right and top of the plot are generally unnecessary.\nax.xaxis.tick_bottom()\nax.yaxis.tick_left()\nax.set_yscale('log')\n\n# Provide tick lines across the plot to help your viewers trace along\n# the axis ticks. Make sure that the lines are light and small so they\n# don't obscure the primary data lines.\nax.grid(True, 'major', 'both', ls='--', lw=.5, c='k', alpha=.3)\n\n# Remove the tick marks; they are unnecessary with the tick lines we just\n# plotted. Make sure your axis ticks are large enough to be easily read.\n# You don't want your viewers squinting to read your plot.\nax.tick_params(axis='both', which='both', labelsize='large',\n               bottom=False, top=False, labelbottom=True,\n               left=False, right=False, labelleft=True)\n\n# Finally, save the figure as a PNG.\n# You can also save it as a PDF, JPEG, etc.\n# Just change the file extension in this call.\n# fig.savefig('stock-prices.png', bbox_inches='tight')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.axes.Axes.text`\n#    - `matplotlib.axis.XAxis.tick_bottom`\n#    - `matplotlib.axis.YAxis.tick_left`\n#    - `matplotlib.artist.Artist.set_visible`"
      },
      {
        "image_path": "gallery_assets/13showcase_214_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n====\nXKCD\n====\n\nShows how to create an xkcd-like plot.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# %%\n\nwith plt.xkcd():\n    # Based on \"Stove Ownership\" from XKCD by Randall Munroe\n    # https://xkcd.com/418/\n\n    fig = plt.figure()\n    ax = fig.add_axes((0.1, 0.2, 0.8, 0.7))\n    ax.spines[['top', 'right']].set_visible(False)\n    ax.set_xticks([])\n    ax.set_yticks([])\n    ax.set_ylim([-30, 10])\n\n    data = np.ones(100)\n    data[70:] -= np.arange(30)\n\n    ax.annotate(\n        'THE DAY I REALIZED\\nI COULD COOK BACON\\nWHENEVER I WANTED',\n        xy=(70, 1), arrowprops=dict(arrowstyle='->'), xytext=(15, -10))\n\n    ax.plot(data)\n\n    ax.set_xlabel('time')\n    ax.set_ylabel('my overall health')\n    fig.text(\n        0.5, 0.05,\n        '\"Stove Ownership\" from xkcd by Randall Munroe',\n        ha='center')\n\n# %%\n\nwith plt.xkcd():\n    # Based on \"The Data So Far\" from XKCD by Randall Munroe\n    # https://xkcd.com/373/\n\n    fig = plt.figure()\n    ax = fig.add_axes((0.1, 0.2, 0.8, 0.7))\n    ax.bar([0, 1], [0, 100], 0.25)\n    ax.spines[['top', 'right']].set_visible(False)\n    ax.xaxis.set_ticks_position('bottom')\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(['CONFIRMED BY\\nEXPERIMENT', 'REFUTED BY\\nEXPERIMENT'])\n    ax.set_xlim([-0.5, 1.5])\n    ax.set_yticks([])\n    ax.set_ylim([0, 110])\n\n    ax.set_title(\"CLAIMS OF SUPERNATURAL POWERS\")\n\n    fig.text(\n        0.5, 0.05,\n        '\"The Data So Far\" from xkcd by Randall Munroe',\n        ha='center')\n\nplt.show()"
      }
    ],
    "17mplot3d": [
      {
        "image_path": "gallery_assets/17mplot3d_215_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======================\nPlot 2D data on 3D plot\n=======================\n\nDemonstrates using ax.plot's *zdir* keyword to plot 2D data on\nselective axes of a 3D plot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Plot a sin curve using the x and y axes.\nx = np.linspace(0, 1, 100)\ny = np.sin(x * 2 * np.pi) / 2 + 0.5\nax.plot(x, y, zs=0, zdir='z', label='curve in (x, y)')\n\n# Plot scatterplot data (20 2D points per colour) on the x and z axes.\ncolors = ('r', 'g', 'b', 'k')\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx = np.random.sample(20 * len(colors))\ny = np.random.sample(20 * len(colors))\nc_list = []\nfor c in colors:\n    c_list.extend([c] * 20)\n# By using zdir='y', the y value of these points is fixed to the zs value 0\n# and the (x, y) points are plotted on the x and z axes.\nax.scatter(x, y, zs=0, zdir='y', c=c_list, label='points in (x, z)')\n\n# Make legend, set axes limits and labels\nax.legend()\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\nax.set_zlim(0, 1)\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')\n\n# Customize the view angle so it's easier to see that the scatter points lie\n# on the plane y=0\nax.view_init(elev=20., azim=-35, roll=0)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_216_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=====================\nDemo of 3D bar charts\n=====================\n\nA basic demo of how to plot 3D bars with and without shading.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# set up the figure and axes\nfig = plt.figure(figsize=(8, 3))\nax1 = fig.add_subplot(121, projection='3d')\nax2 = fig.add_subplot(122, projection='3d')\n\n# fake data\n_x = np.arange(4)\n_y = np.arange(5)\n_xx, _yy = np.meshgrid(_x, _y)\nx, y = _xx.ravel(), _yy.ravel()\n\ntop = x + y\nbottom = np.zeros_like(top)\nwidth = depth = 1\n\nax1.bar3d(x, y, bottom, width, depth, top, shade=True)\nax1.set_title('Shaded')\n\nax2.bar3d(x, y, bottom, width, depth, top, shade=False)\nax2.set_title('Not Shaded')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_217_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========================================\nCreate 2D bar graphs in different planes\n========================================\n\nDemonstrates making a 3D plot which has 2D bar graphs projected onto\nplanes y=0, y=1, etc.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\ncolors = ['r', 'g', 'b', 'y']\nyticks = [3, 2, 1, 0]\nfor c, k in zip(colors, yticks):\n    # Generate the random data for the y=k 'layer'.\n    xs = np.arange(20)\n    ys = np.random.rand(20)\n\n    # You can provide either a single color or an array with the same length as\n    # xs and ys. To demonstrate this, we color the first bar of each set cyan.\n    cs = [c] * len(xs)\n    cs[0] = 'c'\n\n    # Plot the bar graph given by xs and ys on the plane y=k with 80% opacity.\n    ax.bar(xs, ys, zs=k, zdir='y', color=cs, alpha=0.8)\n\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')\n\n# On the y-axis let's only label the discrete values that we have data for.\nax.set_yticks(yticks)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_218_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===================\n3D box surface plot\n===================\n\nGiven data on a gridded volume ``X``, ``Y``, ``Z``, this example plots the\ndata values on the volume surfaces.\n\nThe strategy is to select the data from each surface and plot\ncontours separately using `.axes3d.Axes3D.contourf` with appropriate\nparameters *zdir* and *offset*.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Define dimensions\nNx, Ny, Nz = 100, 300, 500\nX, Y, Z = np.meshgrid(np.arange(Nx), np.arange(Ny), -np.arange(Nz))\n\n# Create fake data\ndata = (((X+100)**2 + (Y-20)**2 + 2*Z)/1000+1)\n\nkw = {\n    'vmin': data.min(),\n    'vmax': data.max(),\n    'levels': np.linspace(data.min(), data.max(), 10),\n}\n\n# Create a figure with 3D ax\nfig = plt.figure(figsize=(5, 4))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot contour surfaces\n_ = ax.contourf(\n    X[:, :, 0], Y[:, :, 0], data[:, :, 0],\n    zdir='z', offset=0, **kw\n)\n_ = ax.contourf(\n    X[0, :, :], data[0, :, :], Z[0, :, :],\n    zdir='y', offset=0, **kw\n)\nC = ax.contourf(\n    data[:, -1, :], Y[:, -1, :], Z[:, -1, :],\n    zdir='x', offset=X.max(), **kw\n)\n# --\n\n\n# Set limits of the plot from coord limits\nxmin, xmax = X.min(), X.max()\nymin, ymax = Y.min(), Y.max()\nzmin, zmax = Z.min(), Z.max()\nax.set(xlim=[xmin, xmax], ylim=[ymin, ymax], zlim=[zmin, zmax])\n\n# Plot edges\nedges_kw = dict(color='0.4', linewidth=1, zorder=1e3)\nax.plot([xmax, xmax], [ymin, ymax], 0, **edges_kw)\nax.plot([xmin, xmax], [ymin, ymin], 0, **edges_kw)\nax.plot([xmax, xmax], [ymin, ymin], [zmin, zmax], **edges_kw)\n\n# Set labels and zticks\nax.set(\n    xlabel='X [km]',\n    ylabel='Y [km]',\n    zlabel='Z [m]',\n    zticks=[0, -150, -300, -450],\n)\n\n# Set zoom and angle view\nax.view_init(40, -30, 0)\nax.set_box_aspect(None, zoom=0.9)\n\n# Colorbar\nfig.colorbar(C, ax=ax, fraction=0.02, pad=0.1, label='Name [units]')\n\n# Show Figure\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_219_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================================\nPlot contour (level) curves in 3D\n=================================\n\nThis is like a contour plot in 2D except that the ``f(x, y)=c`` curve is\nplotted on the plane ``z=c``.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\n\nax.contour(X, Y, Z, cmap=cm.coolwarm)  # Plot contour curves\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_220_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========================================================\nPlot contour (level) curves in 3D using the extend3d option\n===========================================================\n\nThis modification of the :doc:`contour3d` example uses ``extend3d=True`` to\nextend the curves vertically into 'ribbons'.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\nax.contour(X, Y, Z, extend3d=True, cmap=cm.coolwarm)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_221_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=====================================\nProject contour profiles onto a graph\n=====================================\nDemonstrates displaying a 3D surface while also projecting contour 'profiles'\nonto the 'walls' of the graph.\nSee :doc:`contourf3d_2` for the filled version.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot the 3D surface\nax.plot_surface(X, Y, Z, edgecolor='royalblue', lw=0.5, rstride=8, cstride=8,\n                alpha=0.3)\n\n# Plot projections of the contours for each dimension.  By choosing offsets\n# that match the appropriate axes limits, the projected contours will sit on\n# the 'walls' of the graph.\nax.contour(X, Y, Z, zdir='z', offset=-100, cmap='coolwarm')\nax.contour(X, Y, Z, zdir='x', offset=-40, cmap='coolwarm')\nax.contour(X, Y, Z, zdir='y', offset=40, cmap='coolwarm')\n\nax.set(xlim=(-40, 40), ylim=(-40, 40), zlim=(-100, 100),\n       xlabel='X', ylabel='Y', zlabel='Z')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_222_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============\nFilled contours\n===============\n\n`.Axes3D.contourf` differs from `.Axes3D.contour` in that it creates filled\ncontours, i.e. a discrete number of colours are used to shade the domain.\n\nThis is like a `.Axes.contourf` plot in 2D except that the shaded region\ncorresponding to the level c is graphed on the plane ``z=c``.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\nax.contourf(X, Y, Z, cmap=cm.coolwarm)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_223_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===================================\nProject filled contour onto a graph\n===================================\nDemonstrates displaying a 3D surface while also projecting filled contour\n'profiles' onto the 'walls' of the graph.\nSee :doc:`contour3d_3` for the unfilled version.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot the 3D surface\nax.plot_surface(X, Y, Z, edgecolor='royalblue', lw=0.5, rstride=8, cstride=8,\n                alpha=0.3)\n\n# Plot projections of the contours for each dimension.  By choosing offsets\n# that match the appropriate axes limits, the projected contours will sit on\n# the 'walls' of the graph\nax.contourf(X, Y, Z, zdir='z', offset=-100, cmap='coolwarm')\nax.contourf(X, Y, Z, zdir='x', offset=-40, cmap='coolwarm')\nax.contourf(X, Y, Z, zdir='y', offset=40, cmap='coolwarm')\n\nax.set(xlim=(-40, 40), ylim=(-40, 40), zlim=(-100, 100),\n       xlabel='X', ylabel='Y', zlabel='Z')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_224_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============\n3D errorbars\n============\n\nAn example of using errorbars with upper and lower limits in mplot3d.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\n# setting up a parametric curve\nt = np.arange(0, 2*np.pi+.1, 0.01)\nx, y, z = np.sin(t), np.cos(3*t), np.sin(5*t)\n\nestep = 15\ni = np.arange(t.size)\nzuplims = (i % estep == 0) & (i // estep % 3 == 0)\nzlolims = (i % estep == 0) & (i // estep % 3 == 2)\n\nax.errorbar(x, y, z, 0.2, zuplims=zuplims, zlolims=zlolims, errorevery=estep)\n\nax.set_xlabel(\"X label\")\nax.set_ylabel(\"Y label\")\nax.set_zlabel(\"Z label\")\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_225_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============================\nCreate 3D histogram of 2D data\n==============================\n\nDemo of a histogram for 2D data as a bar graph in 3D.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\nx, y = np.random.rand(2, 100) * 4\nhist, xedges, yedges = np.histogram2d(x, y, bins=4, range=[[0, 4], [0, 4]])\n\n# Construct arrays for the anchor positions of the 16 bars.\nxpos, ypos = np.meshgrid(xedges[:-1] + 0.25, yedges[:-1] + 0.25, indexing=\"ij\")\nxpos = xpos.ravel()\nypos = ypos.ravel()\nzpos = 0\n\n# Construct arrays with the dimensions for the 16 bars.\ndx = dy = 0.5 * np.ones_like(zpos)\ndz = hist.ravel()\n\nax.bar3d(xpos, ypos, zpos, dx, dy, dz, zsort='average')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_226_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nParametric curve\n================\n\nThis example demonstrates plotting a parametric curve in 3D.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Prepare arrays x, y, z\ntheta = np.linspace(-4 * np.pi, 4 * np.pi, 100)\nz = np.linspace(-2, 2, 100)\nr = z**2 + 1\nx = r * np.sin(theta)\ny = r * np.cos(theta)\n\nax.plot(x, y, z, label='parametric curve')\nax.legend()\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_227_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nLorenz attractor\n================\n\nThis is an example of plotting Edward Lorenz's 1963 `\"Deterministic Nonperiodic\nFlow\"`_ in a 3-dimensional space using mplot3d.\n\n.. _\"Deterministic Nonperiodic Flow\":\n   https://journals.ametsoc.org/view/journals/atsc/20/2/1520-0469_1963_020_0130_dnf_2_0_co_2.xml\n\n.. note::\n   Because this is a simple non-linear ODE, it would be more easily done using\n   SciPy's ODE solver, but this approach depends only upon NumPy.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef lorenz(xyz, *, s=10, r=28, b=2.667):\n    \"\"\"\n    Parameters\n    ----------\n    xyz : array-like, shape (3,)\n       Point of interest in three-dimensional space.\n    s, r, b : float\n       Parameters defining the Lorenz attractor.\n\n    Returns\n    -------\n    xyz_dot : array, shape (3,)\n       Values of the Lorenz attractor's partial derivatives at *xyz*.\n    \"\"\"\n    x, y, z = xyz\n    x_dot = s*(y - x)\n    y_dot = r*x - y - x*z\n    z_dot = x*y - b*z\n    return np.array([x_dot, y_dot, z_dot])\n\n\ndt = 0.01\nnum_steps = 10000\n\nxyzs = np.empty((num_steps + 1, 3))  # Need one more for the initial values\nxyzs[0] = (0., 1., 1.05)  # Set initial values\n# Step through \"time\", calculating the partial derivatives at the current point\n# and using them to estimate the next point\nfor i in range(num_steps):\n    xyzs[i + 1] = xyzs[i] + lorenz(xyzs[i]) * dt\n\n# Plot\nax = plt.figure().add_subplot(projection='3d')\n\nax.plot(*xyzs.T, lw=0.5)\nax.set_xlabel(\"X Axis\")\nax.set_ylabel(\"Y Axis\")\nax.set_zlabel(\"Z Axis\")\nax.set_title(\"Lorenz Attractor\")\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_228_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============================\n2D and 3D axes in same figure\n=============================\n\nThis example shows a how to plot a 2D and a 3D plot on the same figure.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef f(t):\n    return np.cos(2*np.pi*t) * np.exp(-t)\n\n\n# Set up a figure twice as tall as it is wide\nfig = plt.figure(figsize=plt.figaspect(2.))\nfig.suptitle('A tale of 2 subplots')\n\n# First subplot\nax = fig.add_subplot(2, 1, 1)\n\nt1 = np.arange(0.0, 5.0, 0.1)\nt2 = np.arange(0.0, 5.0, 0.02)\nt3 = np.arange(0.0, 2.0, 0.01)\n\nax.plot(t1, f(t1), 'bo',\n        t2, f(t2), 'k--', markerfacecolor='green')\nax.grid(True)\nax.set_ylabel('Damped oscillation')\n\n# Second subplot\nax = fig.add_subplot(2, 1, 2, projection='3d')\n\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\nsurf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1,\n                       linewidth=0, antialiased=False)\nax.set_zlim(-1, 1)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_229_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========================\nAutomatic text offsetting\n=========================\n\nThis example demonstrates mplot3d's offset text display.\nAs one rotates the 3D figure, the offsets should remain oriented the\nsame way as the axis label, and should also be located \"away\"\nfrom the center of the plot.\n\nThis demo triggers the display of the offset text for the x- and\ny-axis by adding 1e5 to X and Y. Anything less would not\nautomatically trigger it.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\nX, Y = np.mgrid[0:6*np.pi:0.25, 0:4*np.pi:0.25]\nZ = np.sqrt(np.abs(np.cos(X) + np.cos(Y)))\n\nax.plot_surface(X + 1e5, Y + 1e5, Z, cmap='autumn', cstride=2, rstride=2)\n\nax.set_xlabel(\"X label\")\nax.set_ylabel(\"Y label\")\nax.set_zlabel(\"Z label\")\nax.set_zlim(0, 2)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_230_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============================\nDraw flat objects in 3D plot\n============================\n\nDemonstrate using `.pathpatch_2d_to_3d` to 'draw' shapes and text on a 3D plot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Circle, PathPatch\nfrom matplotlib.text import TextPath\nfrom matplotlib.transforms import Affine2D\nimport mpl_toolkits.mplot3d.art3d as art3d\n\n\ndef text3d(ax, xyz, s, zdir=\"z\", size=None, angle=0, usetex=False, **kwargs):\n    \"\"\"\n    Plots the string *s* on the axes *ax*, with position *xyz*, size *size*,\n    and rotation angle *angle*. *zdir* gives the axis which is to be treated as\n    the third dimension. *usetex* is a boolean indicating whether the string\n    should be run through a LaTeX subprocess or not.  Any additional keyword\n    arguments are forwarded to `.transform_path`.\n\n    Note: zdir affects the interpretation of xyz.\n    \"\"\"\n    x, y, z = xyz\n    if zdir == \"y\":\n        xy1, z1 = (x, z), y\n    elif zdir == \"x\":\n        xy1, z1 = (y, z), x\n    else:\n        xy1, z1 = (x, y), z\n\n    text_path = TextPath((0, 0), s, size=size, usetex=usetex)\n    trans = Affine2D().rotate(angle).translate(xy1[0], xy1[1])\n\n    p1 = PathPatch(trans.transform_path(text_path), **kwargs)\n    ax.add_patch(p1)\n    art3d.pathpatch_2d_to_3d(p1, z=z1, zdir=zdir)\n\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Draw a circle on the x=0 'wall'\np = Circle((5, 5), 3)\nax.add_patch(p)\nart3d.pathpatch_2d_to_3d(p, z=0, zdir=\"x\")\n\n# Manually label the axes\ntext3d(ax, (4, -2, 0), \"X-axis\", zdir=\"z\", size=.5, usetex=False,\n       ec=\"none\", fc=\"k\")\ntext3d(ax, (12, 4, 0), \"Y-axis\", zdir=\"z\", size=.5, usetex=False,\n       angle=np.pi / 2, ec=\"none\", fc=\"k\")\ntext3d(ax, (12, 10, 4), \"Z-axis\", zdir=\"y\", size=.5, usetex=False,\n       angle=np.pi / 2, ec=\"none\", fc=\"k\")\n\n# Write a Latex formula on the z=0 'floor'\ntext3d(ax, (1, 5, 0),\n       r\"$\\displaystyle G_{\\mu\\nu} + \\Lambda g_{\\mu\\nu} = \"\n       r\"\\frac{8\\pi G}{c^4} T_{\\mu\\nu}  $\",\n       zdir=\"z\", size=1, usetex=True,\n       ec=\"none\", fc=\"k\")\n\nax.set_xlim(0, 10)\nax.set_ylim(0, 10)\nax.set_zlim(0, 10)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_231_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============================================\nGenerate polygons to fill under 3D line graph\n=============================================\n\nDemonstrate how to create polygons which fill the space under a line\ngraph. In this example polygons are semi-transparent, creating a sort\nof 'jagged stained glass' effect.\n\"\"\"\n\nimport math\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import PolyCollection\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef polygon_under_graph(x, y):\n    \"\"\"\n    Construct the vertex list which defines the polygon filling the space under\n    the (x, y) line graph. This assumes x is in ascending order.\n    \"\"\"\n    return [(x[0], 0.), *zip(x, y), (x[-1], 0.)]\n\n\nax = plt.figure().add_subplot(projection='3d')\n\nx = np.linspace(0., 10., 31)\nlambdas = range(1, 9)\n\n# verts[i] is a list of (x, y) pairs defining polygon i.\ngamma = np.vectorize(math.gamma)\nverts = [polygon_under_graph(x, l**x * np.exp(-l) / gamma(x + 1))\n         for l in lambdas]\nfacecolors = plt.colormaps['viridis_r'](np.linspace(0, 1, len(verts)))\n\npoly = PolyCollection(verts, facecolors=facecolors, alpha=.7)\nax.add_collection3d(poly, zs=lambdas, zdir='y')\n\nax.set(xlim=(0, 10), ylim=(1, 9), zlim=(0, 0.35),\n       xlabel='x', ylabel=r'$\\lambda$', zlabel='probability')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_232_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========================\n3D plot projection types\n========================\n\nDemonstrates the different camera projections for 3D plots, and the effects of\nchanging the focal length for a perspective projection. Note that Matplotlib\ncorrects for the 'zoom' effect of changing the focal length.\n\nThe default focal length of 1 corresponds to a Field of View (FOV) of 90 deg.\nAn increased focal length between 1 and infinity \"flattens\" the image, while a\ndecreased focal length between 1 and 0 exaggerates the perspective and gives\nthe image more apparent depth. In the limiting case, a focal length of\ninfinity corresponds to an orthographic projection after correction of the\nzoom effect.\n\nYou can calculate focal length from a FOV via the equation:\n\n.. math::\n\n    1 / \\\\tan (\\\\mathrm{FOV} / 2)\n\nOr vice versa:\n\n.. math::\n\n    \\\\mathrm{FOV} = 2 \\\\arctan (1 / \\\\mathrm{focal length})\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig, axs = plt.subplots(1, 3, subplot_kw={'projection': '3d'})\n\n# Get the test data\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot the data\nfor ax in axs:\n    ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\n# Set the orthographic projection.\naxs[0].set_proj_type('ortho')  # FOV = 0 deg\naxs[0].set_title(\"'ortho'\\nfocal_length = \u221e\", fontsize=10)\n\n# Set the perspective projections\naxs[1].set_proj_type('persp')  # FOV = 90 deg\naxs[1].set_title(\"'persp'\\nfocal_length = 1 (default)\", fontsize=10)\n\naxs[2].set_proj_type('persp', focal_length=0.2)  # FOV = 157.4 deg\naxs[2].set_title(\"'persp'\\nfocal_length = 0.2\", fontsize=10)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_233_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============\n3D quiver plot\n==============\n\nDemonstrates plotting directional arrows at points on a 3D meshgrid.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Make the grid\nx, y, z = np.meshgrid(np.arange(-0.8, 1, 0.2),\n                      np.arange(-0.8, 1, 0.2),\n                      np.arange(-0.8, 1, 0.8))\n\n# Make the direction data for the arrows\nu = np.sin(np.pi * x) * np.cos(np.pi * y) * np.cos(np.pi * z)\nv = -np.cos(np.pi * x) * np.sin(np.pi * y) * np.cos(np.pi * z)\nw = (np.sqrt(2.0 / 3.0) * np.cos(np.pi * x) * np.cos(np.pi * y) *\n     np.sin(np.pi * z))\n\nax.quiver(x, y, z, u, v, w, length=0.1, normalize=True)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_234_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============\n3D scatterplot\n==============\n\nDemonstration of a basic scatterplot in 3D.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef randrange(n, vmin, vmax):\n    \"\"\"\n    Helper function to make an array of random numbers having shape (n, )\n    with each number distributed Uniform(vmin, vmax).\n    \"\"\"\n    return (vmax - vmin)*np.random.rand(n) + vmin\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\nn = 100\n\n# For each set of style and range settings, plot n random points in the box\n# defined by x in [23, 32], y in [0, 100], z in [zlow, zhigh].\nfor m, zlow, zhigh in [('o', -50, -25), ('^', -30, -5)]:\n    xs = randrange(n, 23, 32)\n    ys = randrange(n, 0, 100)\n    zs = randrange(n, zlow, zhigh)\n    ax.scatter(xs, ys, zs, marker=m)\n\nax.set_xlabel('X Label')\nax.set_ylabel('Y Label')\nax.set_zlabel('Z Label')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_235_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======\n3D stem\n=======\n\nDemonstration of a stem plot in 3D, which plots vertical lines from a baseline\nto the *z*-coordinate and places a marker at the tip.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ntheta = np.linspace(0, 2*np.pi)\nx = np.cos(theta - np.pi/2)\ny = np.sin(theta - np.pi/2)\nz = theta\n\nfig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\nax.stem(x, y, z)\n\nplt.show()\n\n# %%\n#\n# The position of the baseline can be adapted using *bottom*. The parameters\n# *linefmt*, *markerfmt*, and *basefmt* control basic format properties of the\n# plot. However, in contrast to `~.axes3d.Axes3D.plot` not all properties are\n# configurable via keyword arguments. For more advanced control adapt the line\n# objects returned by `~mpl_toolkits.mplot3d.axes3d.Axes3D.stem`.\n\nfig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\nmarkerline, stemlines, baseline = ax.stem(\n    x, y, z, linefmt='grey', markerfmt='D', bottom=np.pi)\nmarkerline.set_markerfacecolor('none')\n\nplt.show()\n\n# %%\n#\n# The orientation of the stems and baseline can be changed using *orientation*.\n# This determines in which direction the stems are projected from the head\n# points, towards the *bottom* baseline.\n#\n# For examples, by setting ``orientation='x'``, the stems are projected along\n# the *x*-direction, and the baseline is in the *yz*-plane.\n\nfig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\nmarkerline, stemlines, baseline = ax.stem(x, y, z, bottom=-1, orientation='x')\nax.set(xlabel='x', ylabel='y', zlabel='z')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_236_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n====================\n3D plots as subplots\n====================\n\nDemonstrate including 3D plots as subplots.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d.axes3d import get_test_data\n\n# set up a figure twice as wide as it is tall\nfig = plt.figure(figsize=plt.figaspect(0.5))\n\n# =============\n# First subplot\n# =============\n# set up the axes for the first plot\nax = fig.add_subplot(1, 2, 1, projection='3d')\n\n# plot a 3D surface like in the example mplot3d/surface3d_demo\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\nsurf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.coolwarm,\n                       linewidth=0, antialiased=False)\nax.set_zlim(-1.01, 1.01)\nfig.colorbar(surf, shrink=0.5, aspect=10)\n\n# ==============\n# Second subplot\n# ==============\n# set up the axes for the second plot\nax = fig.add_subplot(1, 2, 2, projection='3d')\n\n# plot a 3D wireframe like in the example mplot3d/wire3d_demo\nX, Y, Z = get_test_data(0.05)\nax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_237_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=====================\n3D surface (colormap)\n=====================\n\nDemonstrates plotting a 3D surface colored with the coolwarm colormap.\nThe surface is made opaque by using ``antialiased=False``.\n\nAlso demonstrates using the `.LinearLocator` and custom formatting for the\nz axis tick labels.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\nfrom matplotlib.ticker import LinearLocator\n\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n\n# Make data.\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\n# Plot the surface.\nsurf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm,\n                       linewidth=0, antialiased=False)\n\n# Customize the z axis.\nax.set_zlim(-1.01, 1.01)\nax.zaxis.set_major_locator(LinearLocator(10))\n# A StrMethodFormatter is used automatically\nax.zaxis.set_major_formatter('{x:.02f}')\n\n# Add a color bar which maps values to colors.\nfig.colorbar(surf, shrink=0.5, aspect=5)\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.axis.Axis.set_major_formatter`\n#    - `matplotlib.axis.Axis.set_major_locator`\n#    - `matplotlib.ticker.LinearLocator`\n#    - `matplotlib.ticker.StrMethodFormatter`"
      },
      {
        "image_path": "gallery_assets/17mplot3d_238_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========================\n3D surface (solid color)\n========================\n\nDemonstrates a very basic plot of a 3D surface using a solid color.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Make data\nu = np.linspace(0, 2 * np.pi, 100)\nv = np.linspace(0, np.pi, 100)\nx = 10 * np.outer(np.cos(u), np.sin(v))\ny = 10 * np.outer(np.sin(u), np.sin(v))\nz = 10 * np.outer(np.ones(np.size(u)), np.cos(v))\n\n# Plot the surface\nax.plot_surface(x, y, z)\n\n# Set an equal aspect ratio\nax.set_aspect('equal')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_239_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========================\n3D surface (checkerboard)\n=========================\n\nDemonstrates plotting a 3D surface colored in a checkerboard pattern.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.ticker import LinearLocator\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Make data.\nX = np.arange(-5, 5, 0.25)\nxlen = len(X)\nY = np.arange(-5, 5, 0.25)\nylen = len(Y)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\n# Create an empty array of strings with the same shape as the meshgrid, and\n# populate it with two colors in a checkerboard pattern.\ncolortuple = ('y', 'b')\ncolors = np.empty(X.shape, dtype=str)\nfor y in range(ylen):\n    for x in range(xlen):\n        colors[y, x] = colortuple[(x + y) % len(colortuple)]\n\n# Plot the surface with face colors taken from the array we made.\nsurf = ax.plot_surface(X, Y, Z, facecolors=colors, linewidth=0)\n\n# Customize the z axis.\nax.set_zlim(-1, 1)\nax.zaxis.set_major_locator(LinearLocator(6))\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_240_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================================\n3D surface with polar coordinates\n=================================\n\nDemonstrates plotting a surface defined in polar coordinates.\nUses the reversed version of the YlGnBu colormap.\nAlso demonstrates writing axis labels with latex math mode.\n\nExample contributed by Armin Moser.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Create the mesh in polar coordinates and compute corresponding Z.\nr = np.linspace(0, 1.25, 50)\np = np.linspace(0, 2*np.pi, 50)\nR, P = np.meshgrid(r, p)\nZ = ((R**2 - 1)**2)\n\n# Express the mesh in the cartesian system.\nX, Y = R*np.cos(P), R*np.sin(P)\n\n# Plot the surface.\nax.plot_surface(X, Y, Z, cmap=plt.cm.YlGnBu_r)\n\n# Tweak the limits and add latex math labels.\nax.set_zlim(0, 1)\nax.set_xlabel(r'$\\phi_\\mathrm{real}$')\nax.set_ylabel(r'$\\phi_\\mathrm{im}$')\nax.set_zlabel(r'$V(\\phi)$')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_241_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n======================\nText annotations in 3D\n======================\n\nDemonstrates the placement of text annotations on a 3D plot.\n\nFunctionality shown:\n\n- Using the `~.Axes3D.text` function with three types of *zdir* values: None,\n  an axis name (ex. 'x'), or a direction tuple (ex. (1, 1, 0)).\n- Using the `~.Axes3D.text` function with the color keyword.\n- Using the `.text2D` function to place text on a fixed position on the ax\n  object.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Demo 1: zdir\nzdirs = (None, 'x', 'y', 'z', (1, 1, 0), (1, 1, 1))\nxs = (1, 4, 4, 9, 4, 1)\nys = (2, 5, 8, 10, 1, 2)\nzs = (10, 3, 8, 9, 1, 8)\n\nfor zdir, x, y, z in zip(zdirs, xs, ys, zs):\n    label = '(%d, %d, %d), dir=%s' % (x, y, z, zdir)\n    ax.text(x, y, z, label, zdir)\n\n# Demo 2: color\nax.text(9, 0, 0, \"red\", color='red')\n\n# Demo 3: text2D\n# Placement 0, 0 would be the bottom left, 1, 1 would be the top right.\nax.text2D(0.05, 0.95, \"2D Text\", transform=ax.transAxes)\n\n# Tweaking display region and labels\nax.set_xlim(0, 10)\nax.set_ylim(0, 10)\nax.set_zlim(0, 10)\nax.set_xlabel('X axis')\nax.set_ylabel('Y axis')\nax.set_zlabel('Z axis')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_242_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========================\nTriangular 3D contour plot\n==========================\n\nContour plots of unstructured triangular grids.\n\nThe data used is the same as in the second plot of :doc:`trisurf3d_2`.\n:doc:`tricontourf3d` shows the filled version of this example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\nn_angles = 48\nn_radii = 8\nmin_radius = 0.25\n\n# Create the mesh in polar coordinates and compute x, y, z.\nradii = np.linspace(min_radius, 0.95, n_radii)\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi/n_angles\n\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nz = (np.cos(radii)*np.cos(3*angles)).flatten()\n\n# Create a custom triangulation.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\nax = plt.figure().add_subplot(projection='3d')\nax.tricontour(triang, z, cmap=plt.cm.CMRmap)\n\n# Customize the view angle so it's easier to understand the plot.\nax.view_init(elev=45.)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_243_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================================\nTriangular 3D filled contour plot\n=================================\n\nFilled contour plots of unstructured triangular grids.\n\nThe data used is the same as in the second plot of :doc:`trisurf3d_2`.\n:doc:`tricontour3d` shows the unfilled version of this example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\n# First create the x, y, z coordinates of the points.\nn_angles = 48\nn_radii = 8\nmin_radius = 0.25\n\n# Create the mesh in polar coordinates and compute x, y, z.\nradii = np.linspace(min_radius, 0.95, n_radii)\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi/n_angles\n\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nz = (np.cos(radii)*np.cos(3*angles)).flatten()\n\n# Create a custom triangulation.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\nax = plt.figure().add_subplot(projection='3d')\nax.tricontourf(triang, z, cmap=plt.cm.CMRmap)\n\n# Customize the view angle so it's easier to understand the plot.\nax.view_init(elev=45.)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_244_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n======================\nTriangular 3D surfaces\n======================\n\nPlot a 3D surface with a triangular mesh.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nn_radii = 8\nn_angles = 36\n\n# Make radii and angles spaces (radius r=0 omitted to eliminate duplication).\nradii = np.linspace(0.125, 1.0, n_radii)\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)[..., np.newaxis]\n\n# Convert polar (radii, angles) coords to cartesian (x, y) coords.\n# (0, 0) is manually added at this stage,  so there will be no duplicate\n# points in the (x, y) plane.\nx = np.append(0, (radii*np.cos(angles)).flatten())\ny = np.append(0, (radii*np.sin(angles)).flatten())\n\n# Compute z to make the pringle surface.\nz = np.sin(-x*y)\n\nax = plt.figure().add_subplot(projection='3d')\n\nax.plot_trisurf(x, y, z, linewidth=0.2, antialiased=True)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_245_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========================\nMore triangular 3D surfaces\n===========================\n\nTwo additional examples of plotting surfaces with triangular mesh.\n\nThe first demonstrates use of plot_trisurf's triangles argument, and the\nsecond sets a `.Triangulation` object's mask and passes the object directly\nto plot_trisurf.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as mtri\n\nfig = plt.figure(figsize=plt.figaspect(0.5))\n\n# ==========\n# First plot\n# ==========\n\n# Make a mesh in the space of parameterisation variables u and v\nu = np.linspace(0, 2.0 * np.pi, endpoint=True, num=50)\nv = np.linspace(-0.5, 0.5, endpoint=True, num=10)\nu, v = np.meshgrid(u, v)\nu, v = u.flatten(), v.flatten()\n\n# This is the Mobius mapping, taking a u, v pair and returning an x, y, z\n# triple\nx = (1 + 0.5 * v * np.cos(u / 2.0)) * np.cos(u)\ny = (1 + 0.5 * v * np.cos(u / 2.0)) * np.sin(u)\nz = 0.5 * v * np.sin(u / 2.0)\n\n# Triangulate parameter space to determine the triangles\ntri = mtri.Triangulation(u, v)\n\n# Plot the surface.  The triangles in parameter space determine which x, y, z\n# points are connected by an edge.\nax = fig.add_subplot(1, 2, 1, projection='3d')\nax.plot_trisurf(x, y, z, triangles=tri.triangles, cmap=plt.cm.Spectral)\nax.set_zlim(-1, 1)\n\n\n# ===========\n# Second plot\n# ===========\n\n# Make parameter spaces radii and angles.\nn_angles = 36\nn_radii = 8\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi/n_angles\n\n# Map radius, angle pairs to x, y, z points.\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nz = (np.cos(radii)*np.cos(3*angles)).flatten()\n\n# Create the Triangulation; no triangles so Delaunay triangulation created.\ntriang = mtri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\nxmid = x[triang.triangles].mean(axis=1)\nymid = y[triang.triangles].mean(axis=1)\nmask = xmid**2 + ymid**2 < min_radius**2\ntriang.set_mask(mask)\n\n# Plot the surface.\nax = fig.add_subplot(1, 2, 2, projection='3d')\nax.plot_trisurf(triang, z, cmap=plt.cm.CMRmap)\n\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_246_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n======================\nPrimary 3D view planes\n======================\n\nThis example generates an \"unfolded\" 3D plot that shows each of the primary 3D\nview planes. The elevation, azimuth, and roll angles required for each view are\nlabeled. You could print out this image and fold it into a box where each plane\nforms a side of the box.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n\ndef annotate_axes(ax, text, fontsize=18):\n    ax.text(x=0.5, y=0.5, z=0.5, s=text,\n            va=\"center\", ha=\"center\", fontsize=fontsize, color=\"black\")\n\n# (plane, (elev, azim, roll))\nviews = [('XY',   (90, -90, 0)),\n         ('XZ',    (0, -90, 0)),\n         ('YZ',    (0,   0, 0)),\n         ('-XY', (-90,  90, 0)),\n         ('-XZ',   (0,  90, 0)),\n         ('-YZ',   (0, 180, 0))]\n\nlayout = [['XY',  '.',   'L',   '.'],\n          ['XZ', 'YZ', '-XZ', '-YZ'],\n          ['.',   '.', '-XY',   '.']]\nfig, axd = plt.subplot_mosaic(layout, subplot_kw={'projection': '3d'},\n                              figsize=(12, 8.5))\nfor plane, angles in views:\n    axd[plane].set_xlabel('x')\n    axd[plane].set_ylabel('y')\n    axd[plane].set_zlabel('z')\n    axd[plane].set_proj_type('ortho')\n    axd[plane].view_init(elev=angles[0], azim=angles[1], roll=angles[2])\n    axd[plane].set_box_aspect(None, zoom=1.25)\n\n    label = f'{plane}\\n{angles}'\n    annotate_axes(axd[plane], label, fontsize=14)\n\nfor plane in ('XY', '-XY'):\n    axd[plane].set_zticklabels([])\n    axd[plane].set_zlabel('')\nfor plane in ('XZ', '-XZ'):\n    axd[plane].set_yticklabels([])\n    axd[plane].set_ylabel('')\nfor plane in ('YZ', '-YZ'):\n    axd[plane].set_xticklabels([])\n    axd[plane].set_xlabel('')\n\nlabel = 'mplot3d primary view planes\\n' + 'ax.view_init(elev, azim, roll)'\nannotate_axes(axd['L'], label, fontsize=18)\naxd['L'].set_axis_off()\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_247_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========================\n3D voxel / volumetric plot\n==========================\n\nDemonstrates plotting 3D volumetric objects with `.Axes3D.voxels`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# prepare some coordinates\nx, y, z = np.indices((8, 8, 8))\n\n# draw cuboids in the top left and bottom right corners, and a link between\n# them\ncube1 = (x < 3) & (y < 3) & (z < 3)\ncube2 = (x >= 5) & (y >= 5) & (z >= 5)\nlink = abs(x - y) + abs(y - z) + abs(z - x) <= 2\n\n# combine the objects into a single boolean array\nvoxelarray = cube1 | cube2 | link\n\n# set the colors of each object\ncolors = np.empty(voxelarray.shape, dtype=object)\ncolors[link] = 'red'\ncolors[cube1] = 'blue'\ncolors[cube2] = 'green'\n\n# and plot everything\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(voxelarray, facecolors=colors, edgecolor='k')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_248_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============================\n3D voxel plot of the NumPy logo\n===============================\n\nDemonstrates using `.Axes3D.voxels` with uneven coordinates.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef explode(data):\n    size = np.array(data.shape)*2\n    data_e = np.zeros(size - 1, dtype=data.dtype)\n    data_e[::2, ::2, ::2] = data\n    return data_e\n\n# build up the numpy logo\nn_voxels = np.zeros((4, 3, 4), dtype=bool)\nn_voxels[0, 0, :] = True\nn_voxels[-1, 0, :] = True\nn_voxels[1, 0, 2] = True\nn_voxels[2, 0, 1] = True\nfacecolors = np.where(n_voxels, '#FFD65DC0', '#7A88CCC0')\nedgecolors = np.where(n_voxels, '#BFAB6E', '#7D84A6')\nfilled = np.ones(n_voxels.shape)\n\n# upscale the above voxel image, leaving gaps\nfilled_2 = explode(filled)\nfcolors_2 = explode(facecolors)\necolors_2 = explode(edgecolors)\n\n# Shrink the gaps\nx, y, z = np.indices(np.array(filled_2.shape) + 1).astype(float) // 2\nx[0::2, :, :] += 0.05\ny[:, 0::2, :] += 0.05\nz[:, :, 0::2] += 0.05\nx[1::2, :, :] += 0.95\ny[:, 1::2, :] += 0.95\nz[:, :, 1::2] += 0.95\n\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(x, y, z, filled_2, facecolors=fcolors_2, edgecolors=ecolors_2)\nax.set_aspect('equal')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_249_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========================================\n3D voxel / volumetric plot with RGB colors\n==========================================\n\nDemonstrates using `.Axes3D.voxels` to visualize parts of a color space.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef midpoints(x):\n    sl = ()\n    for _ in range(x.ndim):\n        x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) / 2.0\n        sl += np.index_exp[:]\n    return x\n\n# prepare some coordinates, and attach rgb values to each\nr, g, b = np.indices((17, 17, 17)) / 16.0\nrc = midpoints(r)\ngc = midpoints(g)\nbc = midpoints(b)\n\n# define a sphere about [0.5, 0.5, 0.5]\nsphere = (rc - 0.5)**2 + (gc - 0.5)**2 + (bc - 0.5)**2 < 0.5**2\n\n# combine the color components\ncolors = np.zeros(sphere.shape + (3,))\ncolors[..., 0] = rc\ncolors[..., 1] = gc\ncolors[..., 2] = bc\n\n# and plot everything\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(r, g, b, sphere,\n          facecolors=colors,\n          edgecolors=np.clip(2*colors - 0.5, 0, 1),  # brighter\n          linewidth=0.5)\nax.set(xlabel='r', ylabel='g', zlabel='b')\nax.set_aspect('equal')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_250_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======================================================\n3D voxel / volumetric plot with cylindrical coordinates\n=======================================================\n\nDemonstrates using the *x*, *y*, *z* parameters of `.Axes3D.voxels`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors\n\n\ndef midpoints(x):\n    sl = ()\n    for i in range(x.ndim):\n        x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) / 2.0\n        sl += np.index_exp[:]\n    return x\n\n# prepare some coordinates, and attach rgb values to each\nr, theta, z = np.mgrid[0:1:11j, 0:np.pi*2:25j, -0.5:0.5:11j]\nx = r*np.cos(theta)\ny = r*np.sin(theta)\n\nrc, thetac, zc = midpoints(r), midpoints(theta), midpoints(z)\n\n# define a wobbly torus about [0.7, *, 0]\nsphere = (rc - 0.7)**2 + (zc + 0.2*np.cos(thetac*2))**2 < 0.2**2\n\n# combine the color components\nhsv = np.zeros(sphere.shape + (3,))\nhsv[..., 0] = thetac / (np.pi*2)\nhsv[..., 1] = rc\nhsv[..., 2] = zc + 0.5\ncolors = matplotlib.colors.hsv_to_rgb(hsv)\n\n# and plot everything\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(x, y, z, sphere,\n          facecolors=colors,\n          edgecolors=np.clip(2*colors - 0.5, 0, 1),  # brighter\n          linewidth=0.5)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_251_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================\n3D wireframe plot\n=================\n\nA very basic demonstration of a wireframe plot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Grab some test data.\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot a basic wireframe.\nax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/17mplot3d_252_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========================\nAnimate a 3D wireframe plot\n===========================\n\nA very simple \"animation\" of a 3D plot.  See also :doc:`rotate_axes3d_sgskip`.\n\n(This example is skipped when building the documentation gallery because it\nintentionally takes a long time to run.)\n\"\"\"\n\nimport time\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Make the X, Y meshgrid.\nxs = np.linspace(-1, 1, 50)\nys = np.linspace(-1, 1, 50)\nX, Y = np.meshgrid(xs, ys)\n\n# Set the z axis limits, so they aren't recalculated each frame.\nax.set_zlim(-1, 1)\n\n# Begin plotting.\nwframe = None\ntstart = time.time()\nfor phi in np.linspace(0, 180. / np.pi, 100):\n    # If a line collection is already remove it before drawing.\n    if wframe:\n        wframe.remove()\n    # Generate data.\n    Z = np.cos(2 * np.pi * X + phi) * (1 - np.hypot(X, Y))\n    # Plot the new wireframe and pause briefly before continuing.\n    wframe = ax.plot_wireframe(X, Y, Z, rstride=2, cstride=2)\n    plt.pause(.001)\n\nprint('Average FPS: %f' % (100 / (time.time() - tstart)))"
      },
      {
        "image_path": "gallery_assets/17mplot3d_253_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===================================\n3D wireframe plots in one direction\n===================================\n\nDemonstrates that setting *rstride* or *cstride* to 0 causes wires to not be\ngenerated in the corresponding direction.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig, (ax1, ax2) = plt.subplots(\n    2, 1, figsize=(8, 12), subplot_kw={'projection': '3d'})\n\n# Get the test data\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Give the first plot only wireframes of the type y = c\nax1.plot_wireframe(X, Y, Z, rstride=10, cstride=0)\nax1.set_title(\"Column (x) stride set to 0\")\n\n# Give the second plot only wireframes of the type x = c\nax2.plot_wireframe(X, Y, Z, rstride=0, cstride=10)\nax2.set_title(\"Row (y) stride set to 0\")\n\nplt.tight_layout()\nplt.show()"
      }
    ],
    "18scales": [
      {
        "image_path": "gallery_assets/18scales_254_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============\nAsinh Demo\n============\n\nIllustration of the `asinh <.scale.AsinhScale>` axis scaling,\nwhich uses the transformation\n\n.. math::\n\n    a \\\\rightarrow a_0 \\\\sinh^{-1} (a / a_0)\n\nFor coordinate values close to zero (i.e. much smaller than\nthe \"linear width\" :math:`a_0`), this leaves values essentially unchanged:\n\n.. math::\n\n    a \\\\rightarrow a + \\\\mathcal{O}(a^3)\n\nbut for larger values (i.e. :math:`|a| \\\\gg a_0`, this is asymptotically\n\n.. math::\n\n    a \\\\rightarrow a_0 \\\\, \\\\mathrm{sgn}(a) \\\\ln |a| + \\\\mathcal{O}(1)\n\nAs with the `symlog <.scale.SymmetricalLogScale>` scaling,\nthis allows one to plot quantities\nthat cover a very wide dynamic range that includes both positive\nand negative values. However, ``symlog`` involves a transformation\nthat has discontinuities in its gradient because it is built\nfrom *separate* linear and logarithmic transformations.\nThe ``asinh`` scaling uses a transformation that is smooth\nfor all (finite) values, which is both mathematically cleaner\nand reduces visual artifacts associated with an abrupt\ntransition between linear and logarithmic regions of the plot.\n\n.. note::\n   `.scale.AsinhScale` is experimental, and the API may change.\n\nSee `~.scale.AsinhScale`, `~.scale.SymmetricalLogScale`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Prepare sample values for variations on y=x graph:\nx = np.linspace(-3, 6, 500)\n\n# %%\n# Compare \"symlog\" and \"asinh\" behaviour on sample y=x graph,\n# where there is a discontinuous gradient in \"symlog\" near y=2:\nfig1 = plt.figure()\nax0, ax1 = fig1.subplots(1, 2, sharex=True)\n\nax0.plot(x, x)\nax0.set_yscale('symlog')\nax0.grid()\nax0.set_title('symlog')\n\nax1.plot(x, x)\nax1.set_yscale('asinh')\nax1.grid()\nax1.set_title('asinh')\n\n\n# %%\n# Compare \"asinh\" graphs with different scale parameter \"linear_width\":\nfig2 = plt.figure(layout='constrained')\naxs = fig2.subplots(1, 3, sharex=True)\nfor ax, (a0, base) in zip(axs, ((0.2, 2), (1.0, 0), (5.0, 10))):\n    ax.set_title(f'linear_width={a0:.3g}')\n    ax.plot(x, x, label='y=x')\n    ax.plot(x, 10*x, label='y=10x')\n    ax.plot(x, 100*x, label='y=100x')\n    ax.set_yscale('asinh', linear_width=a0, base=base)\n    ax.grid()\n    ax.legend(loc='best', fontsize='small')\n\n\n# %%\n# Compare \"symlog\" and \"asinh\" scalings\n# on 2D Cauchy-distributed random numbers,\n# where one may be able to see more subtle artifacts near y=2\n# due to the gradient-discontinuity in \"symlog\":\nfig3 = plt.figure()\nax = fig3.subplots(1, 1)\nr = 3 * np.tan(np.random.uniform(-np.pi / 2.02, np.pi / 2.02,\n                                 size=(5000,)))\nth = np.random.uniform(0, 2*np.pi, size=r.shape)\n\nax.scatter(r * np.cos(th), r * np.sin(th), s=4, alpha=0.5)\nax.set_xscale('asinh')\nax.set_yscale('symlog')\nax.set_xlabel('asinh')\nax.set_ylabel('symlog')\nax.set_title('2D Cauchy random deviates')\nax.set_xlim(-50, 50)\nax.set_ylim(-50, 50)\nax.grid()\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    - `matplotlib.scale.AsinhScale`\n#    - `matplotlib.ticker.AsinhLocator`\n#    - `matplotlib.scale.SymmetricalLogScale`"
      },
      {
        "image_path": "gallery_assets/18scales_255_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============\nLoglog Aspect\n=============\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nax1.set_xscale(\"log\")\nax1.set_yscale(\"log\")\nax1.set_xlim(1e1, 1e3)\nax1.set_ylim(1e2, 1e3)\nax1.set_aspect(1)\nax1.set_title(\"adjustable = box\")\n\nax2.set_xscale(\"log\")\nax2.set_yscale(\"log\")\nax2.set_adjustable(\"datalim\")\nax2.plot([1, 3, 10], [1, 9, 100], \"o-\")\nax2.set_xlim(1e-1, 1e2)\nax2.set_ylim(1e-1, 1e3)\nax2.set_aspect(1)\nax2.set_title(\"adjustable = datalim\")\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/18scales_256_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======\nLog Bar\n=======\n\nPlotting a bar chart with a logarithmic y-axis.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndata = ((3, 1000), (10, 3), (100, 30), (500, 800), (50, 1))\n\ndim = len(data[0])\nw = 0.75\ndimw = w / dim\n\nfig, ax = plt.subplots()\nx = np.arange(len(data))\nfor i in range(len(data[0])):\n    y = [d[i] for d in data]\n    b = ax.bar(x + i * dimw, y, dimw, bottom=0.001)\n\nax.set_xticks(x + dimw / 2, labels=map(str, x))\nax.set_yscale('log')\n\nax.set_xlabel('x')\nax.set_ylabel('y')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/18scales_257_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========\nLog Demo\n========\n\nExamples of plots with logarithmic axes.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Data for plotting\nt = np.arange(0.01, 20.0, 0.01)\n\n# Create figure\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\n\n# log y axis\nax1.semilogy(t, np.exp(-t / 5.0))\nax1.set(title='semilogy')\nax1.grid()\n\n# log x axis\nax2.semilogx(t, np.sin(2 * np.pi * t))\nax2.set(title='semilogx')\nax2.grid()\n\n# log x and y axis\nax3.loglog(t, 20 * np.exp(-t / 10.0))\nax3.set_xscale('log', base=2)\nax3.set(title='loglog base 2 on x')\nax3.grid()\n\n# With errorbars: clip non-positive values\n# Use new data for plotting\nx = 10.0**np.linspace(0.0, 2.0, 20)\ny = x**2.0\n\nax4.set_xscale(\"log\", nonpositive='clip')\nax4.set_yscale(\"log\", nonpositive='clip')\nax4.set(title='Errorbars go negative')\nax4.errorbar(x, y, xerr=0.1 * x, yerr=5.0 + 0.75 * y)\n# ylim must be set after errorbar to allow errorbar to autoscale limits\nax4.set_ylim(bottom=0.1)\n\nfig.tight_layout()\nplt.show()"
      },
      {
        "image_path": "gallery_assets/18scales_258_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nLogit Demo\n================\n\nExamples of plots with logit axes.\n\"\"\"\n\nimport math\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nxmax = 10\nx = np.linspace(-xmax, xmax, 10000)\ncdf_norm = [math.erf(w / np.sqrt(2)) / 2 + 1 / 2 for w in x]\ncdf_laplacian = np.where(x < 0, 1 / 2 * np.exp(x), 1 - 1 / 2 * np.exp(-x))\ncdf_cauchy = np.arctan(x) / np.pi + 1 / 2\n\nfig, axs = plt.subplots(nrows=3, ncols=2, figsize=(6.4, 8.5))\n\n# Common part, for the example, we will do the same plots on all graphs\nfor i in range(3):\n    for j in range(2):\n        axs[i, j].plot(x, cdf_norm, label=r\"$\\mathcal{N}$\")\n        axs[i, j].plot(x, cdf_laplacian, label=r\"$\\mathcal{L}$\")\n        axs[i, j].plot(x, cdf_cauchy, label=\"Cauchy\")\n        axs[i, j].legend()\n        axs[i, j].grid()\n\n# First line, logitscale, with standard notation\naxs[0, 0].set(title=\"logit scale\")\naxs[0, 0].set_yscale(\"logit\")\naxs[0, 0].set_ylim(1e-5, 1 - 1e-5)\n\naxs[0, 1].set(title=\"logit scale\")\naxs[0, 1].set_yscale(\"logit\")\naxs[0, 1].set_xlim(0, xmax)\naxs[0, 1].set_ylim(0.8, 1 - 5e-3)\n\n# Second line, logitscale, with survival notation (with `use_overline`), and\n# other format display 1/2\naxs[1, 0].set(title=\"logit scale\")\naxs[1, 0].set_yscale(\"logit\", one_half=\"1/2\", use_overline=True)\naxs[1, 0].set_ylim(1e-5, 1 - 1e-5)\n\naxs[1, 1].set(title=\"logit scale\")\naxs[1, 1].set_yscale(\"logit\", one_half=\"1/2\", use_overline=True)\naxs[1, 1].set_xlim(0, xmax)\naxs[1, 1].set_ylim(0.8, 1 - 5e-3)\n\n# Third line, linear scale\naxs[2, 0].set(title=\"linear scale\")\naxs[2, 0].set_ylim(0, 1)\n\naxs[2, 1].set(title=\"linear scale\")\naxs[2, 1].set_xlim(0, xmax)\naxs[2, 1].set_ylim(0.8, 1)\n\nfig.tight_layout()\nplt.show()"
      },
      {
        "image_path": "gallery_assets/18scales_259_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========================\nExploring normalizations\n========================\n\nVarious normalization on a multivariate normal distribution.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy.random import multivariate_normal\n\nimport matplotlib.colors as mcolors\n\n# Fixing random state for reproducibility.\nnp.random.seed(19680801)\n\ndata = np.vstack([\n    multivariate_normal([10, 10], [[3, 2], [2, 3]], size=100000),\n    multivariate_normal([30, 20], [[3, 1], [1, 3]], size=1000)\n])\n\ngammas = [0.8, 0.5, 0.3]\n\nfig, axs = plt.subplots(nrows=2, ncols=2)\n\naxs[0, 0].set_title('Linear normalization')\naxs[0, 0].hist2d(data[:, 0], data[:, 1], bins=100)\n\nfor ax, gamma in zip(axs.flat[1:], gammas):\n    ax.set_title(r'Power law $(\\gamma=%1.1f)$' % gamma)\n    ax.hist2d(data[:, 0], data[:, 1], bins=100, norm=mcolors.PowerNorm(gamma))\n\nfig.tight_layout()\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.colors`\n#    - `matplotlib.colors.PowerNorm`\n#    - `matplotlib.axes.Axes.hist2d`\n#    - `matplotlib.pyplot.hist2d`"
      },
      {
        "image_path": "gallery_assets/18scales_260_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n======\nScales\n======\n\nIllustrate the scale transformations applied to axes, e.g. log, symlog, logit.\n\nThe last two examples are examples of using the ``'function'`` scale by\nsupplying forward and inverse functions for the scale transformation.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.ticker import FixedLocator, NullFormatter\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# make up some data in the interval ]0, 1[\ny = np.random.normal(loc=0.5, scale=0.4, size=1000)\ny = y[(y > 0) & (y < 1)]\ny.sort()\nx = np.arange(len(y))\n\n# plot with various axes scales\nfig, axs = plt.subplots(3, 2, figsize=(6, 8), layout='constrained')\n\n# linear\nax = axs[0, 0]\nax.plot(x, y)\nax.set_yscale('linear')\nax.set_title('linear')\nax.grid(True)\n\n\n# log\nax = axs[0, 1]\nax.plot(x, y)\nax.set_yscale('log')\nax.set_title('log')\nax.grid(True)\n\n\n# symmetric log\nax = axs[1, 1]\nax.plot(x, y - y.mean())\nax.set_yscale('symlog', linthresh=0.02)\nax.set_title('symlog')\nax.grid(True)\n\n# logit\nax = axs[1, 0]\nax.plot(x, y)\nax.set_yscale('logit')\nax.set_title('logit')\nax.grid(True)\n\n\n# Function x**(1/2)\ndef forward(x):\n    return x**(1/2)\n\n\ndef inverse(x):\n    return x**2\n\n\nax = axs[2, 0]\nax.plot(x, y)\nax.set_yscale('function', functions=(forward, inverse))\nax.set_title('function: $x^{1/2}$')\nax.grid(True)\nax.yaxis.set_major_locator(FixedLocator(np.arange(0, 1, 0.2)**2))\nax.yaxis.set_major_locator(FixedLocator(np.arange(0, 1, 0.2)))\n\n\n# Function Mercator transform\ndef forward(a):\n    a = np.deg2rad(a)\n    return np.rad2deg(np.log(np.abs(np.tan(a) + 1.0 / np.cos(a))))\n\n\ndef inverse(a):\n    a = np.deg2rad(a)\n    return np.rad2deg(np.arctan(np.sinh(a)))\n\nax = axs[2, 1]\n\nt = np.arange(0, 170.0, 0.1)\ns = t / 2.\n\nax.plot(t, s, '-', lw=2)\n\nax.set_yscale('function', functions=(forward, inverse))\nax.set_title('function: Mercator')\nax.grid(True)\nax.set_xlim([0, 180])\nax.yaxis.set_minor_formatter(NullFormatter())\nax.yaxis.set_major_locator(FixedLocator(np.arange(0, 90, 10)))\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.set_xscale`\n#    - `matplotlib.axes.Axes.set_yscale`\n#    - `matplotlib.axis.Axis.set_major_locator`\n#    - `matplotlib.scale.LinearScale`\n#    - `matplotlib.scale.LogScale`\n#    - `matplotlib.scale.SymmetricalLogScale`\n#    - `matplotlib.scale.LogitScale`\n#    - `matplotlib.scale.FuncScale`"
      },
      {
        "image_path": "gallery_assets/18scales_261_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n========\nLog Axis\n========\n\n.. redirect-from:: /gallery/scales/log_test\n\nThis is an example of assigning a log-scale for the x-axis using\n`~.axes.Axes.semilogx`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots()\n\ndt = 0.01\nt = np.arange(dt, 20.0, dt)\n\nax.semilogx(t, np.exp(-t / 5.0))\nax.grid()\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/18scales_262_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========\nSymlog Demo\n===========\n\nExample use of symlog (symmetric log) axis scaling.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndt = 0.01\nx = np.arange(-50.0, 50.0, dt)\ny = np.arange(0, 100.0, dt)\n\nfig, (ax0, ax1, ax2) = plt.subplots(nrows=3)\n\nax0.plot(x, y)\nax0.set_xscale('symlog')\nax0.set_ylabel('symlogx')\nax0.grid()\nax0.xaxis.grid(which='minor')  # minor grid on too\n\nax1.plot(y, x)\nax1.set_yscale('symlog')\nax1.set_ylabel('symlogy')\n\nax2.plot(x, np.sin(x / 3.0))\nax2.set_xscale('symlog')\nax2.set_yscale('symlog', linthresh=0.015)\nax2.grid()\nax2.set_ylabel('symlog both')\n\nfig.tight_layout()\nplt.show()\n\n# %%\n# It should be noted that the coordinate transform used by ``symlog``\n# has a discontinuous gradient at the transition between its linear\n# and logarithmic regions. The ``asinh`` axis scale is an alternative\n# technique that may avoid visual artifacts caused by these discontinuities.\n\n# %%\n#\n# .. admonition:: References\n#\n#    - `matplotlib.scale.SymmetricalLogScale`\n#    - `matplotlib.ticker.SymmetricalLogLocator`\n#    - `matplotlib.scale.AsinhScale`"
      }
    ],
    "19specialty_plots": [
      {
        "image_path": "gallery_assets/19specialty_plots_263_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========\nHillshading\n===========\n\nDemonstrates a few common tricks with shaded plots.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import LightSource, Normalize\n\n\ndef display_colorbar():\n    \"\"\"Display a correct numeric colorbar for a shaded plot.\"\"\"\n    y, x = np.mgrid[-4:2:200j, -4:2:200j]\n    z = 10 * np.cos(x**2 + y**2)\n\n    cmap = plt.cm.copper\n    ls = LightSource(315, 45)\n    rgb = ls.shade(z, cmap)\n\n    fig, ax = plt.subplots()\n    ax.imshow(rgb, interpolation='bilinear')\n\n    # Use a proxy artist for the colorbar...\n    im = ax.imshow(z, cmap=cmap)\n    im.remove()\n    fig.colorbar(im, ax=ax)\n\n    ax.set_title('Using a colorbar with a shaded plot', size='x-large')\n\n\ndef avoid_outliers():\n    \"\"\"Use a custom norm to control the displayed z-range of a shaded plot.\"\"\"\n    y, x = np.mgrid[-4:2:200j, -4:2:200j]\n    z = 10 * np.cos(x**2 + y**2)\n\n    # Add some outliers...\n    z[100, 105] = 2000\n    z[120, 110] = -9000\n\n    ls = LightSource(315, 45)\n    fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(8, 4.5))\n\n    rgb = ls.shade(z, plt.cm.copper)\n    ax1.imshow(rgb, interpolation='bilinear')\n    ax1.set_title('Full range of data')\n\n    rgb = ls.shade(z, plt.cm.copper, vmin=-10, vmax=10)\n    ax2.imshow(rgb, interpolation='bilinear')\n    ax2.set_title('Manually set range')\n\n    fig.suptitle('Avoiding Outliers in Shaded Plots', size='x-large')\n\n\ndef shade_other_data():\n    \"\"\"Demonstrates displaying different variables through shade and color.\"\"\"\n    y, x = np.mgrid[-4:2:200j, -4:2:200j]\n    z1 = np.sin(x**2)  # Data to hillshade\n    z2 = np.cos(x**2 + y**2)  # Data to color\n\n    norm = Normalize(z2.min(), z2.max())\n    cmap = plt.cm.RdBu\n\n    ls = LightSource(315, 45)\n    rgb = ls.shade_rgb(cmap(norm(z2)), z1)\n\n    fig, ax = plt.subplots()\n    ax.imshow(rgb, interpolation='bilinear')\n    ax.set_title('Shade by one variable, color by another', size='x-large')\n\ndisplay_colorbar()\navoid_outliers()\nshade_other_data()\nplt.show()"
      },
      {
        "image_path": "gallery_assets/19specialty_plots_264_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================\nAnscombe's quartet\n==================\n\n`Anscombe's quartet`_ is a group of datasets (x, y) that have the same mean,\nstandard deviation, and regression line, but which are qualitatively different.\n\nIt is often used to illustrate the importance of looking at a set of data\ngraphically and not only relying on basic statistic properties.\n\n.. _Anscombe's quartet: https://en.wikipedia.org/wiki/Anscombe%27s_quartet\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5]\ny1 = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68]\ny2 = [9.14, 8.14, 8.74, 8.77, 9.26, 8.10, 6.13, 3.10, 9.13, 7.26, 4.74]\ny3 = [7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73]\nx4 = [8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8]\ny4 = [6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.50, 5.56, 7.91, 6.89]\n\ndatasets = {\n    'I': (x, y1),\n    'II': (x, y2),\n    'III': (x, y3),\n    'IV': (x4, y4)\n}\n\nfig, axs = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 6),\n                        gridspec_kw={'wspace': 0.08, 'hspace': 0.08})\naxs[0, 0].set(xlim=(0, 20), ylim=(2, 14))\naxs[0, 0].set(xticks=(0, 10, 20), yticks=(4, 8, 12))\n\nfor ax, (label, (x, y)) in zip(axs.flat, datasets.items()):\n    ax.text(0.1, 0.9, label, fontsize=20, transform=ax.transAxes, va='top')\n    ax.tick_params(direction='in', top=True, right=True)\n    ax.plot(x, y, 'o')\n\n    # linear regression\n    p1, p0 = np.polyfit(x, y, deg=1)  # slope, intercept\n    ax.axline(xy1=(0, p0), slope=p1, color='r', lw=2)\n\n    # add text box for the statistics\n    stats = (f'$\\\\mu$ = {np.mean(y):.2f}\\n'\n             f'$\\\\sigma$ = {np.std(y):.2f}\\n'\n             f'$r$ = {np.corrcoef(x, y)[0][1]:.2f}')\n    bbox = dict(boxstyle='round', fc='blanchedalmond', ec='orange', alpha=0.5)\n    ax.text(0.95, 0.07, stats, fontsize=9, bbox=bbox,\n            transform=ax.transAxes, horizontalalignment='right')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.axline` / `matplotlib.pyplot.axline`\n#    - `matplotlib.axes.Axes.text` / `matplotlib.pyplot.text`\n#    - `matplotlib.axes.Axes.tick_params` / matplotlib.pyplot.tick_params`"
      },
      {
        "image_path": "gallery_assets/19specialty_plots_265_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======================\nLeft ventricle bullseye\n=======================\n\nThis example demonstrates how to create the 17 segment model for the left\nventricle recommended by the American Heart Association (AHA).\n\n.. redirect-from:: /gallery/specialty_plots/leftventricle_bulleye\n\nSee also the :doc:`/gallery/pie_and_polar_charts/nested_pie` example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\n\n\ndef bullseye_plot(ax, data, seg_bold=None, cmap=\"viridis\", norm=None):\n    \"\"\"\n    Bullseye representation for the left ventricle.\n\n    Parameters\n    ----------\n    ax : axes\n    data : list[float]\n        The intensity values for each of the 17 segments.\n    seg_bold : list[int], optional\n        A list with the segments to highlight.\n    cmap : colormap, default: \"viridis\"\n        Colormap for the data.\n    norm : Normalize or None, optional\n        Normalizer for the data.\n\n    Notes\n    -----\n    This function creates the 17 segment model for the left ventricle according\n    to the American Heart Association (AHA) [1]_\n\n    References\n    ----------\n    .. [1] M. D. Cerqueira, N. J. Weissman, V. Dilsizian, A. K. Jacobs,\n        S. Kaul, W. K. Laskey, D. J. Pennell, J. A. Rumberger, T. Ryan,\n        and M. S. Verani, \"Standardized myocardial segmentation and\n        nomenclature for tomographic imaging of the heart\",\n        Circulation, vol. 105, no. 4, pp. 539-542, 2002.\n    \"\"\"\n\n    data = np.ravel(data)\n    if seg_bold is None:\n        seg_bold = []\n    if norm is None:\n        norm = mpl.colors.Normalize(vmin=data.min(), vmax=data.max())\n\n    r = np.linspace(0.2, 1, 4)\n\n    ax.set(ylim=[0, 1], xticklabels=[], yticklabels=[])\n    ax.grid(False)  # Remove grid\n\n    # Fill segments 1-6, 7-12, 13-16.\n    for start, stop, r_in, r_out in [\n            (0, 6, r[2], r[3]),\n            (6, 12, r[1], r[2]),\n            (12, 16, r[0], r[1]),\n            (16, 17, 0, r[0]),\n    ]:\n        n = stop - start\n        dtheta = 2*np.pi / n\n        ax.bar(np.arange(n) * dtheta + np.pi/2, r_out - r_in, dtheta, r_in,\n               color=cmap(norm(data[start:stop])))\n\n    # Now, draw the segment borders.  In order for the outer bold borders not\n    # to be covered by inner segments, the borders are all drawn separately\n    # after the segments have all been filled.  We also disable clipping, which\n    # would otherwise affect the outermost segment edges.\n    # Draw edges of segments 1-6, 7-12, 13-16.\n    for start, stop, r_in, r_out in [\n            (0, 6, r[2], r[3]),\n            (6, 12, r[1], r[2]),\n            (12, 16, r[0], r[1]),\n    ]:\n        n = stop - start\n        dtheta = 2*np.pi / n\n        ax.bar(np.arange(n) * dtheta + np.pi/2, r_out - r_in, dtheta, r_in,\n               clip_on=False, color=\"none\", edgecolor=\"k\", linewidth=[\n                   4 if i + 1 in seg_bold else 2 for i in range(start, stop)])\n    # Draw edge of segment 17 -- here; the edge needs to be drawn differently,\n    # using plot().\n    ax.plot(np.linspace(0, 2*np.pi), np.linspace(r[0], r[0]), \"k\",\n            linewidth=(4 if 17 in seg_bold else 2))\n\n\n# Create the fake data\ndata = np.arange(17) + 1\n\n\n# Make a figure and axes with dimensions as desired.\nfig = plt.figure(figsize=(10, 5), layout=\"constrained\")\nfig.get_layout_engine().set(wspace=.1, w_pad=.2)\naxs = fig.subplots(1, 3, subplot_kw=dict(projection='polar'))\nfig.canvas.manager.set_window_title('Left Ventricle Bulls Eyes (AHA)')\n\n\n# Set the colormap and norm to correspond to the data for which\n# the colorbar will be used.\ncmap = mpl.cm.viridis\nnorm = mpl.colors.Normalize(vmin=1, vmax=17)\n# Create an empty ScalarMappable to set the colorbar's colormap and norm.\n# The following gives a basic continuous colorbar with ticks and labels.\nfig.colorbar(mpl.cm.ScalarMappable(cmap=cmap, norm=norm),\n             cax=axs[0].inset_axes([0, -.15, 1, .1]),\n             orientation='horizontal', label='Some units')\n\n\n# And again for the second colorbar.\ncmap2 = mpl.cm.cool\nnorm2 = mpl.colors.Normalize(vmin=1, vmax=17)\nfig.colorbar(mpl.cm.ScalarMappable(cmap=cmap2, norm=norm2),\n             cax=axs[1].inset_axes([0, -.15, 1, .1]),\n             orientation='horizontal', label='Some other units')\n\n\n# The second example illustrates the use of a ListedColormap, a\n# BoundaryNorm, and extended ends to show the \"over\" and \"under\"\n# value colors.\ncmap3 = (mpl.colors.ListedColormap(['r', 'g', 'b', 'c'])\n         .with_extremes(over='0.35', under='0.75'))\n# If a ListedColormap is used, the length of the bounds array must be\n# one greater than the length of the color list.  The bounds must be\n# monotonically increasing.\nbounds = [2, 3, 7, 9, 15]\nnorm3 = mpl.colors.BoundaryNorm(bounds, cmap3.N)\nfig.colorbar(mpl.cm.ScalarMappable(cmap=cmap3, norm=norm3),\n             cax=axs[2].inset_axes([0, -.15, 1, .1]),\n             extend='both',\n             ticks=bounds,  # optional\n             spacing='proportional',\n             orientation='horizontal',\n             label='Discrete intervals, some other units')\n\n\n# Create the 17 segment model\nbullseye_plot(axs[0], data, cmap=cmap, norm=norm)\naxs[0].set_title('Bulls Eye (AHA)')\n\nbullseye_plot(axs[1], data, cmap=cmap2, norm=norm2)\naxs[1].set_title('Bulls Eye (AHA)')\n\nbullseye_plot(axs[2], data, seg_bold=[3, 5, 6, 11, 12, 16],\n              cmap=cmap3, norm=norm3)\naxs[2].set_title('Segments [3, 5, 6, 11, 12, 16] in bold')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/19specialty_plots_266_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================\nThe Sankey class\n================\n\nDemonstrate the Sankey class by producing three basic diagrams.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.sankey import Sankey\n\n# %%\n# Example 1 -- Mostly defaults\n#\n# This demonstrates how to create a simple diagram by implicitly calling the\n# Sankey.add() method and by appending finish() to the call to the class.\n\nSankey(flows=[0.25, 0.15, 0.60, -0.20, -0.15, -0.05, -0.50, -0.10],\n       labels=['', '', '', 'First', 'Second', 'Third', 'Fourth', 'Fifth'],\n       orientations=[-1, 1, 0, 1, 1, 1, 0, -1]).finish()\nplt.title(\"The default settings produce a diagram like this.\")\n\n# %%\n# Notice:\n#\n# 1. Axes weren't provided when Sankey() was instantiated, so they were\n#    created automatically.\n# 2. The scale argument wasn't necessary since the data was already\n#    normalized.\n# 3. By default, the lengths of the paths are justified.\n\n\n# %%\n# Example 2\n#\n# This demonstrates:\n#\n# 1. Setting one path longer than the others\n# 2. Placing a label in the middle of the diagram\n# 3. Using the scale argument to normalize the flows\n# 4. Implicitly passing keyword arguments to PathPatch()\n# 5. Changing the angle of the arrow heads\n# 6. Changing the offset between the tips of the paths and their labels\n# 7. Formatting the numbers in the path labels and the associated unit\n# 8. Changing the appearance of the patch and the labels after the figure is\n#    created\n\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[],\n                     title=\"Flow Diagram of a Widget\")\nsankey = Sankey(ax=ax, scale=0.01, offset=0.2, head_angle=180,\n                format='%.0f', unit='%')\nsankey.add(flows=[25, 0, 60, -10, -20, -5, -15, -10, -40],\n           labels=['', '', '', 'First', 'Second', 'Third', 'Fourth',\n                   'Fifth', 'Hurray!'],\n           orientations=[-1, 1, 0, 1, 1, 1, -1, -1, 0],\n           pathlengths=[0.25, 0.25, 0.25, 0.25, 0.25, 0.6, 0.25, 0.25,\n                        0.25],\n           patchlabel=\"Widget\\nA\")  # Arguments to matplotlib.patches.PathPatch\ndiagrams = sankey.finish()\ndiagrams[0].texts[-1].set_color('r')\ndiagrams[0].text.set_fontweight('bold')\n\n# %%\n# Notice:\n#\n# 1. Since the sum of the flows is nonzero, the width of the trunk isn't\n#    uniform.  The matplotlib logging system logs this at the DEBUG level.\n# 2. The second flow doesn't appear because its value is zero.  Again, this is\n#    logged at the DEBUG level.\n\n\n# %%\n# Example 3\n#\n# This demonstrates:\n#\n# 1. Connecting two systems\n# 2. Turning off the labels of the quantities\n# 3. Adding a legend\n\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[], title=\"Two Systems\")\nflows = [0.25, 0.15, 0.60, -0.10, -0.05, -0.25, -0.15, -0.10, -0.35]\nsankey = Sankey(ax=ax, unit=None)\nsankey.add(flows=flows, label='one',\n           orientations=[-1, 1, 0, 1, 1, 1, -1, -1, 0])\nsankey.add(flows=[-0.25, 0.15, 0.1], label='two',\n           orientations=[-1, -1, -1], prior=0, connect=(0, 0))\ndiagrams = sankey.finish()\ndiagrams[-1].patch.set_hatch('/')\nplt.legend()\n\n# %%\n# Notice that only one connection is specified, but the systems form a\n# circuit since: (1) the lengths of the paths are justified and (2) the\n# orientation and ordering of the flows is mirrored.\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.sankey`\n#    - `matplotlib.sankey.Sankey`\n#    - `matplotlib.sankey.Sankey.add`\n#    - `matplotlib.sankey.Sankey.finish`"
      },
      {
        "image_path": "gallery_assets/19specialty_plots_267_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n======================================\nLong chain of connections using Sankey\n======================================\n\nDemonstrate/test the Sankey class by producing a long chain of connections.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.sankey import Sankey\n\nlinks_per_side = 6\n\n\ndef side(sankey, n=1):\n    \"\"\"Generate a side chain.\"\"\"\n    prior = len(sankey.diagrams)\n    for i in range(0, 2*n, 2):\n        sankey.add(flows=[1, -1], orientations=[-1, -1],\n                   patchlabel=str(prior + i),\n                   prior=prior + i - 1, connect=(1, 0), alpha=0.5)\n        sankey.add(flows=[1, -1], orientations=[1, 1],\n                   patchlabel=str(prior + i + 1),\n                   prior=prior + i, connect=(1, 0), alpha=0.5)\n\n\ndef corner(sankey):\n    \"\"\"Generate a corner link.\"\"\"\n    prior = len(sankey.diagrams)\n    sankey.add(flows=[1, -1], orientations=[0, 1],\n               patchlabel=str(prior), facecolor='k',\n               prior=prior - 1, connect=(1, 0), alpha=0.5)\n\n\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[],\n                     title=\"Why would you want to do this?\\n(But you could.)\")\nsankey = Sankey(ax=ax, unit=None)\nsankey.add(flows=[1, -1], orientations=[0, 1],\n           patchlabel=\"0\", facecolor='k',\n           rotation=45)\nside(sankey, n=links_per_side)\ncorner(sankey)\nside(sankey, n=links_per_side)\ncorner(sankey)\nside(sankey, n=links_per_side)\ncorner(sankey)\nside(sankey, n=links_per_side)\nsankey.finish()\n# Notice:\n# 1. The alignment doesn't drift significantly (if at all; with 16007\n#    subdiagrams there is still closure).\n# 2. The first diagram is rotated 45 deg, so all other diagrams are rotated\n#    accordingly.\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.sankey`\n#    - `matplotlib.sankey.Sankey`\n#    - `matplotlib.sankey.Sankey.add`\n#    - `matplotlib.sankey.Sankey.finish`"
      },
      {
        "image_path": "gallery_assets/19specialty_plots_268_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===================\nRankine power cycle\n===================\n\nDemonstrate the Sankey class with a practical example of a Rankine power cycle.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.sankey import Sankey\n\nfig = plt.figure(figsize=(8, 9))\nax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[],\n                     title=\"Rankine Power Cycle: Example 8.6 from Moran and \"\n                     \"Shapiro\\n\\x22Fundamentals of Engineering Thermodynamics \"\n                     \"\\x22, 6th ed., 2008\")\nHdot = [260.431, 35.078, 180.794, 221.115, 22.700,\n        142.361, 10.193, 10.210, 43.670, 44.312,\n        68.631, 10.758, 10.758, 0.017, 0.642,\n        232.121, 44.559, 100.613, 132.168]  # MW\nsankey = Sankey(ax=ax, format='%.3G', unit=' MW', gap=0.5, scale=1.0/Hdot[0])\nsankey.add(patchlabel='\\n\\nPump 1', rotation=90, facecolor='#37c959',\n           flows=[Hdot[13], Hdot[6], -Hdot[7]],\n           labels=['Shaft power', '', None],\n           pathlengths=[0.4, 0.883, 0.25],\n           orientations=[1, -1, 0])\nsankey.add(patchlabel='\\n\\nOpen\\nheater', facecolor='#37c959',\n           flows=[Hdot[11], Hdot[7], Hdot[4], -Hdot[8]],\n           labels=[None, '', None, None],\n           pathlengths=[0.25, 0.25, 1.93, 0.25],\n           orientations=[1, 0, -1, 0], prior=0, connect=(2, 1))\nsankey.add(patchlabel='\\n\\nPump 2', facecolor='#37c959',\n           flows=[Hdot[14], Hdot[8], -Hdot[9]],\n           labels=['Shaft power', '', None],\n           pathlengths=[0.4, 0.25, 0.25],\n           orientations=[1, 0, 0], prior=1, connect=(3, 1))\nsankey.add(patchlabel='Closed\\nheater', trunklength=2.914, fc='#37c959',\n           flows=[Hdot[9], Hdot[1], -Hdot[11], -Hdot[10]],\n           pathlengths=[0.25, 1.543, 0.25, 0.25],\n           labels=['', '', None, None],\n           orientations=[0, -1, 1, -1], prior=2, connect=(2, 0))\nsankey.add(patchlabel='Trap', facecolor='#37c959', trunklength=5.102,\n           flows=[Hdot[11], -Hdot[12]],\n           labels=['\\n', None],\n           pathlengths=[1.0, 1.01],\n           orientations=[1, 1], prior=3, connect=(2, 0))\nsankey.add(patchlabel='Steam\\ngenerator', facecolor='#ff5555',\n           flows=[Hdot[15], Hdot[10], Hdot[2], -Hdot[3], -Hdot[0]],\n           labels=['Heat rate', '', '', None, None],\n           pathlengths=0.25,\n           orientations=[1, 0, -1, -1, -1], prior=3, connect=(3, 1))\nsankey.add(patchlabel='\\n\\n\\nTurbine 1', facecolor='#37c959',\n           flows=[Hdot[0], -Hdot[16], -Hdot[1], -Hdot[2]],\n           labels=['', None, None, None],\n           pathlengths=[0.25, 0.153, 1.543, 0.25],\n           orientations=[0, 1, -1, -1], prior=5, connect=(4, 0))\nsankey.add(patchlabel='\\n\\n\\nReheat', facecolor='#37c959',\n           flows=[Hdot[2], -Hdot[2]],\n           labels=[None, None],\n           pathlengths=[0.725, 0.25],\n           orientations=[-1, 0], prior=6, connect=(3, 0))\nsankey.add(patchlabel='Turbine 2', trunklength=3.212, facecolor='#37c959',\n           flows=[Hdot[3], Hdot[16], -Hdot[5], -Hdot[4], -Hdot[17]],\n           labels=[None, 'Shaft power', None, '', 'Shaft power'],\n           pathlengths=[0.751, 0.15, 0.25, 1.93, 0.25],\n           orientations=[0, -1, 0, -1, 1], prior=6, connect=(1, 1))\nsankey.add(patchlabel='Condenser', facecolor='#58b1fa', trunklength=1.764,\n           flows=[Hdot[5], -Hdot[18], -Hdot[6]],\n           labels=['', 'Heat rate', None],\n           pathlengths=[0.45, 0.25, 0.883],\n           orientations=[-1, 1, 0], prior=8, connect=(2, 0))\ndiagrams = sankey.finish()\nfor diagram in diagrams:\n    diagram.text.set_fontweight('bold')\n    diagram.text.set_fontsize('10')\n    for text in diagram.texts:\n        text.set_fontsize('10')\n# Notice that the explicit connections are handled automatically, but the\n# implicit ones currently are not.  The lengths of the paths and the trunks\n# must be adjusted manually, and that is a bit tricky.\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.sankey`\n#    - `matplotlib.sankey.Sankey`\n#    - `matplotlib.sankey.Sankey.add`\n#    - `matplotlib.sankey.Sankey.finish`"
      }
    ],
    "20spines": [
      {
        "image_path": "gallery_assets/20spines_269_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========================\nCentered spines with arrows\n===========================\n\nThis example shows a way to draw a \"math textbook\" style plot, where the\nspines (\"axes lines\") are drawn at ``x = 0`` and ``y = 0``, and have arrows at\ntheir ends.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots()\n# Move the left and bottom spines to x = 0 and y = 0, respectively.\nax.spines[[\"left\", \"bottom\"]].set_position((\"data\", 0))\n# Hide the top and right spines.\nax.spines[[\"top\", \"right\"]].set_visible(False)\n\n# Draw arrows (as black triangles: \">k\"/\"^k\") at the end of the axes.  In each\n# case, one of the coordinates (0) is a data coordinate (i.e., y = 0 or x = 0,\n# respectively) and the other one (1) is an axes coordinate (i.e., at the very\n# right/top of the axes).  Also, disable clipping (clip_on=False) as the marker\n# actually spills out of the axes.\nax.plot(1, 0, \">k\", transform=ax.get_yaxis_transform(), clip_on=False)\nax.plot(0, 1, \"^k\", transform=ax.get_xaxis_transform(), clip_on=False)\n\n# Some sample data.\nx = np.linspace(-0.5, 1., 100)\nax.plot(x, np.sin(x*np.pi))\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/20spines_270_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "r\"\"\"\n===========================\nMultiple y-axis with Spines\n===========================\n\nCreate multiple y axes with a shared x-axis. This is done by creating\na `~.axes.Axes.twinx` axes, turning all spines but the right one invisible\nand offset its position using `~.spines.Spine.set_position`.\n\nNote that this approach uses `matplotlib.axes.Axes` and their\n`~matplotlib.spines.Spine`\\s.  Alternative approaches using non-standard axes\nare shown in the :doc:`/gallery/axisartist/demo_parasite_axes` and\n:doc:`/gallery/axisartist/demo_parasite_axes2` examples.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\nfig.subplots_adjust(right=0.75)\n\ntwin1 = ax.twinx()\ntwin2 = ax.twinx()\n\n# Offset the right spine of twin2.  The ticks and label have already been\n# placed on the right by twinx above.\ntwin2.spines.right.set_position((\"axes\", 1.2))\n\np1, = ax.plot([0, 1, 2], [0, 1, 2], \"C0\", label=\"Density\")\np2, = twin1.plot([0, 1, 2], [0, 3, 2], \"C1\", label=\"Temperature\")\np3, = twin2.plot([0, 1, 2], [50, 30, 15], \"C2\", label=\"Velocity\")\n\nax.set(xlim=(0, 2), ylim=(0, 2), xlabel=\"Distance\", ylabel=\"Density\")\ntwin1.set(ylim=(0, 4), ylabel=\"Temperature\")\ntwin2.set(ylim=(1, 65), ylabel=\"Velocity\")\n\nax.yaxis.label.set_color(p1.get_color())\ntwin1.yaxis.label.set_color(p2.get_color())\ntwin2.yaxis.label.set_color(p3.get_color())\n\nax.tick_params(axis='y', colors=p1.get_color())\ntwin1.tick_params(axis='y', colors=p2.get_color())\ntwin2.tick_params(axis='y', colors=p3.get_color())\n\nax.legend(handles=[p1, p2, p3])\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/20spines_271_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============\nSpine placement\n===============\n\nThe position of the axis spines can be influenced using `~.Spine.set_position`.\n\nNote: If you want to obtain arrow heads at the ends of the axes, also check\nout the :doc:`/gallery/spines/centered_spines_with_arrows` example.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# %%\n\nx = np.linspace(0, 2*np.pi, 100)\ny = 2 * np.sin(x)\n\nfig, ax_dict = plt.subplot_mosaic(\n    [['center', 'zero'],\n     ['axes', 'data']]\n)\nfig.suptitle('Spine positions')\n\n\nax = ax_dict['center']\nax.set_title(\"'center'\")\nax.plot(x, y)\nax.spines[['left', 'bottom']].set_position('center')\nax.spines[['top', 'right']].set_visible(False)\n\nax = ax_dict['zero']\nax.set_title(\"'zero'\")\nax.plot(x, y)\nax.spines[['left', 'bottom']].set_position('zero')\nax.spines[['top', 'right']].set_visible(False)\n\nax = ax_dict['axes']\nax.set_title(\"'axes' (0.2, 0.2)\")\nax.plot(x, y)\nax.spines.left.set_position(('axes', 0.2))\nax.spines.bottom.set_position(('axes', 0.2))\nax.spines[['top', 'right']].set_visible(False)\n\nax = ax_dict['data']\nax.set_title(\"'data' (1, 2)\")\nax.plot(x, y)\nax.spines.left.set_position(('data', 1))\nax.spines.bottom.set_position(('data', 2))\nax.spines[['top', 'right']].set_visible(False)\n\n# %%\n# Define a method that adjusts the location of the axis spines\n\n\ndef adjust_spines(ax, spines):\n    for loc, spine in ax.spines.items():\n        if loc in spines:\n            spine.set_position(('outward', 10))  # outward by 10 points\n        else:\n            spine.set_color('none')  # don't draw spine\n\n    # turn off ticks where there is no spine\n    if 'left' in spines:\n        ax.yaxis.set_ticks_position('left')\n    else:\n        # no yaxis ticks\n        ax.yaxis.set_ticks([])\n\n    if 'bottom' in spines:\n        ax.xaxis.set_ticks_position('bottom')\n    else:\n        # no xaxis ticks\n        ax.xaxis.set_ticks([])\n\n\n# %%\n# Create another figure using our new ``adjust_spines`` method\n\nfig = plt.figure()\n\nx = np.linspace(0, 2 * np.pi, 100)\ny = 2 * np.sin(x)\n\nax = fig.add_subplot(2, 2, 1)\nax.plot(x, y, clip_on=False)\nadjust_spines(ax, ['left'])\n\nax = fig.add_subplot(2, 2, 2)\nax.plot(x, y, clip_on=False)\nadjust_spines(ax, [])\n\nax = fig.add_subplot(2, 2, 3)\nax.plot(x, y, clip_on=False)\nadjust_spines(ax, ['left', 'bottom'])\n\nax = fig.add_subplot(2, 2, 4)\nax.plot(x, y, clip_on=False)\nadjust_spines(ax, ['bottom'])\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/20spines_272_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n======\nSpines\n======\n\nThis demo compares:\n\n- normal Axes, with spines on all four sides;\n- an Axes with spines only on the left and bottom;\n- an Axes using custom bounds to limit the extent of the spine.\n\nEach `.axes.Axes` has a list of `.Spine` objects, accessible\nvia the container ``ax.spines``.\n\n.. redirect-from:: /gallery/spines/spines_bounds\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 2 * np.pi, 100)\ny = 2 * np.sin(x)\n\n# Constrained layout makes sure the labels don't overlap the axes.\nfig, (ax0, ax1, ax2) = plt.subplots(nrows=3, layout='constrained')\n\nax0.plot(x, y)\nax0.set_title('normal spines')\n\nax1.plot(x, y)\nax1.set_title('bottom-left spines')\n\n# Hide the right and top spines\nax1.spines.right.set_visible(False)\nax1.spines.top.set_visible(False)\n\nax2.plot(x, y)\nax2.set_title('spines with bounds limited to data range')\n\n# Only draw spines for the data range, not in the margins\nax2.spines.bottom.set_bounds(x.min(), x.max())\nax2.spines.left.set_bounds(y.min(), y.max())\n# Hide the right and top spines\nax2.spines.right.set_visible(False)\nax2.spines.top.set_visible(False)\n\nplt.show()\n\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.spines.Spine.set_visible`\n#    - `matplotlib.spines.Spine.set_bounds`"
      },
      {
        "image_path": "gallery_assets/20spines_273_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==============\nDropped spines\n==============\n\nDemo of spines offset from the axes (a.k.a. \"dropped spines\").\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\n\nimage = np.random.uniform(size=(10, 10))\nax.imshow(image, cmap=plt.cm.gray)\nax.set_title('dropped spines')\n\n# Move left and bottom spines outward by 10 points\nax.spines[['left', 'bottom']].set_position(('outward', 10))\n# Hide the right and top spines\nax.spines[['top', 'right']].set_visible(False)\n\nplt.show()"
      }
    ],
    "21ticks": [
      {
        "image_path": "gallery_assets/21ticks_274_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n====================================\nAutomatically setting tick positions\n====================================\n\nSetting the behavior of tick auto-placement.\n\nBy default, Matplotlib will choose the number of ticks and tick positions so\nthat there is a reasonable number of ticks on the axis and they are located\nat \"round\" numbers.\n\nAs a result, there may be no ticks on the edges of the plot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\ndots = np.linspace(0.3, 1.2, 10)\nX, Y = np.meshgrid(dots, dots)\nx, y = X.ravel(), Y.ravel()\nax.scatter(x, y, c=x+y)\nplt.show()\n\n# %%\n# If you want to keep ticks at round numbers, and also have ticks at the edges\n# you can switch :rc:`axes.autolimit_mode` to 'round_numbers'. This expands the\n# axis limits to the next round number.\n\nplt.rcParams['axes.autolimit_mode'] = 'round_numbers'\n\n# Note: The limits are calculated at draw-time. Therefore, when using\n# :rc:`axes.autolimit_mode` in a context manager, it is important that\n# the ``show()`` command is within the context.\n\nfig, ax = plt.subplots()\nax.scatter(x, y, c=x+y)\nplt.show()\n\n# %%\n# The round numbers autolimit_mode is still respected if you set an additional\n# margin around the data using `.Axes.set_xmargin` / `.Axes.set_ymargin`:\n\nfig, ax = plt.subplots()\nax.scatter(x, y, c=x+y)\nax.set_xmargin(0.8)\nplt.show()"
      },
      {
        "image_path": "gallery_assets/21ticks_275_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=======================\nColorbar Tick Labelling\n=======================\n\nProduce custom labelling for a colorbar.\n\nContributed by Scott Sinclair\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy.random import randn\n\nfrom matplotlib import cm\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# %%\n# Make plot with vertical (default) colorbar\n\nfig, ax = plt.subplots()\n\ndata = np.clip(randn(250, 250), -1, 1)\n\ncax = ax.imshow(data, cmap=cm.coolwarm)\nax.set_title('Gaussian noise with vertical colorbar')\n\n# Add colorbar, make sure to specify tick locations to match desired ticklabels\ncbar = fig.colorbar(cax, ticks=[-1, 0, 1])\ncbar.ax.set_yticklabels(['< -1', '0', '> 1'])  # vertically oriented colorbar\n\n# %%\n# Make plot with horizontal colorbar\n\nfig, ax = plt.subplots()\n\ndata = np.clip(randn(250, 250), -1, 1)\n\ncax = ax.imshow(data, cmap=cm.afmhot)\nax.set_title('Gaussian noise with horizontal colorbar')\n\ncbar = fig.colorbar(cax, ticks=[-1, 0, 1], orientation='horizontal')\ncbar.ax.set_xticklabels(['Low', 'Medium', 'High'])  # horizontal colorbar\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/21ticks_276_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============\nCustom Ticker\n=============\n\nThe :mod:`matplotlib.ticker` module defines many preset tickers, but was\nprimarily designed for extensibility, i.e., to support user customized ticking.\n\nIn this example, a user defined function is used to format the ticks in\nmillions of dollars on the y-axis.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n\ndef millions(x, pos):\n    \"\"\"The two arguments are the value and tick position.\"\"\"\n    return f'${x*1e-6:1.1f}M'\n\n\nfig, ax = plt.subplots()\n# set_major_formatter internally creates a FuncFormatter from the callable.\nax.yaxis.set_major_formatter(millions)\nmoney = [1.5e5, 2.5e6, 5.5e6, 2.0e7]\nax.bar(['Bill', 'Fred', 'Mary', 'Sue'], money)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axis.Axis.set_major_formatter`"
      },
      {
        "image_path": "gallery_assets/21ticks_277_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n================================================\nFormatting date ticks using ConciseDateFormatter\n================================================\n\nFinding good tick values and formatting the ticks for an axis that\nhas date data is often a challenge.  `~.dates.ConciseDateFormatter` is\nmeant to improve the strings chosen for the ticklabels, and to minimize\nthe strings used in those tick labels as much as possible.\n\n.. note::\n\n    This formatter is a candidate to become the default date tick formatter\n    in future versions of Matplotlib.  Please report any issues or\n    suggestions for improvement to the GitHub repository or mailing list.\n\n\"\"\"\nimport datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.dates as mdates\n\n# %%\n# First, the default formatter.\n\nbase = datetime.datetime(2005, 2, 1)\ndates = [base + datetime.timedelta(hours=(2 * i)) for i in range(732)]\nN = len(dates)\nnp.random.seed(19680801)\ny = np.cumsum(np.random.randn(N))\n\nfig, axs = plt.subplots(3, 1, layout='constrained', figsize=(6, 6))\nlims = [(np.datetime64('2005-02'), np.datetime64('2005-04')),\n        (np.datetime64('2005-02-03'), np.datetime64('2005-02-15')),\n        (np.datetime64('2005-02-03 11:00'), np.datetime64('2005-02-04 13:20'))]\nfor nn, ax in enumerate(axs):\n    ax.plot(dates, y)\n    ax.set_xlim(lims[nn])\n    # rotate_labels...\n    for label in ax.get_xticklabels():\n        label.set_rotation(40)\n        label.set_horizontalalignment('right')\naxs[0].set_title('Default Date Formatter')\nplt.show()\n\n# %%\n# The default date formatter is quite verbose, so we have the option of\n# using `~.dates.ConciseDateFormatter`, as shown below.  Note that\n# for this example the labels do not need to be rotated as they do for the\n# default formatter because the labels are as small as possible.\n\nfig, axs = plt.subplots(3, 1, layout='constrained', figsize=(6, 6))\nfor nn, ax in enumerate(axs):\n    locator = mdates.AutoDateLocator(minticks=3, maxticks=7)\n    formatter = mdates.ConciseDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n\n    ax.plot(dates, y)\n    ax.set_xlim(lims[nn])\naxs[0].set_title('Concise Date Formatter')\n\nplt.show()\n\n# %%\n# If all calls to axes that have dates are to be made using this converter,\n# it is probably most convenient to use the units registry where you do\n# imports:\n\nimport matplotlib.units as munits\n\nconverter = mdates.ConciseDateConverter()\nmunits.registry[np.datetime64] = converter\nmunits.registry[datetime.date] = converter\nmunits.registry[datetime.datetime] = converter\n\nfig, axs = plt.subplots(3, 1, figsize=(6, 6), layout='constrained')\nfor nn, ax in enumerate(axs):\n    ax.plot(dates, y)\n    ax.set_xlim(lims[nn])\naxs[0].set_title('Concise Date Formatter')\n\nplt.show()\n\n# %%\n# Localization of date formats\n# ============================\n#\n# Dates formats can be localized if the default formats are not desirable by\n# manipulating one of three lists of strings.\n#\n# The ``formatter.formats`` list of formats is for the normal tick labels,\n# There are six levels: years, months, days, hours, minutes, seconds.\n# The ``formatter.offset_formats`` is how the \"offset\" string on the right\n# of the axis is formatted.  This is usually much more verbose than the tick\n# labels. Finally, the ``formatter.zero_formats`` are the formats of the\n# ticks that are \"zeros\".  These are tick values that are either the first of\n# the year, month, or day of month, or the zeroth hour, minute, or second.\n# These are usually the same as the format of\n# the ticks a level above.  For example if the axis limits mean the ticks are\n# mostly days, then we label 1 Mar 2005 simply with a \"Mar\".  If the axis\n# limits are mostly hours, we label Feb 4 00:00 as simply \"Feb-4\".\n#\n# Note that these format lists can also be passed to `.ConciseDateFormatter`\n# as optional keyword arguments.\n#\n# Here we modify the labels to be \"day month year\", instead of the ISO\n# \"year month day\":\n\nfig, axs = plt.subplots(3, 1, layout='constrained', figsize=(6, 6))\n\nfor nn, ax in enumerate(axs):\n    locator = mdates.AutoDateLocator()\n    formatter = mdates.ConciseDateFormatter(locator)\n    formatter.formats = ['%y',  # ticks are mostly years\n                         '%b',       # ticks are mostly months\n                         '%d',       # ticks are mostly days\n                         '%H:%M',    # hrs\n                         '%H:%M',    # min\n                         '%S.%f', ]  # secs\n    # these are mostly just the level above...\n    formatter.zero_formats = [''] + formatter.formats[:-1]\n    # ...except for ticks that are mostly hours, then it is nice to have\n    # month-day:\n    formatter.zero_formats[3] = '%d-%b'\n\n    formatter.offset_formats = ['',\n                                '%Y',\n                                '%b %Y',\n                                '%d %b %Y',\n                                '%d %b %Y',\n                                '%d %b %Y %H:%M', ]\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n\n    ax.plot(dates, y)\n    ax.set_xlim(lims[nn])\naxs[0].set_title('Concise Date Formatter')\n\nplt.show()\n\n# %%\n# Registering a converter with localization\n# =========================================\n#\n# `.ConciseDateFormatter` doesn't have rcParams entries, but localization can\n# be accomplished by passing keyword arguments to `.ConciseDateConverter` and\n# registering the datatypes you will use with the units registry:\n\nimport datetime\n\nformats = ['%y',          # ticks are mostly years\n           '%b',     # ticks are mostly months\n           '%d',     # ticks are mostly days\n           '%H:%M',  # hrs\n           '%H:%M',  # min\n           '%S.%f', ]  # secs\n# these can be the same, except offset by one level....\nzero_formats = [''] + formats[:-1]\n# ...except for ticks that are mostly hours, then it's nice to have month-day\nzero_formats[3] = '%d-%b'\noffset_formats = ['',\n                  '%Y',\n                  '%b %Y',\n                  '%d %b %Y',\n                  '%d %b %Y',\n                  '%d %b %Y %H:%M', ]\n\nconverter = mdates.ConciseDateConverter(\n    formats=formats, zero_formats=zero_formats, offset_formats=offset_formats)\n\nmunits.registry[np.datetime64] = converter\nmunits.registry[datetime.date] = converter\nmunits.registry[datetime.datetime] = converter\n\nfig, axs = plt.subplots(3, 1, layout='constrained', figsize=(6, 6))\nfor nn, ax in enumerate(axs):\n    ax.plot(dates, y)\n    ax.set_xlim(lims[nn])\naxs[0].set_title('Concise Date Formatter registered non-default')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/21ticks_278_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================\nDate Demo Convert\n=================\n\n\"\"\"\nimport datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.dates import DateFormatter, DayLocator, HourLocator, drange\n\ndate1 = datetime.datetime(2000, 3, 2)\ndate2 = datetime.datetime(2000, 3, 6)\ndelta = datetime.timedelta(hours=6)\ndates = drange(date1, date2, delta)\n\ny = np.arange(len(dates))\n\nfig, ax = plt.subplots()\nax.plot(dates, y**2, 'o')\n\n# this is superfluous, since the autoscaler should get it right, but\n# use date2num and num2date to convert between dates and floats if\n# you want; both date2num and num2date convert an instance or sequence\nax.set_xlim(dates[0], dates[-1])\n\n# The hour locator takes the hour or sequence of hours you want to\n# tick, not the base multiple\n\nax.xaxis.set_major_locator(DayLocator())\nax.xaxis.set_minor_locator(HourLocator(range(0, 25, 6)))\nax.xaxis.set_major_formatter(DateFormatter('%Y-%m-%d'))\n\nax.fmt_xdata = DateFormatter('%Y-%m-%d %H:%M:%S')\nfig.autofmt_xdate()\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/21ticks_279_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========================================\nPlacing date ticks using recurrence rules\n=========================================\n\nThe `iCalender RFC`_ specifies *recurrence rules* (rrules), that define\ndate sequences. You can use rrules in Matplotlib to place date ticks.\n\nThis example sets custom date ticks on every 5th easter.\n\nSee https://dateutil.readthedocs.io/en/stable/rrule.html for help with rrules.\n\n.. _iCalender RFC: https://tools.ietf.org/html/rfc5545\n\"\"\"\nimport datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.dates import (YEARLY, DateFormatter, RRuleLocator, drange,\n                              rrulewrapper)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# tick every 5th easter\nrule = rrulewrapper(YEARLY, byeaster=1, interval=5)\nloc = RRuleLocator(rule)\nformatter = DateFormatter('%m/%d/%y')\ndate1 = datetime.date(1952, 1, 1)\ndate2 = datetime.date(2004, 4, 12)\ndelta = datetime.timedelta(days=100)\n\ndates = drange(date1, date2, delta)\ns = np.random.rand(len(dates))  # make up some random y values\n\n\nfig, ax = plt.subplots()\nplt.plot(dates, s, 'o')\nax.xaxis.set_major_locator(loc)\nax.xaxis.set_major_formatter(formatter)\nax.xaxis.set_tick_params(rotation=30, labelsize=10)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/21ticks_280_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=================================\nDate tick locators and formatters\n=================================\n\nThis example illustrates the usage and effect of the various date locators and\nformatters.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.dates import (FR, MO, MONTHLY, SA, SU, TH, TU, WE,\n                              AutoDateFormatter, AutoDateLocator,\n                              ConciseDateFormatter, DateFormatter, DayLocator,\n                              HourLocator, MicrosecondLocator, MinuteLocator,\n                              MonthLocator, RRuleLocator, SecondLocator,\n                              WeekdayLocator, YearLocator, rrulewrapper)\nimport matplotlib.ticker as ticker\n\nlocators = [\n    ('AutoDateLocator(maxticks=8)', '2003-02-01', '%Y-%m'),\n    ('YearLocator(month=4)', '2003-02-01', '%Y-%m'),\n    ('MonthLocator(bymonth=[4,8,12])', '2003-02-01', '%Y-%m'),\n    ('DayLocator(interval=180)', '2003-02-01', '%Y-%m-%d'),\n    ('WeekdayLocator(byweekday=SU, interval=4)', '2000-07-01', '%a %Y-%m-%d'),\n    ('HourLocator(byhour=range(0,24,6))', '2000-02-04', '%H h'),\n    ('MinuteLocator(interval=15)', '2000-02-01 02:00', '%H:%M'),\n    ('SecondLocator(bysecond=(0,30))', '2000-02-01 00:02', '%H:%M:%S'),\n    ('MicrosecondLocator(interval=1000)', '2000-02-01 00:00:00.005', '%S.%f'),\n    ('RRuleLocator(rrulewrapper(freq=MONTHLY, \\nbyweekday=(MO, TU, WE, TH,' +\n     ' FR), bysetpos=-1))', '2000-07-01', '%Y-%m-%d')\n]\n\nformatters = [\n    ('AutoDateFormatter(ax.xaxis.get_major_locator())'),\n    ('ConciseDateFormatter(ax.xaxis.get_major_locator())'),\n    ('DateFormatter(\"%b %Y\")')\n]\n\n\ndef plot_axis(ax, locator=None, xmax='2002-02-01', fmt=None, formatter=None):\n    \"\"\"Set up common parameters for the Axes in the example.\"\"\"\n    ax.spines.right.set_visible(False)\n    ax.spines.left.set_visible(False)\n    ax.spines.top.set_visible(False)\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n    ax.tick_params(which='major', width=1.00, length=5)\n    ax.tick_params(which='minor', width=0.75, length=2.5)\n    ax.set_xlim(np.datetime64('2000-02-01'), np.datetime64(xmax))\n    if locator:\n        ax.xaxis.set_major_locator(eval(locator))\n        ax.xaxis.set_major_formatter(DateFormatter(fmt))\n    else:\n        ax.xaxis.set_major_formatter(eval(formatter))\n    ax.text(0.0, 0.2, locator or formatter, transform=ax.transAxes,\n            fontsize=14, fontname='Monospace', color='tab:blue')\n\n\nfig, ax = plt.subplots(len(locators), 1, figsize=(8, len(locators) * .8),\n                       layout='constrained')\nfig.suptitle('Date Locators')\nfor i, loc in enumerate(locators):\n    plot_axis(ax[i], *loc)\n\nfig, ax = plt.subplots(len(formatters), 1, figsize=(8, len(formatters) * .8),\n                       layout='constrained')\nfig.suptitle('Date Formatters')\nfor i, fmt in enumerate(formatters):\n    plot_axis(ax[i], formatter=fmt)\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.dates.AutoDateLocator`\n#    - `matplotlib.dates.YearLocator`\n#    - `matplotlib.dates.MonthLocator`\n#    - `matplotlib.dates.DayLocator`\n#    - `matplotlib.dates.WeekdayLocator`\n#    - `matplotlib.dates.HourLocator`\n#    - `matplotlib.dates.MinuteLocator`\n#    - `matplotlib.dates.SecondLocator`\n#    - `matplotlib.dates.MicrosecondLocator`\n#    - `matplotlib.dates.RRuleLocator`\n#    - `matplotlib.dates.rrulewrapper`\n#    - `matplotlib.dates.DateFormatter`\n#    - `matplotlib.dates.AutoDateFormatter`\n#    - `matplotlib.dates.ConciseDateFormatter`"
      },
      {
        "image_path": "gallery_assets/21ticks_281_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========================\nDate Precision and Epochs\n=========================\n\nMatplotlib can handle `.datetime` objects and `numpy.datetime64` objects using\na unit converter that recognizes these dates and converts them to floating\npoint numbers.\n\nBefore Matplotlib 3.3, the default for this conversion returns a float that was\ndays since \"0000-12-31T00:00:00\".  As of Matplotlib 3.3, the default is\ndays from \"1970-01-01T00:00:00\".  This allows more resolution for modern\ndates.  \"2020-01-01\" with the old epoch converted to 730120, and a 64-bit\nfloating point number has a resolution of 2^{-52}, or approximately\n14 microseconds, so microsecond precision was lost.  With the new default\nepoch \"2020-01-01\" is 10957.0, so the achievable resolution is 0.21\nmicroseconds.\n\n\"\"\"\nimport datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.dates as mdates\n\n\ndef _reset_epoch_for_tutorial():\n    \"\"\"\n    Users (and downstream libraries) should not use the private method of\n    resetting the epoch.\n    \"\"\"\n    mdates._reset_epoch_test_example()\n\n\n# %%\n# Datetime\n# --------\n#\n# Python `.datetime` objects have microsecond resolution, so with the\n# old default matplotlib dates could not round-trip full-resolution datetime\n# objects.\n\nold_epoch = '0000-12-31T00:00:00'\nnew_epoch = '1970-01-01T00:00:00'\n\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(old_epoch)  # old epoch (pre MPL 3.3)\n\ndate1 = datetime.datetime(2000, 1, 1, 0, 10, 0, 12,\n                          tzinfo=datetime.timezone.utc)\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)\nprint('After Roundtrip:  ', date2)\n\n# %%\n# Note this is only a round-off error, and there is no problem for\n# dates closer to the old epoch:\n\ndate1 = datetime.datetime(10, 1, 1, 0, 10, 0, 12,\n                          tzinfo=datetime.timezone.utc)\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)\nprint('After Roundtrip:  ', date2)\n\n# %%\n# If a user wants to use modern dates at microsecond precision, they\n# can change the epoch using `.set_epoch`.  However, the epoch has to be\n# set before any date operations to prevent confusion between different\n# epochs. Trying to change the epoch later will raise a `RuntimeError`.\n\ntry:\n    mdates.set_epoch(new_epoch)  # this is the new MPL 3.3 default.\nexcept RuntimeError as e:\n    print('RuntimeError:', str(e))\n\n# %%\n# For this tutorial, we reset the sentinel using a private method, but users\n# should just set the epoch once, if at all.\n\n_reset_epoch_for_tutorial()  # Just being done for this tutorial.\nmdates.set_epoch(new_epoch)\n\ndate1 = datetime.datetime(2020, 1, 1, 0, 10, 0, 12,\n                          tzinfo=datetime.timezone.utc)\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)\nprint('After Roundtrip:  ', date2)\n\n# %%\n# datetime64\n# ----------\n#\n# `numpy.datetime64` objects have microsecond precision for a much larger\n# timespace than `.datetime` objects.  However, currently Matplotlib time is\n# only converted back to datetime objects, which have microsecond resolution,\n# and years that only span 0000 to 9999.\n\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(new_epoch)\n\ndate1 = np.datetime64('2000-01-01T00:10:00.000012')\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)\nprint('After Roundtrip:  ', date2)\n\n# %%\n# Plotting\n# --------\n#\n# This all of course has an effect on plotting.  With the old default epoch\n# the times were rounded during the internal ``date2num`` conversion, leading\n# to jumps in the data:\n\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(old_epoch)\n\nx = np.arange('2000-01-01T00:00:00.0', '2000-01-01T00:00:00.000100',\n              dtype='datetime64[us]')\n# simulate the plot being made using the old epoch\nxold = np.array([mdates.num2date(mdates.date2num(d)) for d in x])\ny = np.arange(0, len(x))\n\n# resetting the Epoch so plots are comparable\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(new_epoch)\n\nfig, ax = plt.subplots(layout='constrained')\nax.plot(xold, y)\nax.set_title('Epoch: ' + mdates.get_epoch())\nax.xaxis.set_tick_params(rotation=40)\nplt.show()\n\n# %%\n# For dates plotted using the more recent epoch, the plot is smooth:\n\nfig, ax = plt.subplots(layout='constrained')\nax.plot(x, y)\nax.set_title('Epoch: ' + mdates.get_epoch())\nax.xaxis.set_tick_params(rotation=40)\nplt.show()\n\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.dates.num2date`\n#    - `matplotlib.dates.date2num`\n#    - `matplotlib.dates.set_epoch`"
      },
      {
        "image_path": "gallery_assets/21ticks_282_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============\nDollar ticks\n============\n\nUse a `~.ticker.FormatStrFormatter` to prepend dollar signs on y-axis labels.\n\n.. redirect-from:: /gallery/pyplots/dollar_ticks\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\nax.plot(100*np.random.rand(20))\n\n# Use automatic StrMethodFormatter\nax.yaxis.set_major_formatter('${x:1.2f}')\n\nax.yaxis.set_tick_params(which='major', labelcolor='green',\n                         labelleft=False, labelright=True)\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.axis.Axis.set_major_formatter`\n#    - `matplotlib.axis.Axis.set_tick_params`\n#    - `matplotlib.axis.Tick`\n#    - `matplotlib.ticker.StrMethodFormatter`"
      },
      {
        "image_path": "gallery_assets/21ticks_283_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========================\nFig Axes Customize Simple\n=========================\n\nCustomize the background, labels and ticks of a simple plot.\n\n.. redirect-from:: /gallery/pyplots/fig_axes_customize_simple\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n# %%\n# `.pyplot.figure` creates a `matplotlib.figure.Figure` instance.\n\nfig = plt.figure()\nrect = fig.patch  # a rectangle instance\nrect.set_facecolor('lightgoldenrodyellow')\n\nax1 = fig.add_axes([0.1, 0.3, 0.4, 0.4])\nrect = ax1.patch\nrect.set_facecolor('lightslategray')\n\nax1.tick_params(axis='x', labelcolor='tab:red', labelrotation=45, labelsize=16)\nax1.tick_params(axis='y', color='tab:green', size=25, width=3)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axis.Axis.get_ticklabels`\n#    - `matplotlib.axis.Axis.get_ticklines`\n#    - `matplotlib.text.Text.set_rotation`\n#    - `matplotlib.text.Text.set_fontsize`\n#    - `matplotlib.text.Text.set_color`\n#    - `matplotlib.lines.Line2D`\n#    - `matplotlib.lines.Line2D.set_markeredgecolor`\n#    - `matplotlib.lines.Line2D.set_markersize`\n#    - `matplotlib.lines.Line2D.set_markeredgewidth`\n#    - `matplotlib.patches.Patch.set_facecolor`"
      },
      {
        "image_path": "gallery_assets/21ticks_284_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "r\"\"\"\n=====================\nMajor and minor ticks\n=====================\n\nDemonstrate how to use major and minor tickers.\n\nThe two relevant classes are `.Locator`\\s and `.Formatter`\\s.  Locators\ndetermine where the ticks are, and formatters control the formatting of tick\nlabels.\n\nMinor ticks are off by default (using `.NullLocator` and `.NullFormatter`).\nMinor ticks can be turned on without labels by setting the minor locator.\nMinor tick labels can be turned on by setting the minor formatter.\n\n`.MultipleLocator` places ticks on multiples of some base.\n`.StrMethodFormatter` uses a format string (e.g., ``'{x:d}'`` or ``'{x:1.2f}'``\nor ``'{x:1.1f} cm'``) to format the tick labels (the variable in the format\nstring must be ``'x'``).  For a `.StrMethodFormatter`, the string can be passed\ndirectly to `.Axis.set_major_formatter` or\n`.Axis.set_minor_formatter`.  An appropriate `.StrMethodFormatter` will\nbe created and used automatically.\n\n`.pyplot.grid` changes the grid settings of the major ticks of the x- and\ny-axis together.  If you want to control the grid of the minor ticks for a\ngiven axis, use for example ::\n\n  ax.xaxis.grid(True, which='minor')\n\nNote that a given locator or formatter instance can only be used on a single\naxis (because the locator stores references to the axis data and view limits).\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.ticker import AutoMinorLocator, MultipleLocator\n\nt = np.arange(0.0, 100.0, 0.1)\ns = np.sin(0.1 * np.pi * t) * np.exp(-t * 0.01)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\n# Make a plot with major ticks that are multiples of 20 and minor ticks that\n# are multiples of 5.  Label major ticks with '.0f' formatting but don't label\n# minor ticks.  The string is used directly, the `StrMethodFormatter` is\n# created automatically.\nax.xaxis.set_major_locator(MultipleLocator(20))\nax.xaxis.set_major_formatter('{x:.0f}')\n\n# For the minor ticks, use no labels; default NullFormatter.\nax.xaxis.set_minor_locator(MultipleLocator(5))\n\nplt.show()\n\n# %%\n# Automatic tick selection for major and minor ticks.\n#\n# Use interactive pan and zoom to see how the tick intervals change. There will\n# be either 4 or 5 minor tick intervals per major interval, depending on the\n# major interval.\n#\n# One can supply an argument to `.AutoMinorLocator` to specify a fixed number\n# of minor intervals per major interval, e.g. ``AutoMinorLocator(2)`` would\n# lead to a single minor tick between major ticks.\n\nt = np.arange(0.0, 100.0, 0.01)\ns = np.sin(2 * np.pi * t) * np.exp(-t * 0.01)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\nax.xaxis.set_minor_locator(AutoMinorLocator())\n\nax.tick_params(which='both', width=2)\nax.tick_params(which='major', length=7)\nax.tick_params(which='minor', length=4, color='r')\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.axis.Axis.set_major_formatter`\n#    - `matplotlib.axis.Axis.set_major_locator`\n#    - `matplotlib.axis.Axis.set_minor_locator`\n#    - `matplotlib.ticker.AutoMinorLocator`\n#    - `matplotlib.ticker.MultipleLocator`\n#    - `matplotlib.ticker.StrMethodFormatter`"
      },
      {
        "image_path": "gallery_assets/21ticks_285_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==========================\nThe default tick formatter\n==========================\n\nThe example shows use of the default `.ScalarFormatter` with different\nsettings.\n\nExample 1 : Default\n\nExample 2 : With no Numerical Offset\n\nExample 3 : With Mathtext\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# %%\n# Example 1\n\nx = np.arange(0, 1, .01)\nfig, [[ax1, ax2], [ax3, ax4]] = plt.subplots(2, 2, figsize=(6, 6))\nfig.text(0.5, 0.975, 'Default settings',\n         horizontalalignment='center',\n         verticalalignment='top')\n\nax1.plot(x * 1e5 + 1e10, x * 1e-10 + 1e-5)\n\nax2.plot(x * 1e5, x * 1e-4)\n\nax3.plot(-x * 1e5 - 1e10, -x * 1e-5 - 1e-10)\n\nax4.plot(-x * 1e5, -x * 1e-4)\n\nfig.subplots_adjust(wspace=0.7, hspace=0.6)\n\n# %%\n# Example 2\n\nx = np.arange(0, 1, .01)\nfig, [[ax1, ax2], [ax3, ax4]] = plt.subplots(2, 2, figsize=(6, 6))\nfig.text(0.5, 0.975, 'No numerical offset',\n         horizontalalignment='center',\n         verticalalignment='top')\n\nax1.plot(x * 1e5 + 1e10, x * 1e-10 + 1e-5)\nax1.ticklabel_format(useOffset=False)\n\nax2.plot(x * 1e5, x * 1e-4)\nax2.ticklabel_format(useOffset=False)\n\nax3.plot(-x * 1e5 - 1e10, -x * 1e-5 - 1e-10)\nax3.ticklabel_format(useOffset=False)\n\nax4.plot(-x * 1e5, -x * 1e-4)\nax4.ticklabel_format(useOffset=False)\n\nfig.subplots_adjust(wspace=0.7, hspace=0.6)\n\n# %%\n# Example 3\n\nx = np.arange(0, 1, .01)\nfig, [[ax1, ax2], [ax3, ax4]] = plt.subplots(2, 2, figsize=(6, 6))\nfig.text(0.5, 0.975, 'With mathtext',\n         horizontalalignment='center',\n         verticalalignment='top')\n\nax1.plot(x * 1e5 + 1e10, x * 1e-10 + 1e-5)\nax1.ticklabel_format(useMathText=True)\n\nax2.plot(x * 1e5, x * 1e-4)\nax2.ticklabel_format(useMathText=True)\n\nax3.plot(-x * 1e5 - 1e10, -x * 1e-5 - 1e-10)\nax3.ticklabel_format(useMathText=True)\n\nax4.plot(-x * 1e5, -x * 1e-4)\nax4.ticklabel_format(useMathText=True)\n\nfig.subplots_adjust(wspace=0.7, hspace=0.6)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/21ticks_286_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===============\nTick formatters\n===============\n\nTick formatters define how the numeric value associated with a tick on an axis\nis formatted as a string.\n\nThis example illustrates the usage and effect of the most common formatters.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib import ticker\n\n\ndef setup(ax, title):\n    \"\"\"Set up common parameters for the Axes in the example.\"\"\"\n    # only show the bottom spine\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n    ax.spines[['left', 'right', 'top']].set_visible(False)\n\n    # define tick positions\n    ax.xaxis.set_major_locator(ticker.MultipleLocator(1.00))\n    ax.xaxis.set_minor_locator(ticker.MultipleLocator(0.25))\n\n    ax.xaxis.set_ticks_position('bottom')\n    ax.tick_params(which='major', width=1.00, length=5)\n    ax.tick_params(which='minor', width=0.75, length=2.5, labelsize=10)\n    ax.set_xlim(0, 5)\n    ax.set_ylim(0, 1)\n    ax.text(0.0, 0.2, title, transform=ax.transAxes,\n            fontsize=14, fontname='Monospace', color='tab:blue')\n\n\n# %%\n# Tick formatters can be set in one of two ways, either by passing a ``str``\n# or function to `~.Axis.set_major_formatter` or `~.Axis.set_minor_formatter`,\n# or by creating an instance of one of the various `~.ticker.Formatter` classes\n# and providing that to `~.Axis.set_major_formatter` or\n# `~.Axis.set_minor_formatter`.\n#\n# The first two examples directly pass a ``str`` or function.\n\nfig0, axs0 = plt.subplots(2, 1, figsize=(8, 2))\nfig0.suptitle('Simple Formatting')\n\n# A ``str``, using format string function syntax, can be used directly as a\n# formatter.  The variable ``x`` is the tick value and the variable ``pos`` is\n# tick position.  This creates a StrMethodFormatter automatically.\nsetup(axs0[0], title=\"'{x} km'\")\naxs0[0].xaxis.set_major_formatter('{x} km')\n\n# A function can also be used directly as a formatter. The function must take\n# two arguments: ``x`` for the tick value and ``pos`` for the tick position,\n# and must return a ``str``. This creates a FuncFormatter automatically.\nsetup(axs0[1], title=\"lambda x, pos: str(x-5)\")\naxs0[1].xaxis.set_major_formatter(lambda x, pos: str(x-5))\n\nfig0.tight_layout()\n\n\n# %%\n# The remaining examples use `.Formatter` objects.\n\nfig1, axs1 = plt.subplots(7, 1, figsize=(8, 6))\nfig1.suptitle('Formatter Object Formatting')\n\n# Null formatter\nsetup(axs1[0], title=\"NullFormatter()\")\naxs1[0].xaxis.set_major_formatter(ticker.NullFormatter())\n\n# StrMethod formatter\nsetup(axs1[1], title=\"StrMethodFormatter('{x:.3f}')\")\naxs1[1].xaxis.set_major_formatter(ticker.StrMethodFormatter(\"{x:.3f}\"))\n\n\n# FuncFormatter can be used as a decorator\n@ticker.FuncFormatter\ndef major_formatter(x, pos):\n    return f'[{x:.2f}]'\n\n\nsetup(axs1[2], title='FuncFormatter(\"[{:.2f}]\".format)')\naxs1[2].xaxis.set_major_formatter(major_formatter)\n\n# Fixed formatter\nsetup(axs1[3], title=\"FixedFormatter(['A', 'B', 'C', ...])\")\n# FixedFormatter should only be used together with FixedLocator.\n# Otherwise, one cannot be sure where the labels will end up.\npositions = [0, 1, 2, 3, 4, 5]\nlabels = ['A', 'B', 'C', 'D', 'E', 'F']\naxs1[3].xaxis.set_major_locator(ticker.FixedLocator(positions))\naxs1[3].xaxis.set_major_formatter(ticker.FixedFormatter(labels))\n\n# Scalar formatter\nsetup(axs1[4], title=\"ScalarFormatter()\")\naxs1[4].xaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True))\n\n# FormatStr formatter\nsetup(axs1[5], title=\"FormatStrFormatter('#%d')\")\naxs1[5].xaxis.set_major_formatter(ticker.FormatStrFormatter(\"#%d\"))\n\n# Percent formatter\nsetup(axs1[6], title=\"PercentFormatter(xmax=5)\")\naxs1[6].xaxis.set_major_formatter(ticker.PercentFormatter(xmax=5))\n\nfig1.tight_layout()\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.axes.Axes.text`\n#    - `matplotlib.axis.Axis.set_major_formatter`\n#    - `matplotlib.axis.Axis.set_major_locator`\n#    - `matplotlib.axis.Axis.set_minor_locator`\n#    - `matplotlib.axis.XAxis.set_ticks_position`\n#    - `matplotlib.axis.YAxis.set_ticks_position`\n#    - `matplotlib.ticker.FixedFormatter`\n#    - `matplotlib.ticker.FixedLocator`\n#    - `matplotlib.ticker.FormatStrFormatter`\n#    - `matplotlib.ticker.FuncFormatter`\n#    - `matplotlib.ticker.MultipleLocator`\n#    - `matplotlib.ticker.NullFormatter`\n#    - `matplotlib.ticker.NullLocator`\n#    - `matplotlib.ticker.PercentFormatter`\n#    - `matplotlib.ticker.ScalarFormatter`\n#    - `matplotlib.ticker.StrMethodFormatter`"
      },
      {
        "image_path": "gallery_assets/21ticks_287_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=============\nTick locators\n=============\n\nTick locators define the position of the ticks.\n\nThis example illustrates the usage and effect of the most common locators.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as ticker\n\n\ndef setup(ax, title):\n    \"\"\"Set up common parameters for the Axes in the example.\"\"\"\n    # only show the bottom spine\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n    ax.spines[['left', 'right', 'top']].set_visible(False)\n\n    ax.xaxis.set_ticks_position('bottom')\n    ax.tick_params(which='major', width=1.00, length=5)\n    ax.tick_params(which='minor', width=0.75, length=2.5)\n    ax.set_xlim(0, 5)\n    ax.set_ylim(0, 1)\n    ax.text(0.0, 0.2, title, transform=ax.transAxes,\n            fontsize=14, fontname='Monospace', color='tab:blue')\n\n\nfig, axs = plt.subplots(8, 1, figsize=(8, 6))\n\n# Null Locator\nsetup(axs[0], title=\"NullLocator()\")\naxs[0].xaxis.set_major_locator(ticker.NullLocator())\naxs[0].xaxis.set_minor_locator(ticker.NullLocator())\n\n# Multiple Locator\nsetup(axs[1], title=\"MultipleLocator(0.5)\")\naxs[1].xaxis.set_major_locator(ticker.MultipleLocator(0.5))\naxs[1].xaxis.set_minor_locator(ticker.MultipleLocator(0.1))\n\n# Fixed Locator\nsetup(axs[2], title=\"FixedLocator([0, 1, 5])\")\naxs[2].xaxis.set_major_locator(ticker.FixedLocator([0, 1, 5]))\naxs[2].xaxis.set_minor_locator(ticker.FixedLocator(np.linspace(0.2, 0.8, 4)))\n\n# Linear Locator\nsetup(axs[3], title=\"LinearLocator(numticks=3)\")\naxs[3].xaxis.set_major_locator(ticker.LinearLocator(3))\naxs[3].xaxis.set_minor_locator(ticker.LinearLocator(31))\n\n# Index Locator\nsetup(axs[4], title=\"IndexLocator(base=0.5, offset=0.25)\")\naxs[4].plot(range(0, 5), [0]*5, color='white')\naxs[4].xaxis.set_major_locator(ticker.IndexLocator(base=0.5, offset=0.25))\n\n# Auto Locator\nsetup(axs[5], title=\"AutoLocator()\")\naxs[5].xaxis.set_major_locator(ticker.AutoLocator())\naxs[5].xaxis.set_minor_locator(ticker.AutoMinorLocator())\n\n# MaxN Locator\nsetup(axs[6], title=\"MaxNLocator(n=4)\")\naxs[6].xaxis.set_major_locator(ticker.MaxNLocator(4))\naxs[6].xaxis.set_minor_locator(ticker.MaxNLocator(40))\n\n# Log Locator\nsetup(axs[7], title=\"LogLocator(base=10, numticks=15)\")\naxs[7].set_xlim(10**3, 10**10)\naxs[7].set_xscale('log')\naxs[7].xaxis.set_major_locator(ticker.LogLocator(base=10, numticks=15))\n\nplt.tight_layout()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The following functions, methods, classes and modules are used in this example:\n#\n#    - `matplotlib.axis.Axis.set_major_locator`\n#    - `matplotlib.axis.Axis.set_minor_locator`\n#    - `matplotlib.ticker.NullLocator`\n#    - `matplotlib.ticker.MultipleLocator`\n#    - `matplotlib.ticker.FixedLocator`\n#    - `matplotlib.ticker.LinearLocator`\n#    - `matplotlib.ticker.IndexLocator`\n#    - `matplotlib.ticker.AutoLocator`\n#    - `matplotlib.ticker.MaxNLocator`\n#    - `matplotlib.ticker.LogLocator`"
      },
      {
        "image_path": "gallery_assets/21ticks_288_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n============================================\nSet default y-axis tick labels on the right\n============================================\n\nWe can use :rc:`ytick.labelright`, :rc:`ytick.right`, :rc:`ytick.labelleft`,\nand :rc:`ytick.left` to control where on the axes ticks and their labels\nappear. These properties can also be set in ``.matplotlib/matplotlibrc``.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.rcParams['ytick.right'] = plt.rcParams['ytick.labelright'] = True\nplt.rcParams['ytick.left'] = plt.rcParams['ytick.labelleft'] = False\n\nx = np.arange(10)\n\nfig, (ax0, ax1) = plt.subplots(2, 1, sharex=True, figsize=(6, 6))\n\nax0.plot(x)\nax0.yaxis.tick_left()\n\n# use default parameter in rcParams, not calling tick_right()\nax1.plot(x)\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/21ticks_289_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=========================================\nSetting tick labels from a list of values\n=========================================\n\nUsing `.Axes.set_xticks` causes the tick labels to be set on the currently\nchosen ticks. However, you may want to allow matplotlib to dynamically\nchoose the number of ticks and their spacing.\n\nIn this case it may be better to determine the tick label from the\nvalue at the tick. The following example shows how to do this.\n\nNB: The `.ticker.MaxNLocator` is used here to ensure that the tick values\ntake integer values.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.ticker import MaxNLocator\n\nfig, ax = plt.subplots()\nxs = range(26)\nys = range(26)\nlabels = list('abcdefghijklmnopqrstuvwxyz')\n\n\ndef format_fn(tick_val, tick_pos):\n    if int(tick_val) in xs:\n        return labels[int(tick_val)]\n    else:\n        return ''\n\n\n# A FuncFormatter is created automatically.\nax.xaxis.set_major_formatter(format_fn)\nax.xaxis.set_major_locator(MaxNLocator(integer=True))\nax.plot(xs, ys)\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.axis.Axis.set_major_formatter`\n#    - `matplotlib.axis.Axis.set_major_locator`\n#    - `matplotlib.ticker.FuncFormatter`\n#    - `matplotlib.ticker.MaxNLocator`"
      },
      {
        "image_path": "gallery_assets/21ticks_290_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n==================================\nMove x-axis tick labels to the top\n==================================\n\n`~.axes.Axes.tick_params` can be used to configure the ticks. *top* and\n*labeltop* control the visibility tick lines and labels at the top x-axis.\nTo move x-axis ticks from bottom to top, we have to activate the top ticks\nand deactivate the bottom ticks::\n\n    ax.tick_params(top=True, labeltop=True, bottom=False, labelbottom=False)\n\n.. note::\n\n    If the change should be made for all future plots and not only the current\n    Axes, you can adapt the respective config parameters\n\n    - :rc:`xtick.top`\n    - :rc:`xtick.labeltop`\n    - :rc:`xtick.bottom`\n    - :rc:`xtick.labelbottom`\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\nax.plot(range(10))\nax.tick_params(top=True, labeltop=True, bottom=False, labelbottom=False)\nax.set_title('x-ticks moved to the top')\n\nplt.show()"
      },
      {
        "image_path": "gallery_assets/21ticks_291_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n===========================\nRotating custom tick labels\n===========================\n\nDemo of custom tick-labels with user-defined rotation.\n\"\"\"\nimport matplotlib.pyplot as plt\n\nx = [1, 2, 3, 4]\ny = [1, 4, 9, 6]\nlabels = ['Frogs', 'Hogs', 'Bogs', 'Slogs']\n\nplt.plot(x, y)\n# You can specify a rotation for the tick labels in degrees or with keywords.\nplt.xticks(x, labels, rotation='vertical')\n# Pad margins so that markers don't get clipped by the axes\nplt.margins(0.2)\n# Tweak spacing to prevent clipping of tick-labels\nplt.subplots_adjust(bottom=0.15)\nplt.show()"
      },
      {
        "image_path": "gallery_assets/21ticks_292_Example.png",
        "celltype": "Normal",
        "css": "border: 3px solid #007AB8;width:120px",
        "code": "\"\"\"\n=====================\nFixing too many ticks\n=====================\n\nOne common cause for unexpected tick behavior is passing a list of strings\ninstead of numbers or datetime objects. This can easily happen without notice\nwhen reading in a comma-delimited text file. Matplotlib treats lists of strings\nas *categorical* variables\n(:doc:`/gallery/lines_bars_and_markers/categorical_variables`), and by default\nputs one tick per category, and plots them in the order in which they are\nsupplied.  If this is not desired, the solution is to convert the strings to\na numeric type as in the following examples.\n\n\"\"\"\n\n# %%\n# Example 1: Strings can lead to an unexpected order of number ticks\n# ------------------------------------------------------------------\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots(1, 2, layout='constrained', figsize=(6, 2.5))\nx = ['1', '5', '2', '3']\ny = [1, 4, 2, 3]\nax[0].plot(x, y, 'd')\nax[0].tick_params(axis='x', color='r', labelcolor='r')\nax[0].set_xlabel('Categories')\nax[0].set_title('Ticks seem out of order / misplaced')\n\n# convert to numbers:\nx = np.asarray(x, dtype='float')\nax[1].plot(x, y, 'd')\nax[1].set_xlabel('Floats')\nax[1].set_title('Ticks as expected')\n\n# %%\n# Example 2: Strings can lead to very many ticks\n# ----------------------------------------------\n# If *x* has 100 elements, all strings, then we would have 100 (unreadable)\n# ticks, and again the solution is to convert the strings to floats:\n\nfig, ax = plt.subplots(1, 2, figsize=(6, 2.5))\nx = [f'{xx}' for xx in np.arange(100)]\ny = np.arange(100)\nax[0].plot(x, y)\nax[0].tick_params(axis='x', color='r', labelcolor='r')\nax[0].set_title('Too many ticks')\nax[0].set_xlabel('Categories')\n\nax[1].plot(np.asarray(x, float), y)\nax[1].set_title('x converted to numbers')\nax[1].set_xlabel('Floats')\n\n# %%\n# Example 3: Strings can lead to an unexpected order of datetime ticks\n# --------------------------------------------------------------------\n# A common case is when dates are read from a CSV file, they need to be\n# converted from strings to datetime objects to get the proper date locators\n# and formatters.\n\nfig, ax = plt.subplots(1, 2, layout='constrained', figsize=(6, 2.75))\nx = ['2021-10-01', '2021-11-02', '2021-12-03', '2021-09-01']\ny = [0, 2, 3, 1]\nax[0].plot(x, y, 'd')\nax[0].tick_params(axis='x', labelrotation=90, color='r', labelcolor='r')\nax[0].set_title('Dates out of order')\n\n# convert to datetime64\nx = np.asarray(x, dtype='datetime64[s]')\nax[1].plot(x, y, 'd')\nax[1].tick_params(axis='x', labelrotation=90)\nax[1].set_title('x converted to datetimes')\n\nplt.show()"
      }
    ]
  }
}